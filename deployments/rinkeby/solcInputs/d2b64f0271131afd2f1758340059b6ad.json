{
  "language": "Solidity",
  "sources": {
    "contracts/external/FixedPoint.sol": {
      "content": "// solhint-disable\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\";\n\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/protocol/Accountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./CreditLine.sol\";\nimport \"../external/FixedPoint.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @title The Accountant\n * @notice Library for handling key financial calculations, such as interest and principal accrual.\n * @author Goldfinch\n */\n\nlibrary Accountant {\n  using SafeMath for uint256;\n  using FixedPoint for FixedPoint.Signed;\n  using FixedPoint for FixedPoint.Unsigned;\n  using FixedPoint for int256;\n  using FixedPoint for uint256;\n\n  // Scaling factor used by FixedPoint.sol. We need this to convert the fixed point raw values back to unscaled\n  uint256 public constant FP_SCALING_FACTOR = 10**18;\n  uint256 public constant INTEREST_DECIMALS = 1e8;\n  uint256 public constant BLOCKS_PER_DAY = 5760;\n  uint256 public constant BLOCKS_PER_YEAR = (BLOCKS_PER_DAY * 365);\n\n  struct PaymentAllocation {\n    uint256 interestPayment;\n    uint256 principalPayment;\n    uint256 additionalBalancePayment;\n  }\n\n  function calculateInterestAndPrincipalAccrued(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 lateFeeGracePeriod\n  ) public view returns (uint256, uint256) {\n    uint256 interestAccrued = calculateInterestAccrued(cl, blockNumber, lateFeeGracePeriod);\n    uint256 principalAccrued = calculatePrincipalAccrued(cl, blockNumber);\n    return (interestAccrued, principalAccrued);\n  }\n\n  function calculatePrincipalAccrued(CreditLine cl, uint256 blockNumber) public view returns (uint256) {\n    if (blockNumber >= cl.termEndBlock()) {\n      return cl.balance();\n    } else {\n      return 0;\n    }\n  }\n\n  function calculateWritedownFor(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 gracePeriodInDays,\n    uint256 maxDaysLate\n  ) public view returns (uint256, uint256) {\n    FixedPoint.Unsigned memory amountOwedPerDay = calculateAmountOwedForOneDay(cl);\n    if (amountOwedPerDay.isEqual(0)) {\n      return (0, 0);\n    }\n    FixedPoint.Unsigned memory fpGracePeriod =\n      FixedPoint.min(\n        FixedPoint.fromUnscaledUint(gracePeriodInDays),\n        FixedPoint.fromUnscaledUint(cl.paymentPeriodInDays())\n      );\n    FixedPoint.Unsigned memory daysLate;\n\n    // Excel math: =min(1,max(0,periods_late_in_days-graceperiod_in_days)/MAX_ALLOWED_DAYS_LATE) grace_period = 30,\n    // Before the term end block, we use the interestOwed to calculate the periods late. However, after the loan term\n    // has ended, since the interest is a much smaller fraction of the principal, we cannot reliably use interest to\n    // calculate the periods later.\n    uint256 totalOwed = cl.interestOwed().add(cl.principalOwed());\n    daysLate = FixedPoint.fromUnscaledUint(totalOwed).div(amountOwedPerDay);\n    if (blockNumber > cl.termEndBlock()) {\n      uint256 blocksLate = blockNumber.sub(cl.termEndBlock());\n      daysLate = daysLate.add(FixedPoint.fromUnscaledUint(blocksLate).div(BLOCKS_PER_DAY));\n    }\n\n    FixedPoint.Unsigned memory maxLate = FixedPoint.fromUnscaledUint(maxDaysLate);\n    FixedPoint.Unsigned memory writedownPercent;\n    if (daysLate.isLessThanOrEqual(fpGracePeriod)) {\n      // Within the grace period, we don't have to write down, so assume 0%\n      writedownPercent = FixedPoint.fromUnscaledUint(0);\n    } else {\n      writedownPercent = FixedPoint.min(FixedPoint.fromUnscaledUint(1), (daysLate.sub(fpGracePeriod)).div(maxLate));\n    }\n\n    FixedPoint.Unsigned memory writedownAmount = writedownPercent.mul(cl.balance()).div(FP_SCALING_FACTOR);\n    // This will return a number between 0-100 representing the write down percent with no decimals\n    uint256 unscaledWritedownPercent = writedownPercent.mul(100).div(FP_SCALING_FACTOR).rawValue;\n    return (unscaledWritedownPercent, writedownAmount.rawValue);\n  }\n\n  function calculateAmountOwedForOneDay(CreditLine cl) public view returns (FixedPoint.Unsigned memory) {\n    // Determine theoretical interestOwed for one full day\n    uint256 totalInterestPerYear = cl.balance().mul(cl.interestApr()).div(INTEREST_DECIMALS);\n    FixedPoint.Unsigned memory interestOwed = FixedPoint.fromUnscaledUint(totalInterestPerYear).div(365);\n\n    return interestOwed;\n  }\n\n  function calculateInterestAccrued(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 lateFeeGracePeriodInDays\n  ) public view returns (uint256) {\n    // We use Math.min here to prevent integer overflow (ie. go negative) when calculating\n    // numBlocksElapsed. Typically this shouldn't be possible, because\n    // the interestAccruedAsOfBlock couldn't be *after* the current blockNumber. However, when assessing\n    // we allow this function to be called with a past block number, which raises the possibility\n    // of overflow.\n    // This use of min should not generate incorrect interest calculations, since\n    // this functions purpose is just to normalize balances, and  will be called any time\n    // a balance affecting action takes place (eg. drawdown, repayment, assessment)\n    uint256 interestAccruedAsOfBlock = Math.min(blockNumber, cl.interestAccruedAsOfBlock());\n    uint256 numBlocksElapsed = blockNumber.sub(interestAccruedAsOfBlock);\n    uint256 totalInterestPerYear = cl.balance().mul(cl.interestApr()).div(INTEREST_DECIMALS);\n    uint256 interestOwed = totalInterestPerYear.mul(numBlocksElapsed).div(BLOCKS_PER_YEAR);\n\n    if (lateFeeApplicable(cl, blockNumber, lateFeeGracePeriodInDays)) {\n      uint256 lateFeeInterestPerYear = cl.balance().mul(cl.lateFeeApr()).div(INTEREST_DECIMALS);\n      uint256 additionalLateFeeInterest = lateFeeInterestPerYear.mul(numBlocksElapsed).div(BLOCKS_PER_YEAR);\n      interestOwed = interestOwed.add(additionalLateFeeInterest);\n    }\n\n    return interestOwed;\n  }\n\n  function lateFeeApplicable(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 gracePeriodInDays\n  ) public view returns (bool) {\n    uint256 blocksLate = blockNumber.sub(cl.lastFullPaymentBlock());\n    gracePeriodInDays = Math.min(gracePeriodInDays, cl.paymentPeriodInDays());\n    return cl.lateFeeApr() > 0 && blocksLate > gracePeriodInDays.mul(BLOCKS_PER_DAY);\n  }\n\n  function allocatePayment(\n    uint256 paymentAmount,\n    uint256 balance,\n    uint256 interestOwed,\n    uint256 principalOwed\n  ) public pure returns (PaymentAllocation memory) {\n    uint256 paymentRemaining = paymentAmount;\n    uint256 interestPayment = Math.min(interestOwed, paymentRemaining);\n    paymentRemaining = paymentRemaining.sub(interestPayment);\n\n    uint256 principalPayment = Math.min(principalOwed, paymentRemaining);\n    paymentRemaining = paymentRemaining.sub(principalPayment);\n\n    uint256 balanceRemaining = balance.sub(principalPayment);\n    uint256 additionalBalancePayment = Math.min(paymentRemaining, balanceRemaining);\n\n    return\n      PaymentAllocation({\n        interestPayment: interestPayment,\n        principalPayment: principalPayment,\n        additionalBalancePayment: additionalBalancePayment\n      });\n  }\n}\n"
    },
    "contracts/protocol/CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./GoldfinchConfig.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"../interfaces/IERC20withDec.sol\";\n\n/**\n * @title CreditLine\n * @notice A \"dumb\" state container that represents the agreement between an Underwriter and\n *  the borrower. Includes the terms of the loan, as well as the current accounting state, such as interest owed.\n *  This contract purposefully has essentially no business logic. Really just setters and getters.\n * @author Goldfinch\n */\n\n// solhint-disable-next-line max-states-count\ncontract CreditLine is BaseUpgradeablePausable {\n  // Credit line terms\n  address public borrower;\n  address public underwriter;\n  uint256 public limit;\n  uint256 public interestApr;\n  uint256 public paymentPeriodInDays;\n  uint256 public termInDays;\n  uint256 public lateFeeApr;\n\n  // Accounting variables\n  uint256 public balance;\n  uint256 public interestOwed;\n  uint256 public principalOwed;\n  uint256 public termEndBlock;\n  uint256 public nextDueBlock;\n  uint256 public interestAccruedAsOfBlock;\n  uint256 public writedownAmount;\n  uint256 public lastFullPaymentBlock;\n\n  function initialize(\n    address owner,\n    address _borrower,\n    address _underwriter,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public initializer {\n    require(owner != address(0) && _borrower != address(0) && _underwriter != address(0), \"Zero address passed in\");\n    __BaseUpgradeablePausable__init(owner);\n    borrower = _borrower;\n    underwriter = _underwriter;\n    limit = _limit;\n    interestApr = _interestApr;\n    paymentPeriodInDays = _paymentPeriodInDays;\n    termInDays = _termInDays;\n    lateFeeApr = _lateFeeApr;\n    interestAccruedAsOfBlock = block.number;\n  }\n\n  function setTermEndBlock(uint256 newTermEndBlock) external onlyAdmin {\n    termEndBlock = newTermEndBlock;\n  }\n\n  function setNextDueBlock(uint256 newNextDueBlock) external onlyAdmin {\n    nextDueBlock = newNextDueBlock;\n  }\n\n  function setBalance(uint256 newBalance) external onlyAdmin {\n    balance = newBalance;\n  }\n\n  function setInterestOwed(uint256 newInterestOwed) external onlyAdmin {\n    interestOwed = newInterestOwed;\n  }\n\n  function setPrincipalOwed(uint256 newPrincipalOwed) external onlyAdmin {\n    principalOwed = newPrincipalOwed;\n  }\n\n  function setInterestAccruedAsOfBlock(uint256 newInterestAccruedAsOfBlock) external onlyAdmin {\n    interestAccruedAsOfBlock = newInterestAccruedAsOfBlock;\n  }\n\n  function setWritedownAmount(uint256 newWritedownAmount) external onlyAdmin {\n    writedownAmount = newWritedownAmount;\n  }\n\n  function setLastFullPaymentBlock(uint256 newLastFullPaymentBlock) external onlyAdmin {\n    lastFullPaymentBlock = newLastFullPaymentBlock;\n  }\n\n  function setLateFeeApr(uint256 newLateFeeApr) external onlyAdmin {\n    lateFeeApr = newLateFeeApr;\n  }\n\n  function setLimit(uint256 newAmount) external onlyAdminOrUnderwriter {\n    limit = newAmount;\n  }\n\n  function authorizePool(address configAddress) external onlyAdmin {\n    GoldfinchConfig config = GoldfinchConfig(configAddress);\n    address poolAddress = config.getAddress(uint256(ConfigOptions.Addresses.Pool));\n    address usdcAddress = config.getAddress(uint256(ConfigOptions.Addresses.USDC));\n    // Approve the pool for an infinite amount\n    bool success = IERC20withDec(usdcAddress).approve(poolAddress, uint256(-1));\n    require(success, \"Failed to approve USDC\");\n  }\n\n  modifier onlyAdminOrUnderwriter() {\n    require(isAdmin() || _msgSender() == underwriter, \"Restricted to owner or underwriter\");\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/protocol/GoldfinchConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigOptions.sol\";\n\n/**\n * @title GoldfinchConfig\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. For example, the TransactionLimit, or the PoolAddress. These config vars\n *  are enumerated in the `ConfigOptions` library, and can only be changed by admins of the protocol.\n * @author Goldfinch\n */\n\ncontract GoldfinchConfig is BaseUpgradeablePausable {\n  mapping(uint256 => address) public addresses;\n  mapping(uint256 => uint256) public numbers;\n\n  event AddressUpdated(address owner, string name, address oldValue, address newValue);\n  event NumberUpdated(address owner, string name, uint256 oldValue, uint256 newValue);\n\n  function initialize(address owner) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n  }\n\n  function setAddress(uint256 addressKey, address newAddress) public onlyAdmin {\n    require(addresses[addressKey] == address(0), \"Address has already been initialized\");\n\n    emit AddressUpdated(msg.sender, ConfigOptions.getAddressName(addressKey), addresses[addressKey], newAddress);\n    addresses[addressKey] = newAddress;\n  }\n\n  function setNumber(uint256 number, uint256 newNumber) public onlyAdmin {\n    emit NumberUpdated(msg.sender, ConfigOptions.getNumberName(number), numbers[number], newNumber);\n    numbers[number] = newNumber;\n  }\n\n  function setCreditLineImplementation(address newCreditLine) public onlyAdmin {\n    uint256 addressKey = uint256(ConfigOptions.Addresses.CreditLineImplementation);\n    emit AddressUpdated(msg.sender, ConfigOptions.getAddressName(addressKey), addresses[addressKey], newCreditLine);\n    addresses[addressKey] = newCreditLine;\n  }\n\n  function setTreasuryReserve(address newTreasuryReserve) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.TreasuryReserve);\n    emit AddressUpdated(msg.sender, ConfigOptions.getAddressName(key), addresses[key], newTreasuryReserve);\n    addresses[key] = newTreasuryReserve;\n  }\n\n  /*\n    Using custom getters incase we want to change underlying implementation later,\n    or add checks or validations later on.\n  */\n  function getAddress(uint256 addressKey) public view returns (address) {\n    // Cheap way to see if it's an invalid number\n    ConfigOptions.Addresses(addressKey);\n    return addresses[addressKey];\n  }\n\n  function getNumber(uint256 number) public view returns (uint256) {\n    // Cheap way to see if it's an invalid number\n    ConfigOptions.Numbers(number);\n    return numbers[number];\n  }\n}\n"
    },
    "contracts/protocol/BaseUpgradeablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./PauserPausable.sol\";\n\n/**\n * @title BaseUpgradeablePausable contract\n * @notice This is our Base contract that most other contracts inherit from. It includes many standard\n *  useful abilities like ugpradeability, pausability, access control, and re-entrancy guards.\n * @author Goldfinch\n */\n\ncontract BaseUpgradeablePausable is\n  Initializable,\n  AccessControlUpgradeSafe,\n  PauserPausable,\n  ReentrancyGuardUpgradeSafe\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  using SafeMath for uint256;\n  // Pre-reserving a few slots in the base contract in case we need to add things in the future.\n  // This does not actually take up gas cost or storage cost, but it does reserve the storage slots.\n  // See OpenZeppelin's use of this pattern here:\n  // https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/GSN/Context.sol#L37\n  uint256[50] private __gap1;\n  uint256[50] private __gap2;\n  uint256[50] private __gap3;\n  uint256[50] private __gap4;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __BaseUpgradeablePausable__init(address owner) public initializer {\n    require(owner != address(0), \"Owner cannot be the zero address\");\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/interfaces/IERC20withDec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\n/*\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\n*/\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20withDec is IERC20 {\n  /**\n   * @dev Returns the number of decimals used for the token\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/protocol/ConfigOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @title ConfigOptions\n * @notice A central place for enumerating the configurable options of our GoldfinchConfig contract\n * @author Goldfinch\n */\n\nlibrary ConfigOptions {\n  // NEVER EVER CHANGE THE ORDER OF THESE!\n  // You can rename or append. But NEVER change the order.\n  enum Numbers {\n    TransactionLimit,\n    TotalFundsLimit,\n    MaxUnderwriterLimit,\n    ReserveDenominator,\n    WithdrawFeeDenominator,\n    LatenessGracePeriodInDays,\n    LatenessMaxDays\n  }\n  enum Addresses {\n    Pool,\n    CreditLineImplementation,\n    CreditLineFactory,\n    CreditDesk,\n    Fidu,\n    USDC,\n    TreasuryReserve,\n    ProtocolAdmin\n  }\n\n  function getNumberName(uint256 number) public pure returns (string memory) {\n    Numbers numberName = Numbers(number);\n    if (Numbers.TransactionLimit == numberName) {\n      return \"TransactionLimit\";\n    }\n    if (Numbers.TotalFundsLimit == numberName) {\n      return \"TotalFundsLimit\";\n    }\n    if (Numbers.MaxUnderwriterLimit == numberName) {\n      return \"MaxUnderwriterLimit\";\n    }\n    if (Numbers.ReserveDenominator == numberName) {\n      return \"ReserveDenominator\";\n    }\n    if (Numbers.WithdrawFeeDenominator == numberName) {\n      return \"WithdrawFeeDenominator\";\n    }\n    if (Numbers.LatenessGracePeriodInDays == numberName) {\n      return \"LatenessGracePeriodInDays\";\n    }\n    if (Numbers.LatenessMaxDays == numberName) {\n      return \"LatenessMaxDays\";\n    }\n    revert(\"Unknown value passed to getNumberName\");\n  }\n\n  function getAddressName(uint256 addressKey) public pure returns (string memory) {\n    Addresses addressName = Addresses(addressKey);\n    if (Addresses.Pool == addressName) {\n      return \"Pool\";\n    }\n    if (Addresses.CreditLineImplementation == addressName) {\n      return \"CreditLineImplementation\";\n    }\n    if (Addresses.CreditLineFactory == addressName) {\n      return \"CreditLineFactory\";\n    }\n    if (Addresses.CreditDesk == addressName) {\n      return \"CreditDesk\";\n    }\n    if (Addresses.Fidu == addressName) {\n      return \"Fidu\";\n    }\n    if (Addresses.USDC == addressName) {\n      return \"USDC\";\n    }\n    if (Addresses.TreasuryReserve == addressName) {\n      return \"TreasuryReserve\";\n    }\n    if (Addresses.ProtocolAdmin == addressName) {\n      return \"ProtocolAdmin\";\n    }\n    revert(\"Unknown value passed to getAddressName\");\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, _msgSender()));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n */\nabstract contract AccessControlUpgradeSafe is Initializable, ContextUpgradeSafe {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n\n\n    }\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeSafe is Initializable {\n    bool private _notEntered;\n\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n\n    }\n\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/protocol/PauserPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\";\n\n/**\n * @title PauserPausable\n * @notice Inheriting from OpenZeppelin's Pausable contract, this does small\n *  augmentations to make it work with a PAUSER_ROLE, leveraging the AccessControl contract.\n *  It is meant to be inherited.\n * @author Goldfinch\n */\n\ncontract PauserPausable is AccessControlUpgradeSafe, PausableUpgradeSafe {\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __PauserPausable__init() public initializer {\n    __Pausable_init_unchained();\n  }\n\n  /**\n   * @dev Pauses all functions guarded by Pause\n   *\n   * See {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the PAUSER_ROLE.\n   */\n\n  function pause() public onlyPauserRole {\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses the contract\n   *\n   * See {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the Pauser role\n   */\n  function unpause() public onlyPauserRole {\n    _unpause();\n  }\n\n  modifier onlyPauserRole() {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Must have pauser role to perform this action\");\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract PausableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n\n\n        _paused = false;\n\n    }\n\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/test/TestAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../protocol/Accountant.sol\";\nimport \"../protocol/CreditLine.sol\";\n\ncontract TestAccountant {\n  function calculateInterestAndPrincipalAccrued(\n    address creditLineAddress,\n    uint256 blockNumber,\n    uint256 lateFeeGracePeriod\n  ) public view returns (uint256, uint256) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    return Accountant.calculateInterestAndPrincipalAccrued(cl, blockNumber, lateFeeGracePeriod);\n  }\n\n  function calculateWritedownFor(\n    address creditLineAddress,\n    uint256 blockNumber,\n    uint256 gracePeriod,\n    uint256 maxLatePeriods\n  ) public view returns (uint256, uint256) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    return Accountant.calculateWritedownFor(cl, blockNumber, gracePeriod, maxLatePeriods);\n  }\n\n  function calculateAmountOwedForOneDay(address creditLineAddress) public view returns (FixedPoint.Unsigned memory) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    return Accountant.calculateAmountOwedForOneDay(cl);\n  }\n}\n"
    },
    "contracts/test/FakeV2CreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\";\nimport \"../protocol/BaseUpgradeablePausable.sol\";\nimport \"../protocol/Pool.sol\";\nimport \"../protocol/Accountant.sol\";\nimport \"../protocol/CreditLine.sol\";\nimport \"../protocol/GoldfinchConfig.sol\";\n\ncontract FakeV2CreditDesk is BaseUpgradeablePausable {\n  uint256 public totalWritedowns;\n  uint256 public totalLoansOutstanding;\n  // Approximate number of blocks\n  uint256 public constant BLOCKS_PER_DAY = 5760;\n  GoldfinchConfig public config;\n\n  struct Underwriter {\n    uint256 governanceLimit;\n    address[] creditLines;\n  }\n\n  struct Borrower {\n    address[] creditLines;\n  }\n\n  event PaymentMade(\n    address indexed payer,\n    address indexed creditLine,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount\n  );\n  event PrepaymentMade(address indexed payer, address indexed creditLine, uint256 prepaymentAmount);\n  event DrawdownMade(address indexed borrower, address indexed creditLine, uint256 drawdownAmount);\n  event CreditLineCreated(address indexed borrower, address indexed creditLine);\n  event PoolAddressUpdated(address indexed oldAddress, address indexed newAddress);\n  event GovernanceUpdatedUnderwriterLimit(address indexed underwriter, uint256 newLimit);\n  event LimitChanged(address indexed owner, string limitType, uint256 amount);\n\n  mapping(address => Underwriter) public underwriters;\n  mapping(address => Borrower) private borrowers;\n\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    return;\n  }\n\n  function someBrandNewFunction() public pure returns (uint256) {\n    return 5;\n  }\n\n  function getUnderwriterCreditLines(address underwriterAddress) public view returns (address[] memory) {\n    return underwriters[underwriterAddress].creditLines;\n  }\n}\n"
    },
    "contracts/protocol/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Goldfinch's Pool contract\n * @notice Main entry point for LP's (a.k.a. capital providers)\n *  Handles key logic for depositing and withdrawing funds from the Pool\n * @author Goldfinch\n */\n\ncontract Pool is BaseUpgradeablePausable, IPool {\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  // $1 threshold to handle potential rounding errors, from differing decimals on Fidu and USDC;\n  uint256 constant ASSET_LIABILITY_MATCH_THRESHOLD = 1e6;\n\n  event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n  event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n  event TransferMade(address indexed from, address indexed to, uint256 amount);\n  event InterestCollected(address indexed payer, uint256 poolAmount, uint256 reserveAmount);\n  event PrincipalCollected(address indexed payer, uint256 amount);\n  event ReserveFundsCollected(address indexed user, uint256 amount);\n  event PrincipalWrittendown(address indexed creditline, int256 amount);\n\n  /**\n   * @notice Run only once, on initialization\n   * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n   * @param _config The address of the GoldfinchConfig contract\n   */\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n\n    config = _config;\n    sharePrice = fiduMantissa();\n    IERC20withDec usdc = config.getUSDC();\n    // Sanity check the address\n    usdc.totalSupply();\n\n    // Unlock self for infinite amount\n    bool success = usdc.approve(address(this), uint256(-1));\n    require(success, \"Failed to approve USDC\");\n  }\n\n  /**\n   * @notice Deposits `amount` USDC from msg.sender into the Pool, and returns you the equivalent value of FIDU tokens\n   * @param amount The amount of USDC to deposit\n   */\n  function deposit(uint256 amount) external override whenNotPaused withinTransactionLimit(amount) nonReentrant {\n    require(amount > 0, \"Must deposit more than zero\");\n    // Check if the amount of new shares to be added is within limits\n    uint256 depositShares = getNumShares(amount);\n    uint256 potentialNewTotalShares = totalShares().add(depositShares);\n    require(poolWithinLimit(potentialNewTotalShares), \"Deposit would put the Pool over the total limit.\");\n    emit DepositMade(msg.sender, amount, depositShares);\n    bool success = doUSDCTransfer(msg.sender, address(this), amount);\n    require(success, \"Failed to transfer for deposit\");\n    config.getFidu().mintTo(msg.sender, depositShares);\n\n    assert(assetsMatchLiabilities());\n  }\n\n  /**\n   * @notice Withdraws `amount` USDC from the Pool to msg.sender, and burns the equivalent value of FIDU tokens\n   * @param amount The amount of USDC to withdraw\n   */\n  function withdraw(uint256 amount) external override whenNotPaused withinTransactionLimit(amount) nonReentrant {\n    require(amount > 0, \"Must withdraw more than zero\");\n    // Determine current shares the address has and the shares requested to withdraw\n    uint256 currentShares = config.getFidu().balanceOf(msg.sender);\n    uint256 withdrawShares = getNumShares(amount);\n    // Ensure the address has enough value in the pool\n    require(withdrawShares <= currentShares, \"Amount requested is greater than what this address owns\");\n\n    uint256 reserveAmount = amount.div(config.getWithdrawFeeDenominator());\n    uint256 userAmount = amount.sub(reserveAmount);\n\n    emit WithdrawalMade(msg.sender, userAmount, reserveAmount);\n    // Send the amounts\n    bool success = doUSDCTransfer(address(this), msg.sender, userAmount);\n    require(success, \"Failed to transfer for withdraw\");\n    sendToReserve(address(this), reserveAmount, msg.sender);\n\n    // Burn the shares\n    config.getFidu().burnFrom(msg.sender, withdrawShares);\n\n    assert(assetsMatchLiabilities());\n  }\n\n  /**\n   * @notice Collects `amount` USDC in interest from `from` and sends it to the Pool.\n   *  This also increases the share price accordingly. A portion is sent to the Goldfinch Reserve address\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function collectInterestRepayment(address from, uint256 amount) external override onlyCreditDesk whenNotPaused {\n    uint256 reserveAmount = amount.div(config.getReserveDenominator());\n    uint256 poolAmount = amount.sub(reserveAmount);\n    emit InterestCollected(from, poolAmount, reserveAmount);\n    uint256 increment = usdcToSharePrice(poolAmount);\n    sharePrice = sharePrice.add(increment);\n    sendToReserve(from, reserveAmount, from);\n    bool success = doUSDCTransfer(from, address(this), poolAmount);\n    require(success, \"Failed to transfer interest payment\");\n  }\n\n  /**\n   * @notice Collects `amount` USDC in principal from `from` and sends it to the Pool.\n   *  The key difference from `collectInterestPayment` is that this does not change the sharePrice.\n   *  The reason it does not is because the principal is already baked in. ie. we implicitly assume all principal\n   *  will be returned to the Pool. But if borrowers are late with payments, we have a writedown schedule that adjusts\n   *  the sharePrice downwards to reflect the lowered confidence in that borrower.\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function collectPrincipalRepayment(address from, uint256 amount) external override onlyCreditDesk whenNotPaused {\n    // Purposefully does nothing except receive money. No share price updates for principal.\n    emit PrincipalCollected(from, amount);\n    bool success = doUSDCTransfer(from, address(this), amount);\n    require(success, \"Failed to principal repayment\");\n  }\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta)\n    external\n    override\n    onlyCreditDesk\n    whenNotPaused\n  {\n    if (writedownDelta > 0) {\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta));\n      sharePrice = sharePrice.add(delta);\n    } else {\n      // If delta is negative, convert to positive uint, and sub from sharePrice\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta * -1));\n      sharePrice = sharePrice.sub(delta);\n    }\n    emit PrincipalWrittendown(creditlineAddress, writedownDelta);\n  }\n\n  /**\n   * @notice Moves `amount` USDC from `from`, to `to`.\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param to The address that the USDC should be moved to\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override onlyCreditDesk whenNotPaused returns (bool) {\n    bool result = doUSDCTransfer(from, to, amount);\n    emit TransferMade(from, to, amount);\n    return result;\n  }\n\n  function assets() public view override returns (uint256) {\n    return\n      config.getUSDC().balanceOf(config.poolAddress()).add(config.getCreditDesk().totalLoansOutstanding()).sub(\n        config.getCreditDesk().totalWritedowns()\n      );\n  }\n\n  /* Internal Functions */\n\n  function fiduMantissa() internal view returns (uint256) {\n    return uint256(10)**uint256(config.getFidu().decimals());\n  }\n\n  function usdcMantissa() internal view returns (uint256) {\n    return uint256(10)**uint256(config.getUSDC().decimals());\n  }\n\n  function usdcToFidu(uint256 amount) internal view returns (uint256) {\n    return amount.mul(fiduMantissa()).div(usdcMantissa());\n  }\n\n  function totalShares() internal view returns (uint256) {\n    return config.getFidu().totalSupply();\n  }\n\n  function usdcToSharePrice(uint256 usdcAmount) internal view returns (uint256) {\n    return usdcToFidu(usdcAmount).mul(fiduMantissa()).div(totalShares());\n  }\n\n  function poolWithinLimit(uint256 _totalShares) internal view returns (bool) {\n    return\n      _totalShares.mul(sharePrice).div(fiduMantissa()) <=\n      usdcToFidu(config.getNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit)));\n  }\n\n  function transactionWithinLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n  }\n\n  function getNumShares(uint256 amount) internal view returns (uint256) {\n    return usdcToFidu(amount).mul(fiduMantissa()).div(sharePrice);\n  }\n\n  function assetsMatchLiabilities() internal view returns (bool) {\n    uint256 liabilities = config.getFidu().totalSupply().mul(sharePrice).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = assets();\n    if (_assets >= liabilitiesInDollars) {\n      return _assets.sub(liabilitiesInDollars) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  function fiduToUSDC(uint256 amount) internal view returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function sendToReserve(\n    address from,\n    uint256 amount,\n    address userForEvent\n  ) internal {\n    emit ReserveFundsCollected(userForEvent, amount);\n    bool success = doUSDCTransfer(from, config.reserveAddress(), amount);\n    require(success, \"Reserve transfer was not successful\");\n  }\n\n  function doUSDCTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n    require(transactionWithinLimit(amount), \"Amount is over the per-transaction limit\");\n    require(to != address(0), \"Can't send to zero address\");\n    IERC20withDec usdc = config.getUSDC();\n    uint256 balanceBefore = usdc.balanceOf(to);\n\n    bool success = usdc.transferFrom(from, to, amount);\n\n    // Calculate the amount that was *actually* transferred\n    uint256 balanceAfter = usdc.balanceOf(to);\n    require(balanceAfter >= balanceBefore, \"Token Transfer Overflow Error\");\n    return success;\n  }\n\n  modifier withinTransactionLimit(uint256 amount) {\n    require(transactionWithinLimit(amount), \"Amount is over the per-transaction limit\");\n    _;\n  }\n\n  modifier onlyCreditDesk() {\n    require(msg.sender == config.creditDeskAddress(), \"Only the credit desk is allowed to call this function\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./GoldfinchConfig.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/IFidu.sol\";\nimport \"../interfaces/ICreditDesk.sol\";\nimport \"../interfaces/IERC20withDec.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the GoldfinchConfig contract\n * @author Goldfinch\n */\n\nlibrary ConfigHelper {\n  function getPool(GoldfinchConfig config) internal view returns (IPool) {\n    return IPool(poolAddress(config));\n  }\n\n  function getUSDC(GoldfinchConfig config) internal view returns (IERC20withDec) {\n    return IERC20withDec(config.getAddress(uint256(ConfigOptions.Addresses.USDC)));\n  }\n\n  function getCreditDesk(GoldfinchConfig config) internal view returns (ICreditDesk) {\n    return ICreditDesk(creditDeskAddress(config));\n  }\n\n  function getFidu(GoldfinchConfig config) internal view returns (IFidu) {\n    return IFidu(fiduAddress(config));\n  }\n\n  function poolAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Pool));\n  }\n\n  function creditDeskAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CreditDesk));\n  }\n\n  function fiduAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Fidu));\n  }\n\n  function reserveAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TreasuryReserve));\n  }\n\n  function protocolAdminAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.ProtocolAdmin));\n  }\n\n  function getReserveDenominator(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.ReserveDenominator));\n  }\n\n  function getWithdrawFeeDenominator(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator));\n  }\n\n  function getLatenessGracePeriodInDays(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays));\n  }\n\n  function getLatenessMaxDays(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessMaxDays));\n  }\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nabstract contract IPool {\n  uint256 public sharePrice;\n\n  function deposit(uint256 amount) external virtual;\n\n  function withdraw(uint256 amount) external virtual;\n\n  function collectInterestRepayment(address from, uint256 amount) external virtual;\n\n  function collectPrincipalRepayment(address from, uint256 amount) external virtual;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool);\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta) external virtual;\n\n  function assets() public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20withDec.sol\";\n\ninterface IFidu is IERC20withDec {\n  function mintTo(address to, uint256 amount) external;\n\n  function burnFrom(address to, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/ICreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nabstract contract ICreditDesk {\n  uint256 public totalWritedowns;\n  uint256 public totalLoansOutstanding;\n\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit) external virtual;\n\n  function createCreditLine(\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public virtual returns (address);\n\n  function drawdown(\n    uint256 amount,\n    address creditLineAddress,\n    address addressToSendTo\n  ) external virtual;\n\n  function pay(address creditLineAddress, uint256 amount) external virtual;\n\n  function assessCreditLine(address creditLineAddress) external virtual;\n}\n"
    },
    "contracts/test/TestTheConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/GoldfinchConfig.sol\";\n\ncontract TestTheConfig {\n  address public poolAddress = 0xBAc2781706D0aA32Fb5928c9a5191A13959Dc4AE;\n  address public clImplAddress = 0xc783df8a850f42e7F7e57013759C285caa701eB6;\n  address public clFactoryAddress = 0x0afFE1972479c386A2Ab21a27a7f835361B6C0e9;\n  address public fiduAddress = 0xf3c9B38c155410456b5A98fD8bBf5E35B87F6d96;\n  address public creditDeskAddress = 0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4;\n  address public treasuryReserveAddress = 0xECd9C93B79AE7C1591b1fB5323BD777e86E150d5;\n\n  function testTheEnums(address configAddress) public {\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.TransactionLimit), 1);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit), 2);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.MaxUnderwriterLimit), 3);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.ReserveDenominator), 4);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator), 5);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays), 6);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.LatenessMaxDays), 7);\n\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.Fidu), fiduAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.Pool), poolAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.CreditDesk), creditDeskAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.CreditLineFactory), clFactoryAddress);\n\n    GoldfinchConfig(configAddress).setCreditLineImplementation(clImplAddress);\n    GoldfinchConfig(configAddress).setTreasuryReserve(treasuryReserveAddress);\n  }\n}\n"
    },
    "contracts/test/TestGoldfinchConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/GoldfinchConfig.sol\";\n\ncontract TestGoldfinchConfig is GoldfinchConfig {\n  function setAddressForTest(uint256 addressKey, address newAddress) public {\n    addresses[addressKey] = newAddress;\n  }\n}\n"
    },
    "contracts/protocol/CreditLineFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./GoldfinchConfig.sol\";\n\n/**\n * @title CreditLineFactory\n * @notice Contract that allows us to follow the minimal proxy pattern for creating CreditLines.\n *  This saves us gas, and lets us easily swap out the CreditLine implementaton.\n * @author Goldfinch\n */\n\ncontract CreditLineFactory is BaseUpgradeablePausable {\n  GoldfinchConfig public config;\n\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  function createCreditLine(bytes calldata _data) external returns (address) {\n    address creditLineImplAddress = config.getAddress(uint256(ConfigOptions.Addresses.CreditLineImplementation));\n    address creditLineProxy = deployMinimal(creditLineImplAddress, _data);\n    return creditLineProxy;\n  }\n\n  function deployMinimal(address _logic, bytes memory _data) internal returns (address proxy) {\n    /* solhint-disable */\n    // From https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.8.0/packages/lib/contracts/upgradeability/ProxyFactory.sol#L18-L35\n    // Because of compiler version mismatch\n    bytes20 targetBytes = bytes20(_logic);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      proxy := create(0, clone, 0x37)\n    }\n\n    // Only this line was changed (commented out)\n    // emit ProxyCreated(address(proxy));\n\n    if (_data.length > 0) {\n      (bool success, ) = proxy.call(_data);\n      require(success);\n    }\n    /* solhint-enable */\n  }\n}\n"
    },
    "contracts/test/FakeV2CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/Pool.sol\";\nimport \"../protocol/BaseUpgradeablePausable.sol\";\n\ncontract FakeV2CreditLine is BaseUpgradeablePausable {\n  // Credit line terms\n  address public borrower;\n  address public underwriter;\n  uint256 public limit;\n  uint256 public interestApr;\n  uint256 public paymentPeriodInDays;\n  uint256 public termInDays;\n  uint256 public lateFeeApr;\n\n  // Accounting variables\n  uint256 public balance;\n  uint256 public interestOwed;\n  uint256 public principalOwed;\n  uint256 public termEndBlock;\n  uint256 public nextDueBlock;\n  uint256 public interestAccruedAsOfBlock;\n  uint256 public writedownAmount;\n  uint256 public lastFullPaymentBlock;\n\n  function initialize(\n    address owner,\n    address _borrower,\n    address _underwriter,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n    borrower = _borrower;\n    underwriter = _underwriter;\n    limit = _limit;\n    interestApr = _interestApr;\n    paymentPeriodInDays = _paymentPeriodInDays;\n    termInDays = _termInDays;\n    lateFeeApr = _lateFeeApr;\n    interestAccruedAsOfBlock = block.number;\n  }\n\n  function anotherNewFunction() external pure returns (uint256) {\n    return 42;\n  }\n\n  function authorizePool(address) external view onlyAdmin {\n    // no-op\n    return;\n  }\n}\n"
    },
    "contracts/test/TestPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/Pool.sol\";\n\ncontract TestPool is Pool {\n  function _getNumShares(uint256 amount) public view returns (uint256) {\n    return getNumShares(amount);\n  }\n\n  function _usdcMantissa() public view returns (uint256) {\n    return usdcMantissa();\n  }\n\n  function _fiduMantissa() public view returns (uint256) {\n    return fiduMantissa();\n  }\n\n  function _usdcToFidu(uint256 amount) public view returns (uint256) {\n    return usdcToFidu(amount);\n  }\n\n  function _setSharePrice(uint256 newSharePrice) public returns (uint256) {\n    sharePrice = newSharePrice;\n  }\n}\n"
    },
    "contracts/protocol/Fidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/presets/ERC20PresetMinterPauser.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Fidu\n * @notice Fidu (symbol: FIDU) is Goldfinch's liquidity token, representing shares\n *  in the Pool. When you deposit, we mint a corresponding amount of Fidu, and when you withdraw, we\n *  burn Fidu. The share price of the Pool implicitly represents the \"exchange rate\" between Fidu\n *  and USDC (or whatever currencies the Pool may allow withdraws in during the future)\n * @author Goldfinch\n */\n\ncontract Fidu is ERC20PresetMinterPauserUpgradeSafe {\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  // $1 threshold to handle potential rounding errors, from differing decimals on Fidu and USDC;\n  uint256 public constant ASSET_LIABILITY_MATCH_THRESHOLD = 1e6;\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  /*\n    We are using our own initializer function so we can set the owner by passing it in.\n    I would override the regular \"initializer\" function, but I can't because it's not marked\n    as \"virtual\" in the parent contract\n  */\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(\n    address owner,\n    string calldata name,\n    string calldata symbol,\n    GoldfinchConfig _config\n  ) external initializer {\n    __Context_init_unchained();\n    __AccessControl_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n\n    __ERC20Burnable_init_unchained();\n    __Pausable_init_unchained();\n    __ERC20Pausable_init_unchained();\n\n    config = _config;\n\n    _setupRole(MINTER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(MINTER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mintTo(address to, uint256 amount) public {\n    require(canMint(amount), \"Cannot mint: it would create an asset/liability mismatch\");\n    // This will lock the function down to only the minter\n    super.mint(to, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the MINTER_ROLE\n   */\n  function burnFrom(address from, uint256 amount) public override {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: Must have minter role to burn\");\n    require(canBurn(amount), \"Cannot burn: it would create an asset/liability mismatch\");\n    _burn(from, amount);\n  }\n\n  // Internal functions\n\n  // canMint assumes that the USDC that backs the new shares has already been sent to the Pool\n  function canMint(uint256 newAmount) internal view returns (bool) {\n    uint256 liabilities = totalSupply().add(newAmount).mul(config.getPool().sharePrice()).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = config.getPool().assets();\n    if (_assets >= liabilitiesInDollars) {\n      return _assets.sub(liabilitiesInDollars) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  // canBurn assumes that the USDC that backed these shares has already been moved out the Pool\n  function canBurn(uint256 amountToBurn) internal view returns (bool) {\n    uint256 liabilities = totalSupply().sub(amountToBurn).mul(config.getPool().sharePrice()).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = config.getPool().assets();\n    if (_assets >= liabilitiesInDollars) {\n      return _assets.sub(liabilitiesInDollars) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  function fiduToUSDC(uint256 amount) internal view returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function fiduMantissa() internal view returns (uint256) {\n    return uint256(10)**uint256(decimals());\n  }\n\n  function usdcMantissa() internal view returns (uint256) {\n    return uint256(10)**uint256(config.getUSDC().decimals());\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/presets/ERC20PresetMinterPauser.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../token/ERC20/ERC20.sol\";\nimport \"../token/ERC20/ERC20Burnable.sol\";\nimport \"../token/ERC20/ERC20Pausable.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to aother accounts\n */\ncontract ERC20PresetMinterPauserUpgradeSafe is Initializable, ContextUpgradeSafe, AccessControlUpgradeSafe, ERC20BurnableUpgradeSafe, ERC20PausableUpgradeSafe {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n\n    function initialize(string memory name, string memory symbol) public {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __ERC20Burnable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {\n\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n\n    }\n\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(ERC20UpgradeSafe, ERC20PausableUpgradeSafe) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20UpgradeSafe is Initializable, ContextUpgradeSafe, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n    }\n\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\n\n\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n\n    }\n\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeSafe is Initializable, ContextUpgradeSafe, ERC20UpgradeSafe {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n\n\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeSafe is Initializable, ERC20UpgradeSafe, PausableUpgradeSafe {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n\n\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// contracts/GLDToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20UpgradeSafe {\n  constructor(uint256 initialSupply, uint8 decimals) public {\n    __ERC20_init(\"USDC\", \"USDC\");\n    _setupDecimals(decimals);\n    _mint(msg.sender, initialSupply);\n  }\n}\n"
    },
    "contracts/protocol/CreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./Accountant.sol\";\nimport \"./CreditLine.sol\";\nimport \"./CreditLineFactory.sol\";\n\n/**\n * @title Goldfinch's CreditDesk contract\n * @notice Main entry point for borrowers and underwriters.\n *  Handles key logic for creating CreditLine's, borrowing money, repayment, etc.\n * @author Goldfinch\n */\n\ncontract CreditDesk is BaseUpgradeablePausable, ICreditDesk {\n  // Approximate number of blocks per day\n  uint256 public constant BLOCKS_PER_DAY = 5760;\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  struct Underwriter {\n    uint256 governanceLimit;\n    address[] creditLines;\n  }\n\n  struct Borrower {\n    address[] creditLines;\n  }\n\n  event PaymentApplied(\n    address indexed payer,\n    address indexed creditLine,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount\n  );\n  event PaymentCollected(address indexed payer, address indexed creditLine, uint256 paymentAmount);\n  event DrawdownMade(address indexed borrower, address indexed creditLine, uint256 drawdownAmount);\n  event CreditLineCreated(address indexed borrower, address indexed creditLine);\n  event GovernanceUpdatedUnderwriterLimit(address indexed underwriter, uint256 newLimit);\n\n  mapping(address => Underwriter) public underwriters;\n  mapping(address => Borrower) private borrowers;\n  mapping(address => address) private creditLines;\n\n  /**\n   * @notice Run only once, on initialization\n   * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n   * @param _config The address of the GoldfinchConfig contract\n   */\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  /**\n   * @notice Sets a particular underwriter's limit of how much credit the DAO will allow them to \"create\"\n   * @param underwriterAddress The address of the underwriter for whom the limit shall change\n   * @param limit What the new limit will be set to\n   * Requirements:\n   *\n   * - the caller must have the `OWNER_ROLE`.\n   */\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit)\n    external\n    override\n    onlyAdmin\n    whenNotPaused\n  {\n    require(withinMaxUnderwriterLimit(limit), \"This limit is greater than the max allowed by the protocol\");\n    underwriters[underwriterAddress].governanceLimit = limit;\n    emit GovernanceUpdatedUnderwriterLimit(underwriterAddress, limit);\n  }\n\n  /**\n   * @notice Allows an underwriter to create a new CreditLine for a single borrower\n   * @param _borrower The borrower for whom the CreditLine will be created\n   * @param _limit The maximum amount a borrower can drawdown from this CreditLine\n   * @param _interestApr The interest amount, on an annualized basis (APR, so non-compounding), expressed as an integer.\n   *  We assume 8 digits of precision. For example, to submit 15.34%, you would pass up 15340000,\n   *  and 5.34% would be 5340000\n   * @param _paymentPeriodInDays How many days in each payment period.\n   *  ie. the frequency with which they need to make payments.\n   * @param _termInDays Number of days in the credit term. It is used to set the `termEndBlock` upon first drawdown.\n   *  ie. The credit line should be fully paid off {_termIndays} days after the first drawdown.\n   * @param _lateFeeApr The additional interest you will pay if you are late. For example, if this is 3%, and your\n   *  normal rate is 15%, then you will pay 18% while you are late.\n   *\n   * Requirements:\n   *\n   * - the caller must be an underwriter with enough limit (see `setUnderwriterGovernanceLimit`)\n   */\n  function createCreditLine(\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public override whenNotPaused returns (address) {\n    Underwriter storage underwriter = underwriters[msg.sender];\n    Borrower storage borrower = borrowers[_borrower];\n    require(underwriterCanCreateThisCreditLine(_limit, underwriter), \"The underwriter cannot create this credit line\");\n\n    address clAddress = getCreditLineFactory().createCreditLine(\"\");\n    CreditLine cl = CreditLine(clAddress);\n    cl.initialize(\n      address(this),\n      _borrower,\n      msg.sender,\n      _limit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr\n    );\n\n    underwriter.creditLines.push(clAddress);\n    borrower.creditLines.push(clAddress);\n    creditLines[clAddress] = clAddress;\n    emit CreditLineCreated(_borrower, clAddress);\n\n    cl.grantRole(keccak256(\"OWNER_ROLE\"), config.protocolAdminAddress());\n    cl.authorizePool(address(config));\n    return clAddress;\n  }\n\n  /**\n   * @notice Allows a borrower to drawdown on their creditline.\n   *  `amount` USDC is sent to the borrower, and the credit line accounting is updated.\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to drawdown\n   * @param creditLineAddress The creditline from which they would like to drawdown\n   * @param addressToSendTo The address where they would like the funds sent. If the zero address is passed,\n   *  it will be defaulted to the borrower's address (msg.sender). This is a convenience feature for when they would\n   *  like the funds sent to an exchange or alternate wallet, different from the authentication address\n   *\n   * Requirements:\n   *\n   * - the caller must be the borrower on the creditLine\n   */\n  function drawdown(\n    uint256 amount,\n    address creditLineAddress,\n    address addressToSendTo\n  ) external override whenNotPaused onlyValidCreditLine(creditLineAddress) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    Borrower storage borrower = borrowers[msg.sender];\n    require(borrower.creditLines.length > 0, \"No credit lines exist for this borrower\");\n    require(amount > 0, \"Must drawdown more than zero\");\n    require(cl.borrower() == msg.sender, \"You do not belong to this credit line\");\n    require(withinTransactionLimit(amount), \"Amount is over the per-transaction limit\");\n    require(withinCreditLimit(amount, cl), \"The borrower does not have enough credit limit for this drawdown\");\n\n    if (addressToSendTo == address(0)) {\n      addressToSendTo = msg.sender;\n    }\n\n    if (cl.balance() == 0) {\n      cl.setInterestAccruedAsOfBlock(blockNumber());\n      cl.setLastFullPaymentBlock(blockNumber());\n    }\n    // Must get the interest and principal accrued prior to adding to the balance.\n    (uint256 interestOwed, uint256 principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(cl, blockNumber());\n    uint256 balance = cl.balance().add(amount);\n\n    updateCreditLineAccounting(cl, balance, interestOwed, principalOwed);\n\n    // Must put this after we update the credit line accounting, so we're using the latest\n    // interestOwed\n    require(!isLate(cl), \"Cannot drawdown when payments are past due\");\n    emit DrawdownMade(msg.sender, address(cl), amount);\n\n    bool success = config.getPool().transferFrom(config.poolAddress(), addressToSendTo, amount);\n    require(success, \"Failed to drawdown\");\n  }\n\n  /**\n   * @notice Allows a borrower to repay their loan. Payment is *collected* immediately (by sending it to\n   *  the individual CreditLine), but it is not *applied* unless it is after the nextDueBlock, or until we assess\n   *  the credit line (ie. payment period end).\n   *  Any amounts over the minimum payment will be applied to outstanding principal (reducing the effective\n   *  interest rate). If there is still any left over, it will remain in the USDC Balance\n   *  of the CreditLine, which is held distinct from the Pool amounts, and can not be withdrawn by LP's.\n   * @param creditLineAddress The credit line to be paid back\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to pay\n   */\n  function pay(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    require(amount > 0, \"Must pay more than zero\");\n    CreditLine cl = CreditLine(creditLineAddress);\n\n    collectPayment(cl, amount);\n    assessCreditLine(creditLineAddress);\n  }\n\n  /**\n   * @notice Assesses a particular creditLine. This will apply payments, which will update accounting and\n   *  distribute gains or losses back to the pool accordingly. This function is idempotent, and anyone\n   *  is allowed to call it.\n   * @param creditLineAddress The creditline that should be assessed.\n   */\n  function assessCreditLine(address creditLineAddress)\n    public\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    // Do not assess until a full period has elapsed or past due\n    require(cl.balance() > 0, \"Must have balance to assess credit line\");\n\n    // Don't assess credit lines early!\n    if (blockNumber() < cl.nextDueBlock() && !isLate(cl)) {\n      return;\n    }\n\n    cl.setNextDueBlock(calculateNextDueBlock(cl));\n    uint256 blockToAssess = cl.nextDueBlock();\n\n    // We always want to assess for the most recently *past* nextDueBlock.\n    // So if the recalculation above sets the nextDueBlock into the future,\n    // then ensure we pass in the one just before this.\n    if (cl.nextDueBlock() > blockNumber()) {\n      uint256 blocksPerPeriod = cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n      blockToAssess = cl.nextDueBlock().sub(blocksPerPeriod);\n    }\n    applyPayment(cl, getUSDCBalance(address(cl)), blockToAssess);\n  }\n\n  function migrateCreditLine(\n    CreditLine clToMigrate,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public onlyAdmin {\n    require(clToMigrate.limit() > 0, \"Can't migrate empty credit line\");\n    address newClAddress =\n      createCreditLine(_borrower, _limit, _interestApr, _paymentPeriodInDays, _termInDays, _lateFeeApr);\n\n    CreditLine newCl = CreditLine(newClAddress);\n\n    // Set accounting state vars.\n    newCl.setBalance(clToMigrate.balance());\n    newCl.setInterestOwed(clToMigrate.interestOwed());\n    newCl.setPrincipalOwed(clToMigrate.principalOwed());\n    newCl.setTermEndBlock(clToMigrate.termEndBlock());\n    newCl.setNextDueBlock(clToMigrate.nextDueBlock());\n    newCl.setInterestAccruedAsOfBlock(clToMigrate.interestAccruedAsOfBlock());\n    newCl.setWritedownAmount(clToMigrate.writedownAmount());\n    newCl.setLastFullPaymentBlock(clToMigrate.lastFullPaymentBlock());\n\n    // Close out the original credit line\n    clToMigrate.setLimit(0);\n    clToMigrate.setBalance(0);\n    bool success =\n      config.getPool().transferFrom(\n        address(clToMigrate),\n        address(newCl),\n        config.getUSDC().balanceOf(address(clToMigrate))\n      );\n    require(success, \"Failed to transfer funds\");\n  }\n\n  // Public View Functions (Getters)\n\n  /**\n   * @notice Simple getter for the creditlines of a given underwriter\n   * @param underwriterAddress The underwriter address you would like to see the credit lines of.\n   */\n  function getUnderwriterCreditLines(address underwriterAddress) public view whenNotPaused returns (address[] memory) {\n    return underwriters[underwriterAddress].creditLines;\n  }\n\n  /**\n   * @notice Simple getter for the creditlines of a given borrower\n   * @param borrowerAddress The borrower address you would like to see the credit lines of.\n   */\n  function getBorrowerCreditLines(address borrowerAddress) public view whenNotPaused returns (address[] memory) {\n    return borrowers[borrowerAddress].creditLines;\n  }\n\n  /*\n   * Internal Functions\n   */\n\n  /**\n   * @notice Collects `amount` of payment for a given credit line. This sends money from the payer to the credit line.\n   *  Note that payment is not *applied* when calling this function. Only collected (ie. held) for later application.\n   * @param cl The CreditLine the payment will be collected for.\n   * @param amount The amount, in USDC atomic units, to be collected\n   */\n  function collectPayment(CreditLine cl, uint256 amount) internal {\n    require(withinTransactionLimit(amount), \"Amount is over the per-transaction limit\");\n    require(config.getUSDC().balanceOf(msg.sender) >= amount, \"You have insufficent balance for this payment\");\n\n    emit PaymentCollected(msg.sender, address(cl), amount);\n\n    bool success = config.getPool().transferFrom(msg.sender, address(cl), amount);\n    require(success, \"Failed to collect payment\");\n  }\n\n  /**\n   * @notice Applies `amount` of payment for a given credit line. This moves already collected money into the Pool.\n   *  It also updates all the accounting variables. Note that interest is always paid back first, then principal.\n   *  Any extra after paying the minimum will go towards existing principal (reducing the\n   *  effective interest rate). Any extra after the full loan has been paid off will remain in the\n   *  USDC Balance of the creditLine, where it will be automatically used for the next drawdown.\n   * @param cl The CreditLine the payment will be collected for.\n   * @param amount The amount, in USDC atomic units, to be applied\n   * @param blockNumber The blockNumber on which accrual calculations should be based. This allows us\n   *  to be precise when we assess a Credit Line\n   */\n  function applyPayment(\n    CreditLine cl,\n    uint256 amount,\n    uint256 blockNumber\n  ) internal {\n    (uint256 paymentRemaining, uint256 interestPayment, uint256 principalPayment) =\n      handlePayment(cl, amount, blockNumber);\n\n    updateWritedownAmounts(cl);\n\n    if (interestPayment > 0) {\n      emit PaymentApplied(cl.borrower(), address(cl), interestPayment, principalPayment, paymentRemaining);\n      config.getPool().collectInterestRepayment(address(cl), interestPayment);\n    }\n    if (principalPayment > 0) {\n      emit PaymentApplied(cl.borrower(), address(cl), interestPayment, principalPayment, paymentRemaining);\n      config.getPool().collectPrincipalRepayment(address(cl), principalPayment);\n    }\n  }\n\n  function handlePayment(\n    CreditLine cl,\n    uint256 paymentAmount,\n    uint256 asOfBlock\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 interestOwed, uint256 principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(cl, asOfBlock);\n    Accountant.PaymentAllocation memory pa =\n      Accountant.allocatePayment(paymentAmount, cl.balance(), interestOwed, principalOwed);\n\n    uint256 newBalance = cl.balance().sub(pa.principalPayment);\n    // Apply any additional payment towards the balance\n    newBalance = newBalance.sub(pa.additionalBalancePayment);\n\n    uint256 totalPrincipalPayment = cl.balance().sub(newBalance);\n    uint256 paymentRemaining = paymentAmount.sub(pa.interestPayment).sub(totalPrincipalPayment);\n\n    updateCreditLineAccounting(\n      cl,\n      newBalance,\n      interestOwed.sub(pa.interestPayment),\n      principalOwed.sub(pa.principalPayment)\n    );\n\n    assert(paymentRemaining.add(pa.interestPayment).add(totalPrincipalPayment) == paymentAmount);\n\n    return (paymentRemaining, pa.interestPayment, totalPrincipalPayment);\n  }\n\n  function updateWritedownAmounts(CreditLine cl) internal {\n    (uint256 writedownPercent, uint256 writedownAmount) =\n      Accountant.calculateWritedownFor(\n        cl,\n        blockNumber(),\n        config.getLatenessGracePeriodInDays(),\n        config.getLatenessMaxDays()\n      );\n\n    if (writedownPercent == 0 && cl.writedownAmount() == 0) {\n      return;\n    }\n    int256 writedownDelta = int256(cl.writedownAmount()) - int256(writedownAmount);\n    cl.setWritedownAmount(writedownAmount);\n    if (writedownDelta > 0) {\n      // If writedownDelta is positive, that means we got money back. So subtract from totalWritedowns.\n      totalWritedowns = totalWritedowns.sub(uint256(writedownDelta));\n    } else {\n      totalWritedowns = totalWritedowns.add(uint256(writedownDelta * -1));\n    }\n    config.getPool().distributeLosses(address(cl), writedownDelta);\n  }\n\n  function isLate(CreditLine cl) internal view returns (bool) {\n    uint256 blocksElapsedSinceFullPayment = blockNumber().sub(cl.lastFullPaymentBlock());\n    return blocksElapsedSinceFullPayment > cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n  }\n\n  function getCreditLineFactory() internal view returns (CreditLineFactory) {\n    return CreditLineFactory(config.getAddress(uint256(ConfigOptions.Addresses.CreditLineFactory)));\n  }\n\n  function subtractClFromTotalLoansOutstanding(CreditLine cl) internal {\n    totalLoansOutstanding = totalLoansOutstanding.sub(cl.balance());\n  }\n\n  function addCLToTotalLoansOutstanding(CreditLine cl) internal {\n    totalLoansOutstanding = totalLoansOutstanding.add(cl.balance());\n  }\n\n  function updateAndGetInterestAndPrincipalOwedAsOf(CreditLine cl, uint256 blockNumber)\n    internal\n    returns (uint256, uint256)\n  {\n    (uint256 interestAccrued, uint256 principalAccrued) =\n      Accountant.calculateInterestAndPrincipalAccrued(cl, blockNumber, config.getLatenessGracePeriodInDays());\n    if (interestAccrued > 0) {\n      // If we've accrued any interest, update interestAccruedAsOfBLock to the block that we've\n      // calculated interest for. If we've not accrued any interest, then we keep the old value so the next\n      // time the entire period is taken into account.\n      cl.setInterestAccruedAsOfBlock(blockNumber);\n    }\n    return (cl.interestOwed().add(interestAccrued), cl.principalOwed().add(principalAccrued));\n  }\n\n  function withinCreditLimit(uint256 amount, CreditLine cl) internal view returns (bool) {\n    return cl.balance().add(amount) <= cl.limit();\n  }\n\n  function withinTransactionLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n  }\n\n  function calculateNewTermEndBlock(CreditLine cl) internal view returns (uint256) {\n    // If there's no balance, there's no loan, so there's no term end block\n    if (cl.balance() == 0) {\n      return 0;\n    }\n    // Don't allow any weird bugs where we add to your current end block. This\n    // function should only be used on new credit lines, when we are setting them up\n    if (cl.termEndBlock() != 0) {\n      return cl.termEndBlock();\n    }\n    return blockNumber().add(BLOCKS_PER_DAY.mul(cl.termInDays()));\n  }\n\n  function calculateNextDueBlock(CreditLine cl) internal view returns (uint256) {\n    uint256 blocksPerPeriod = cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n\n    // Your paid off, or have not taken out a loan yet, so no next due block.\n    if (cl.balance() == 0 && cl.nextDueBlock() != 0) {\n      return 0;\n    }\n    // You must have just done your first drawdown\n    if (cl.nextDueBlock() == 0 && cl.balance() > 0) {\n      return blockNumber().add(blocksPerPeriod);\n    }\n    // Active loan that has entered a new period, so return the *next* nextDueBlock.\n    // But never return something after the termEndBlock\n    if (cl.balance() > 0 && blockNumber() >= cl.nextDueBlock()) {\n      uint256 blocksToAdvance = (blockNumber().sub(cl.nextDueBlock()).div(blocksPerPeriod)).add(1).mul(blocksPerPeriod);\n      uint256 nextDueBlock = cl.nextDueBlock().add(blocksToAdvance);\n      return Math.min(nextDueBlock, cl.termEndBlock());\n    }\n    // Active loan in current period, where we've already set the nextDueBlock correctly, so should not change.\n    if (cl.balance() > 0 && blockNumber() < cl.nextDueBlock()) {\n      return cl.nextDueBlock();\n    }\n    revert(\"Error: could not calculate next due block.\");\n  }\n\n  function blockNumber() internal view virtual returns (uint256) {\n    return block.number;\n  }\n\n  function underwriterCanCreateThisCreditLine(uint256 newAmount, Underwriter storage underwriter)\n    internal\n    view\n    returns (bool)\n  {\n    require(underwriter.governanceLimit != 0, \"underwriter does not have governance limit\");\n    uint256 creditCurrentlyExtended = getCreditCurrentlyExtended(underwriter);\n    uint256 totalToBeExtended = creditCurrentlyExtended.add(newAmount);\n    return totalToBeExtended <= underwriter.governanceLimit;\n  }\n\n  function withinMaxUnderwriterLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.MaxUnderwriterLimit));\n  }\n\n  function getCreditCurrentlyExtended(Underwriter storage underwriter) internal view returns (uint256) {\n    uint256 creditExtended;\n    uint256 length = underwriter.creditLines.length;\n    for (uint256 i = 0; i < length; i++) {\n      CreditLine cl = CreditLine(underwriter.creditLines[i]);\n      creditExtended = creditExtended.add(cl.limit());\n    }\n    return creditExtended;\n  }\n\n  function updateCreditLineAccounting(\n    CreditLine cl,\n    uint256 balance,\n    uint256 interestOwed,\n    uint256 principalOwed\n  ) internal nonReentrant {\n    subtractClFromTotalLoansOutstanding(cl);\n\n    cl.setBalance(balance);\n    cl.setInterestOwed(interestOwed);\n    cl.setPrincipalOwed(principalOwed);\n\n    // This resets lastFullPaymentBlock. These conditions assure that they have\n    // indeed paid off all their interest and they have a real nextDueBlock. (ie. creditline isn't pre-drawdown)\n    if (cl.interestOwed() == 0 && cl.nextDueBlock() != 0) {\n      // If interest was fully paid off, then set the last full payment as the previous due block\n      uint256 mostRecentLastDueBlock;\n      if (blockNumber() < cl.nextDueBlock()) {\n        uint256 blocksPerPeriod = cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n        mostRecentLastDueBlock = cl.nextDueBlock().sub(blocksPerPeriod);\n      } else {\n        mostRecentLastDueBlock = cl.nextDueBlock();\n      }\n      cl.setLastFullPaymentBlock(mostRecentLastDueBlock);\n    }\n\n    addCLToTotalLoansOutstanding(cl);\n\n    cl.setTermEndBlock(calculateNewTermEndBlock(cl));\n    cl.setNextDueBlock(calculateNextDueBlock(cl));\n  }\n\n  function getUSDCBalance(address _address) internal returns (uint256) {\n    return config.getUSDC().balanceOf(_address);\n  }\n\n  modifier onlyValidCreditLine(address clAddress) {\n    require(creditLines[clAddress] != address(0), \"Unknown credit line\");\n    _;\n  }\n}\n"
    },
    "contracts/test/TestCreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../protocol/CreditDesk.sol\";\n\ncontract TestCreditDesk is CreditDesk {\n  uint256 _blockNumberForTest;\n\n  function _setTotalLoansOutstanding(uint256 amount) public {\n    totalLoansOutstanding = amount;\n  }\n\n  function _setBlockNumberForTest(uint256 blockNumber) public {\n    _blockNumberForTest = blockNumber;\n  }\n\n  function blockNumber() internal view override returns (uint256) {\n    if (_blockNumberForTest == 0) {\n      return super.blockNumber();\n    } else {\n      return _blockNumberForTest;\n    }\n  }\n\n  function blockNumberForTest() public view returns (uint256) {\n    return blockNumber();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}