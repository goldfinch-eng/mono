{
  "address": "0x6CE93728877396D43874eFdd6345E8c251dFE008",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "principalPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "interestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "interestOwed",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "interestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalOwed",
              "type": "uint256"
            }
          ],
          "internalType": "struct Accountant.AllocatePaymentParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "allocatePayment",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "owedInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "accruedInterestPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalPayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "additionalBalancePayment",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "paymentRemaining",
              "type": "uint256"
            }
          ],
          "internalType": "struct ILoan.PaymentAllocation",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ICreditLine",
          "name": "cl",
          "type": "ICreditLine"
        }
      ],
      "name": "calculateAmountOwedForOneDay",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "rawValue",
              "type": "uint256"
            }
          ],
          "internalType": "struct FixedPoint.Unsigned",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ICreditLine",
          "name": "cl",
          "type": "ICreditLine"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gracePeriodInDays",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxDaysLate",
          "type": "uint256"
        }
      ],
      "name": "calculateWritedownFor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ICreditLine",
          "name": "cl",
          "type": "ICreditLine"
        },
        {
          "internalType": "uint256",
          "name": "principal",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gracePeriodInDays",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxDaysLate",
          "type": "uint256"
        }
      ],
      "name": "calculateWritedownForPrincipal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "paymentAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "interestOwed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "interestAccrued",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "principalOwed",
          "type": "uint256"
        }
      ],
      "name": "splitPayment",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "interestPayment",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "principalPayment",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x0fd1fab9c0ae180ae0c5e51ec7cc0b62d2cb22745798711d1a6cbdee4a1e3f13",
  "receipt": {
    "to": null,
    "from": "0xE1599F49Bc20dD0F0071a5A9f36cb755124A3dA6",
    "contractAddress": "0x6CE93728877396D43874eFdd6345E8c251dFE008",
    "transactionIndex": 110,
    "gasUsed": "897511",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xea725c93406a77247cd39f7979142f2b37d71ef7618fffb05e59137a6ec66c9d",
    "transactionHash": "0x0fd1fab9c0ae180ae0c5e51ec7cc0b62d2cb22745798711d1a6cbdee4a1e3f13",
    "logs": [],
    "blockNumber": 16891951,
    "cumulativeGasUsed": "9928765",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "037931358a02360a4927a740cc7df37a",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principalPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalOwed\",\"type\":\"uint256\"}],\"internalType\":\"struct Accountant.AllocatePaymentParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"allocatePayment\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"owedInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedInterestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"additionalBalancePayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentRemaining\",\"type\":\"uint256\"}],\"internalType\":\"struct ILoan.PaymentAllocation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICreditLine\",\"name\":\"cl\",\"type\":\"ICreditLine\"}],\"name\":\"calculateAmountOwedForOneDay\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rawValue\",\"type\":\"uint256\"}],\"internalType\":\"struct FixedPoint.Unsigned\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICreditLine\",\"name\":\"cl\",\"type\":\"ICreditLine\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriodInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDaysLate\",\"type\":\"uint256\"}],\"name\":\"calculateWritedownFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICreditLine\",\"name\":\"cl\",\"type\":\"ICreditLine\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gracePeriodInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDaysLate\",\"type\":\"uint256\"}],\"name\":\"calculateWritedownForPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestOwed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalOwed\",\"type\":\"uint256\"}],\"name\":\"splitPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestPayment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalPayment\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Goldfinch\",\"kind\":\"dev\",\"methods\":{\"allocatePayment(Accountant.AllocatePaymentParams)\":{\"details\":\"IO - Interest OwedPO - Principal OwedAI - Accrued Interest\",\"params\":{\"params\":\"specifying payment amounts and amounts owed\"},\"returns\":{\"_0\":\"payment allocation\"}}},\"title\":\"The Accountant\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allocatePayment(Accountant.AllocatePaymentParams)\":{\"notice\":\"Allocate a payment.  1. interestOwed must be paid before principalOwed  2. principalOwed must be paid before interestAccrued  3. interestAccrued must be paid before the rest of the balance\"},\"splitPayment(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Given a lump sum, returns the amount of the payment that should be allocated         to paying interest, and the amount that should be allocated to paying principal\"}},\"notice\":\"Library for handling key financial calculations, such as interest and principal accrual.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/core/Accountant.sol\":\"Accountant\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\",\"keccak256\":\"0x50280546205978ca6573541955e15453b4c07a19e6c8ec4f6785a5ae0d7343fb\"},\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0x04d34b3cd5677bea25f8dfceb6dec0eaa071d4d4b789a43f13fe0c415ba4c296\"},\"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\":{\"content\":\"pragma solidity ^0.6.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Multiplies two signed integers, reverts on overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two signed integers, reverts on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two signed integers, reverts on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xfadc24a31d75d6b3f955190cffe13bbe6e24a274c12b2b60e8c4004131487ce8\"},\"contracts/external/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\n// solhint-disable\\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\\\";\\n\\n/**\\n * @title Library for fixed point arithmetic on uints\\n */\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n  // For unsigned values:\\n  //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\n  uint256 private constant FP_SCALING_FACTOR = 10 ** 18;\\n\\n  // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  /**\\n   * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\\n   * @param a uint to convert into a FixedPoint.\\n   * @return the converted FixedPoint.\\n   */\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice The minimum of `a` and `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the minimum of `a` and `b`.\\n   */\\n  function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice The maximum of `a` and `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the maximum of `a` and `b`.\\n   */\\n  function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice Adds two `Unsigned`s, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts two `Unsigned`s, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Unsigned`s, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n    // stored internally as a uint256 ~10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n    // would round to 3, but this computation produces the result 2.\\n    // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n    // 10^41 is stored internally as a uint256 10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b a uint256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  /**\\n   * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a uint256 numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b a uint256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\n    // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\n    // This creates the possibility of overflow if b is very large.\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  /**\\n   * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n   * @dev This will \\\"floor\\\" the result.\\n   * @param a a FixedPoint numerator.\\n   * @param b a uint256 denominator.\\n   * @return output is `a` to the power of `b`.\\n   */\\n  function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  // ------------------------------------------------- SIGNED -------------------------------------------------------------\\n  // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n  // For signed values:\\n  //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\n  int256 private constant SFP_SCALING_FACTOR = 10 ** 18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, \\\"Negative value provided\\\");\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\n    require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  /**\\n   * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\\n   * @param a int to convert into a FixedPoint.Signed.\\n   * @return the converted FixedPoint.Signed.\\n   */\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a int256.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice The minimum of `a` and `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the minimum of `a` and `b`.\\n   */\\n  function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice The maximum of `a` and `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the maximum of `a` and `b`.\\n   */\\n  function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice Adds two `Signed`s, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts two `Signed`s, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Signed`s, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n    // stored internally as an int256 ~10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n    // would round to 3, but this computation produces the result 2.\\n    // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n    // Manual mod because SignedSafeMath doesn't support it.\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n    // 10^41 is stored internally as an int256 10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b an int256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  /**\\n   * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a an int256 numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n    // Manual mod because SignedSafeMath doesn't support it.\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b an int256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\n    // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\n    // This creates the possibility of overflow if b is very large.\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  /**\\n   * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n   * @dev This will \\\"floor\\\" the result.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a uint256 (negative exponents are not allowed).\\n   * @return output is `a` to the power of `b`.\\n   */\\n  function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x10e2bb4ab4d2d103da60f6b340142ebe9a2112e037b57da2ab1df1a89f4656ea\",\"license\":\"AGPL-3.0-only\"},\"contracts/interfaces/ICreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ILoan} from \\\"./ILoan.sol\\\";\\n\\nimport {ICreditLine} from \\\"./ICreditLine.sol\\\";\\nimport {ISchedule} from \\\"./ISchedule.sol\\\";\\n\\ninterface ICreditLine {\\n  function balance() external view returns (uint256);\\n\\n  function interestOwed() external view returns (uint256);\\n\\n  function principalOwed() external view returns (uint256);\\n\\n  function termEndTime() external view returns (uint256);\\n\\n  function nextDueTime() external view returns (uint256);\\n\\n  function interestAccruedAsOf() external view returns (uint256);\\n\\n  function lastFullPaymentTime() external view returns (uint256);\\n\\n  function borrower() external view returns (address);\\n\\n  function currentLimit() external view returns (uint256);\\n\\n  function limit() external view returns (uint256);\\n\\n  function maxLimit() external view returns (uint256);\\n\\n  function interestApr() external view returns (uint256);\\n\\n  function lateFeeApr() external view returns (uint256);\\n\\n  function isLate() external view returns (bool);\\n\\n  function withinPrincipalGracePeriod() external view returns (bool);\\n\\n  /// @notice Cumulative interest accrued up to now\\n  function totalInterestAccrued() external view returns (uint256);\\n\\n  /// @notice Cumulative interest accrued up to `timestamp`\\n  function totalInterestAccruedAt(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Cumulative interest paid back up to now\\n  function totalInterestPaid() external view returns (uint256);\\n\\n  /// @notice Cumulative interest owed up to now\\n  function totalInterestOwed() external view returns (uint256);\\n\\n  /// @notice Cumulative interest owed up to `timestamp`\\n  function totalInterestOwedAt(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Interest that would be owed at `timestamp`\\n  function interestOwedAt(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Interest accrued in the current payment period up to now. Converted to\\n  ///   owed interest once we cross into the next payment period. Is 0 if the\\n  ///   current time is after loan maturity (all interest accrued immediately becomes\\n  ///   interest owed).\\n  function interestAccrued() external view returns (uint256);\\n\\n  /// @notice Interest accrued in the current payment period for `timestamp`. Coverted to\\n  ///   owed interest once we cross into the payment period after `timestamp`. Is 0\\n  ///   if `timestamp` is after loan maturity (all interest accrued immediately becomes\\n  ///   interest owed).\\n  function interestAccruedAt(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Principal owed up to `timestamp`\\n  function principalOwedAt(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Returns the total amount of principal thats been paid\\n  function totalPrincipalPaid() external view returns (uint256);\\n\\n  /// @notice Cumulative principal owed at timestamp\\n  function totalPrincipalOwedAt(uint256 timestamp) external view returns (uint256);\\n\\n  /// @notice Cumulative principal owed at current timestamp\\n  function totalPrincipalOwed() external view returns (uint256);\\n\\n  function setLimit(uint256 newAmount) external;\\n\\n  function setMaxLimit(uint256 newAmount) external;\\n\\n  /// @notice Time of first drawdown\\n  function termStartTime() external view returns (uint256);\\n\\n  /// @notice Process a bulk payment, allocating the payment amount based on the payment waterfall\\n  function pay(uint paymentAmount) external returns (ILoan.PaymentAllocation memory);\\n\\n  /**\\n   * Process a payment according to the waterfall described in `Accountant.allocatePayment`\\n   * @param principalPayment principal payment amount\\n   * @param interestPayment interest payment amount\\n   * @return payment allocation\\n   */\\n  function pay(\\n    uint256 principalPayment,\\n    uint256 interestPayment\\n  ) external returns (ILoan.PaymentAllocation memory);\\n\\n  /// @notice Drawdown on the line\\n  /// @param amount amount to drawdown. Cannot exceed the line's limit\\n  function drawdown(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0xb686be076b47f3d64138d7e2ba5084f8bb81f13cd61385c88307f07defa96d65\",\"license\":\"MIT\"},\"contracts/interfaces/ILoan.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {ISchedule} from \\\"./ISchedule.sol\\\";\\nimport {ICreditLine} from \\\"./ICreditLine.sol\\\";\\n\\nenum LoanType {\\n  TranchedPool,\\n  CallableLoan\\n}\\n\\ninterface ILoan {\\n  /// @notice getLoanType was added to support the new callable loan type.\\n  ///         It is not supported in older versions of ILoan (e.g. legacy TranchedPools)\\n  function getLoanType() external view returns (LoanType);\\n\\n  /// @notice Pool's credit line, responsible for managing the loan's accounting variables\\n  function creditLine() external view returns (ICreditLine);\\n\\n  /// @notice Time when the pool was initialized. Zero if uninitialized\\n  function createdAt() external view returns (uint256);\\n\\n  /// @notice Pay down interest + principal. Excess payments are refunded to the caller\\n  /// @param amount USDC amount to pay\\n  /// @return PaymentAllocation info on how the payment was allocated\\n  /// @dev {this} must be approved by msg.sender to transfer {amount} of USDC\\n  function pay(uint256 amount) external returns (PaymentAllocation memory);\\n\\n  /// @notice Compute interest and principal owed on the current balance at a future timestamp\\n  /// @param timestamp time to calculate up to\\n  /// @return interestOwed amount of obligated interest owed at `timestamp`\\n  /// @return interestAccrued amount of accrued interest (not yet owed) that can be paid at `timestamp`\\n  /// @return principalOwed amount of principal owed at `timestamp`\\n  function getAmountsOwed(\\n    uint256 timestamp\\n  ) external view returns (uint256 interestOwed, uint256 interestAccrued, uint256 principalOwed);\\n\\n  function getAllowedUIDTypes() external view returns (uint256[] memory);\\n\\n  /// @notice Drawdown the loan. The credit line's balance should increase by the amount drawn down.\\n  ///   Junior capital must be locked before this function can be called. If senior capital isn't locked\\n  ///   then this function will lock it for you (convenience to avoid calling lockPool() separately).\\n  ///   This function should revert if the amount requested exceeds the the current slice's currentLimit\\n  ///   This function should revert if the caller is not the borrower.\\n  /// @param amount USDC to drawdown. This amount is transferred to the caller\\n  function drawdown(uint256 amount) external;\\n\\n  /// @notice Update `fundableAt` to a new timestamp. Only the borrower can call this.\\n  function setFundableAt(uint256 newFundableAt) external;\\n\\n  /// @notice Supply capital to this pool. Caller can't deposit to the junior tranche if the junior pool is locked.\\n  ///   Caller can't deposit to a senior tranche if the pool is locked. Caller can't deposit if they are missing the\\n  ///   required UID NFT.\\n  /// @param tranche id of tranche to supply capital to. Id must correspond to a tranche in the current slice.\\n  /// @param amount amount of capital to supply\\n  /// @return tokenId NFT representing your position in this pool\\n  function deposit(uint256 tranche, uint256 amount) external returns (uint256 tokenId);\\n\\n  function depositWithPermit(\\n    uint256 tranche,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint256 tokenId);\\n\\n  /// @notice Query the max amount available to withdraw for tokenId's position\\n  /// @param tokenId position to query max amount withdrawable for\\n  /// @return interestRedeemable total interest withdrawable on the position\\n  /// @return principalRedeemable total principal redeemable on the position\\n  function availableToWithdraw(\\n    uint256 tokenId\\n  ) external view returns (uint256 interestRedeemable, uint256 principalRedeemable);\\n\\n  /// @notice Withdraw an already deposited amount if the funds are available. Caller must be the owner or\\n  ///   approved by the owner on tokenId. Amount withdrawn is sent to the caller.\\n  /// @param tokenId the NFT representing the position\\n  /// @param amount amount to withdraw (must be <= interest+principal available to withdraw)\\n  /// @return interestWithdrawn interest withdrawn\\n  /// @return principalWithdrawn principal withdrawn\\n  function withdraw(\\n    uint256 tokenId,\\n    uint256 amount\\n  ) external returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  /// @notice Similar to withdraw but withdraw the max interest and principal available for `tokenId`\\n  function withdrawMax(\\n    uint256 tokenId\\n  ) external returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  /// @notice Withdraw from multiple tokens\\n  /// @param tokenIds NFT positions to withdraw. Caller must be an owner or approved on all tokens in the array\\n  /// @param amounts amounts to withdraw from positions such that amounts[i] is withdrawn from position tokenIds[i]\\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n  /// @notice Result of applying a payment to a v2 pool\\n  /// @param owedInterestPayment payment portion of interest owed\\n  /// @param accruedInterestPayment payment portion of accrued (but not yet owed) interest\\n  /// @param principalPayment payment portion on principal owed\\n  /// @param additionalBalancePayment payment portion on any balance that is currently owed\\n  /// @param paymentRemaining payment amount leftover\\n  struct PaymentAllocation {\\n    uint256 owedInterestPayment;\\n    uint256 accruedInterestPayment;\\n    uint256 principalPayment;\\n    uint256 additionalBalancePayment;\\n    uint256 paymentRemaining;\\n  }\\n  /// @notice Event emitted on payment\\n  /// @param payer address that made the payment\\n  /// @param pool pool to which the payment was made\\n  /// @param interest amount of payment allocated to interest (obligated + additional)\\n  /// @param principal amount of payment allocated to principal owed and remaining balance\\n  /// @param remaining any excess payment amount that wasn't allocated to a debt owed\\n  /// @param reserve of payment that went to the protocol reserve\\n  event PaymentApplied(\\n    address indexed payer,\\n    address indexed pool,\\n    uint256 interest,\\n    uint256 principal,\\n    uint256 remaining,\\n    uint256 reserve\\n  );\\n  event DepositMade(\\n    address indexed owner,\\n    uint256 indexed tranche,\\n    uint256 indexed tokenId,\\n    uint256 amount\\n  );\\n\\n  /// @notice While owner is the label of the first argument, it is actually the sender of the transaction.\\n  event WithdrawalMade(\\n    address indexed owner,\\n    uint256 indexed tranche,\\n    uint256 indexed tokenId,\\n    uint256 interestWithdrawn,\\n    uint256 principalWithdrawn\\n  );\\n  event ReserveFundsCollected(address indexed from, uint256 amount);\\n  event DrawdownMade(address indexed borrower, uint256 amount);\\n  event DrawdownsPaused(address indexed pool);\\n  event DrawdownsUnpaused(address indexed pool);\\n  event EmergencyShutdown(address indexed pool);\\n}\\n\",\"keccak256\":\"0xf4f3daafcf9d018c9457f1216fddd741ab0cdeebf35e02d4ffa28ec509b0f63b\",\"license\":\"MIT\"},\"contracts/interfaces/ISchedule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface ISchedule {\\n  function periodsPerPrincipalPeriod() external view returns (uint256);\\n\\n  function periodsInTerm() external view returns (uint256);\\n\\n  function periodsPerInterestPeriod() external view returns (uint256);\\n\\n  function gracePrincipalPeriods() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the period that timestamp resides in\\n   */\\n  function periodAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the principal period that timestamp resides in\\n   */\\n  function principalPeriodAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the interest period that timestamp resides in\\n   */\\n  function interestPeriodAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns true if the given timestamp resides in a principal grace period\\n   */\\n  function withinPrincipalGracePeriodAt(\\n    uint256 startTime,\\n    uint256 timestamp\\n  ) external view returns (bool);\\n\\n  /**\\n   * Returns the next timestamp where either principal or interest will come due following `timestamp`\\n   */\\n  function nextDueTimeAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the previous timestamp where either principal or timestamp came due\\n   */\\n  function previousDueTimeAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the previous timestamp where new interest came due\\n   */\\n  function previousInterestDueTimeAt(\\n    uint256 startTime,\\n    uint256 timestamp\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the previous timestamp where new principal came due\\n   */\\n  function previousPrincipalDueTimeAt(\\n    uint256 startTime,\\n    uint256 timestamp\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the total number of principal periods\\n   */\\n  function totalPrincipalPeriods() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the total number of interest periods\\n   */\\n  function totalInterestPeriods() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the timestamp that the term will end\\n   */\\n  function termEndTime(uint256 startTime) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the timestamp that the term began\\n   */\\n  function termStartTime(uint256 startTime) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the next time principal will come due, or the termEndTime if there are no more due times\\n   */\\n  function nextPrincipalDueTimeAt(\\n    uint256 startTime,\\n    uint256 timestamp\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the next time interest will come due, or the termEndTime if there are no more due times\\n   */\\n  function nextInterestDueTimeAt(\\n    uint256 startTime,\\n    uint256 timestamp\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the end time of the given period.\\n   */\\n  function periodEndTime(uint256 startTime, uint256 period) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd12234c42aeb8a91fb435196e0aa5f45568b9f16b44ce29ea70118393ae952b1\",\"license\":\"MIT\"},\"contracts/interfaces/ITranchedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\nimport {ISchedule} from \\\"./ISchedule.sol\\\";\\nimport {ILoan} from \\\"./ILoan.sol\\\";\\nimport {ICreditLine} from \\\"./ICreditLine.sol\\\";\\n\\ninterface ITranchedPool is ILoan {\\n  struct TrancheInfo {\\n    uint256 id;\\n    uint256 principalDeposited;\\n    uint256 principalSharePrice;\\n    uint256 interestSharePrice;\\n    uint256 lockedUntil;\\n  }\\n  struct PoolSlice {\\n    TrancheInfo seniorTranche;\\n    TrancheInfo juniorTranche;\\n    uint256 totalInterestAccrued;\\n    uint256 principalDeployed;\\n  }\\n  enum Tranches {\\n    Reserved,\\n    Senior,\\n    Junior\\n  }\\n\\n  /// @notice Initialize the pool. Can only be called once, and should be called in the same transaction as\\n  ///   contract creation to avoid initialization front-running\\n  /// @param _config address of GoldfinchConfig\\n  /// @param _borrower address of borrower, a non-transferrable role for performing privileged actions like\\n  ///   drawdown\\n  /// @param _juniorFeePercent percent (whole number) of senior interest that gets re-allocated to the junior tranche.\\n  ///   valid range is [0, 100]\\n  /// @param _limit the max USDC amount that can be drawn down across all pool slices\\n  /// @param _interestApr interest rate for the loan\\n  /// @param _lateFeeApr late fee interest rate for the loan, which kicks in `LatenessGracePeriodInDays` days after a\\n  ///   payment becomes late\\n  /// @param _fundableAt earliest time at which the first slice can be funded\\n  function initialize(\\n    address _config,\\n    address _borrower,\\n    uint256 _juniorFeePercent,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    ISchedule _schedule,\\n    uint256 _lateFeeApr,\\n    uint256 _fundableAt,\\n    uint256[] calldata _allowedUIDTypes\\n  ) external;\\n\\n  /// @notice Pay down the credit line, separating the principal and interest payments. You must pay back all interest\\n  ///   before paying back principal. Excess payments are refunded to the caller\\n  /// @param principalPayment USDC amount to pay down principal\\n  /// @param interestPayment USDC amount to pay down interest\\n  /// @return PaymentAllocation info on how the payment was allocated\\n  /// @dev {this} must be approved by msg.sender to transfer {principalPayment} + {interestPayment} of USDC\\n  function pay(\\n    uint256 principalPayment,\\n    uint256 interestPayment\\n  ) external returns (PaymentAllocation memory);\\n\\n  /// @notice TrancheInfo for tranche with id `trancheId`. The senior tranche of slice i has id 2*(i-1)+1. The\\n  ///   junior tranche of slice i has id 2*i. Slice indices start at 1.\\n  /// @param trancheId id of tranche. Valid ids are in the range [1, 2*numSlices]\\n  function getTranche(uint256 trancheId) external view returns (ITranchedPool.TrancheInfo memory);\\n\\n  /// @notice Get a slice by index\\n  /// @param index of slice. Valid indices are on the interval [0, numSlices - 1]\\n  function poolSlices(uint256 index) external view returns (ITranchedPool.PoolSlice memory);\\n\\n  /// @notice Lock the junior capital in the junior tranche of the current slice. The capital is locked for\\n  ///   `DrawdownPeriodInSeconds` seconds and gives the senior pool time to decide how much to invest (ensure\\n  ///   leverage ratio cannot change for the period). During this period the borrower has the option to lock\\n  ///   the senior capital by calling `lockPool()`. Backers may withdraw their junior capital if the the senior\\n  ///   tranche has not been locked and the drawdown period has ended. Only the borrower can call this function.\\n  function lockJuniorCapital() external;\\n\\n  /// @notice Lock the senior capital in the senior tranche of the current slice and reset the lock period of\\n  ///   the junior capital to match the senior capital lock period. During this period the borrower has the\\n  ///   option to draw down the pool. Beyond the drawdown period any unused capital is available to withdraw by\\n  ///   all depositors.\\n  function lockPool() external;\\n\\n  /// @notice Initialize the next slice for the pool. Enables backers and the senior pool to provide additional\\n  ///   capital to the borrower.\\n  /// @param _fundableAt time at which the new slice (now the current slice) becomes fundable\\n  function initializeNextSlice(uint256 _fundableAt) external;\\n\\n  /// @notice Query the total capital supplied to the pool's junior tranches\\n  function totalJuniorDeposits() external view returns (uint256);\\n\\n  function assess() external;\\n\\n  /// @notice Get the current number of slices for this pool\\n  /// @return numSlices total current slice count\\n  function numSlices() external view returns (uint256);\\n\\n  // Note: This has to exactly match the event in the TranchingLogic library for events to be emitted\\n  // correctly\\n  event SharePriceUpdated(\\n    address indexed pool,\\n    uint256 indexed tranche,\\n    uint256 principalSharePrice,\\n    int256 principalDelta,\\n    uint256 interestSharePrice,\\n    int256 interestDelta\\n  );\\n  event CreditLineMigrated(ICreditLine indexed oldCreditLine, ICreditLine indexed newCreditLine);\\n  event TrancheLocked(address indexed pool, uint256 trancheId, uint256 lockedUntil);\\n  event SliceCreated(address indexed pool, uint256 sliceId);\\n}\\n\",\"keccak256\":\"0x2d9da6ab58b4f6c543a915f18a92d31840099705cae3a6248c3f02e9295c0aea\",\"license\":\"MIT\"},\"contracts/library/SafeMath.sol\":{\"content\":\"pragma solidity >=0.6.12;\\n\\n// NOTE: this file exists only to remove the extremely long error messages in safe math.\\n\\nimport {SafeMath as OzSafeMath} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a);\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return OzSafeMath.sub(a, b, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    return OzSafeMath.sub(a, b, errorMessage);\\n  }\\n\\n  /// @notice Do a - b. If that would result in overflow then return 0\\n  function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return b > a ? 0 : a - b;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b);\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return OzSafeMath.div(a, b, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    return OzSafeMath.div(a, b, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return OzSafeMath.mod(a, b, \\\"\\\");\\n  }\\n\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    return OzSafeMath.mod(a, b, errorMessage);\\n  }\\n}\\n\",\"keccak256\":\"0x492f16ba6645f576d55d73cb648a4f7268bf84dae52768826d7e37693ffa7148\"},\"contracts/protocol/core/Accountant.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {ICreditLine} from \\\"../../interfaces/ICreditLine.sol\\\";\\nimport {ILoan} from \\\"../../interfaces/ILoan.sol\\\";\\n\\nimport {ITranchedPool} from \\\"../../interfaces/ITranchedPool.sol\\\";\\nimport {FixedPoint} from \\\"../../external/FixedPoint.sol\\\";\\nimport {SafeMath} from \\\"../../library/SafeMath.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\\\";\\n\\n/**\\n * @title The Accountant\\n * @notice Library for handling key financial calculations, such as interest and principal accrual.\\n * @author Goldfinch\\n */\\n\\nlibrary Accountant {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Signed;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FixedPoint for int256;\\n  using FixedPoint for uint256;\\n\\n  // Scaling factor used by FixedPoint.sol. We need this to convert the fixed point raw values back to unscaled\\n  uint256 private constant FP_SCALING_FACTOR = 10 ** 18;\\n  uint256 private constant INTEREST_DECIMALS = 1e18;\\n  uint256 private constant SECONDS_PER_DAY = 60 * 60 * 24;\\n  uint256 private constant SECONDS_PER_YEAR = (SECONDS_PER_DAY * 365);\\n\\n  /// @notice Input params for allocating a payment\\n  struct AllocatePaymentParams {\\n    uint256 principalPayment;\\n    uint256 interestPayment;\\n    uint256 balance;\\n    uint256 interestOwed;\\n    uint256 interestAccrued;\\n    uint256 principalOwed;\\n  }\\n\\n  function calculateWritedownFor(\\n    ICreditLine cl,\\n    uint256 timestamp,\\n    uint256 gracePeriodInDays,\\n    uint256 maxDaysLate\\n  ) public view returns (uint256, uint256) {\\n    return\\n      calculateWritedownForPrincipal(cl, cl.balance(), timestamp, gracePeriodInDays, maxDaysLate);\\n  }\\n\\n  function calculateWritedownForPrincipal(\\n    ICreditLine cl,\\n    uint256 principal,\\n    uint256 timestamp,\\n    uint256 gracePeriodInDays,\\n    uint256 maxDaysLate\\n  ) public view returns (uint256, uint256) {\\n    FixedPoint.Unsigned memory amountOwedPerDay = calculateAmountOwedForOneDay(cl);\\n    if (amountOwedPerDay.isEqual(0)) {\\n      return (0, 0);\\n    }\\n    FixedPoint.Unsigned memory fpGracePeriod = FixedPoint.fromUnscaledUint(gracePeriodInDays);\\n    FixedPoint.Unsigned memory daysLate;\\n\\n    // Excel math: =min(1,max(0,periods_late_in_days-graceperiod_in_days)/MAX_ALLOWED_DAYS_LATE) grace_period = 30,\\n    // Before the term end date, we use the interestOwed to calculate the periods late. However, after the loan term\\n    // has ended, since the interest is a much smaller fraction of the principal, we cannot reliably use interest to\\n    // calculate the periods later.\\n    uint256 totalOwed = cl.interestOwed().add(cl.principalOwed());\\n    daysLate = FixedPoint.fromUnscaledUint(totalOwed).div(amountOwedPerDay);\\n    if (timestamp > cl.termEndTime()) {\\n      uint256 secondsLate = timestamp.sub(cl.termEndTime());\\n      daysLate = daysLate.add(FixedPoint.fromUnscaledUint(secondsLate).div(SECONDS_PER_DAY));\\n    }\\n\\n    FixedPoint.Unsigned memory maxLate = FixedPoint.fromUnscaledUint(maxDaysLate);\\n    FixedPoint.Unsigned memory writedownPercent;\\n    if (daysLate.isLessThanOrEqual(fpGracePeriod)) {\\n      // Within the grace period, we don't have to write down, so assume 0%\\n      writedownPercent = FixedPoint.fromUnscaledUint(0);\\n    } else {\\n      writedownPercent = FixedPoint.min(\\n        FixedPoint.fromUnscaledUint(1),\\n        (daysLate.sub(fpGracePeriod)).div(maxLate)\\n      );\\n    }\\n\\n    FixedPoint.Unsigned memory writedownAmount = writedownPercent.mul(principal).div(\\n      FP_SCALING_FACTOR\\n    );\\n    // This will return a number between 0-100 representing the write down percent with no decimals\\n    uint256 unscaledWritedownPercent = writedownPercent.mul(100).div(FP_SCALING_FACTOR).rawValue;\\n    return (unscaledWritedownPercent, writedownAmount.rawValue);\\n  }\\n\\n  function calculateAmountOwedForOneDay(\\n    ICreditLine cl\\n  ) public view returns (FixedPoint.Unsigned memory) {\\n    // Determine theoretical interestOwed for one full day\\n    uint256 totalInterestPerYear = cl.balance().mul(cl.interestApr()).div(INTEREST_DECIMALS);\\n    FixedPoint.Unsigned memory interestOwedForOneDay = FixedPoint\\n      .fromUnscaledUint(totalInterestPerYear)\\n      .div(365);\\n    return interestOwedForOneDay.add(cl.principalOwed());\\n  }\\n\\n  /**\\n   * @notice Given a lump sum, returns the amount of the payment that should be allocated\\n   *         to paying interest, and the amount that should be allocated to paying principal\\n   */\\n  function splitPayment(\\n    uint256 paymentAmount,\\n    uint256 balance,\\n    uint256 interestOwed,\\n    uint256 interestAccrued,\\n    uint256 principalOwed\\n  ) external pure returns (uint interestPayment, uint principalPayment) {\\n    uint owedInterestPayment = Math.min(interestOwed, paymentAmount);\\n    paymentAmount = paymentAmount.sub(owedInterestPayment);\\n\\n    uint owedPrincipalPayment = Math.min(principalOwed, paymentAmount);\\n    paymentAmount = paymentAmount.sub(owedPrincipalPayment);\\n\\n    uint accruedInterestPayment = Math.min(interestAccrued, paymentAmount);\\n    paymentAmount = paymentAmount.sub(accruedInterestPayment);\\n\\n    uint balanceRemaining = balance.sub(owedPrincipalPayment);\\n    uint additionalBalancePayment = Math.min(balanceRemaining, paymentAmount);\\n\\n    return (\\n      owedInterestPayment.add(accruedInterestPayment),\\n      owedPrincipalPayment.add(additionalBalancePayment)\\n    );\\n  }\\n\\n  /**\\n   * @notice Allocate a payment.\\n   *  1. interestOwed must be paid before principalOwed\\n   *  2. principalOwed must be paid before interestAccrued\\n   *  3. interestAccrued must be paid before the rest of the balance\\n   * @param params specifying payment amounts and amounts owed\\n   * @return payment allocation\\n   *\\n   * @dev IO - Interest Owed\\n   * @dev PO - Principal Owed\\n   * @dev AI - Accrued Interest\\n   */\\n  function allocatePayment(\\n    AllocatePaymentParams memory params\\n  ) public pure returns (ITranchedPool.PaymentAllocation memory) {\\n    require(params.principalPayment > 0 || params.interestPayment > 0, \\\"ZZ\\\");\\n\\n    uint256 remainingPrincipalPayment = params.principalPayment;\\n    uint256 remainingInterestPayment = params.interestPayment;\\n\\n    // The payment waterfall works like this:\\n\\n    // 1. Any interest that is _currently_ owed must be paid\\n    uint owedInterestPayment = Math.min(params.interestOwed, remainingInterestPayment);\\n    remainingInterestPayment = remainingInterestPayment.sub(owedInterestPayment);\\n\\n    // 2. Any principal that is _currently_ owed must be paid\\n    // If you still owe interest then you can't pay back principal or pay down balance\\n    if (owedInterestPayment < params.interestOwed && params.principalPayment > 0) {\\n      revert(\\\"IO\\\");\\n    }\\n    uint owedPrincipalPayment = Math.min(remainingPrincipalPayment, params.principalOwed);\\n    remainingPrincipalPayment = remainingPrincipalPayment.sub(owedPrincipalPayment);\\n\\n    // 3. Any accured interest, meaning any interest that has accrued since the last payment\\n    //    date but isn't actually currently owed must be paid\\n    // If you still owe principal then you can't pay accrued interest\\n    if (\\n      owedPrincipalPayment < params.principalOwed &&\\n      remainingInterestPayment > 0 &&\\n      params.interestAccrued > 0\\n    ) {\\n      revert(\\\"PO\\\");\\n    }\\n    uint accruedInterestPayment = Math.min(remainingInterestPayment, params.interestAccrued);\\n    remainingInterestPayment = remainingInterestPayment.sub(accruedInterestPayment);\\n\\n    // 4. If there's remaining principal payment, it can be applied to remaining balance\\n    // But if you still have additional interest then you can't pay back balance\\n    if (\\n      accruedInterestPayment < params.interestAccrued &&\\n      remainingPrincipalPayment > 0 &&\\n      params.balance.sub(owedPrincipalPayment) > 0\\n    ) {\\n      revert(\\\"AI\\\");\\n    }\\n\\n    uint balanceRemaining = params.balance.sub(owedPrincipalPayment);\\n    uint additionalBalancePayment = Math.min(balanceRemaining, remainingPrincipalPayment);\\n    remainingPrincipalPayment = remainingPrincipalPayment.sub(additionalBalancePayment);\\n\\n    // 5. Any remaining payment is not applied\\n    uint paymentRemaining = remainingPrincipalPayment.add(remainingInterestPayment);\\n\\n    return\\n      ILoan.PaymentAllocation({\\n        owedInterestPayment: owedInterestPayment,\\n        accruedInterestPayment: accruedInterestPayment,\\n        principalPayment: owedPrincipalPayment,\\n        additionalBalancePayment: additionalBalancePayment,\\n        paymentRemaining: paymentRemaining\\n      });\\n  }\\n}\\n\",\"keccak256\":\"0x5e8027ec31b609677cf0cc34c390f8c6f868ab8f647c6c239c6516f1b021ac8e\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x610f48610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80635652172f1461006657806397aec1ab14610090578063a7beba8e146100a3578063da95434e146100b6578063f02cd2b4146100d6575b600080fd5b610079610074366004610d33565b6100f6565b604051610087929190610eec565b60405180910390f35b61007961009e366004610c63565b61018b565b6100796100b1366004610c1e565b6104b1565b6100c96100c4366004610c02565b61053e565b6040516100879190610ee2565b6100e96100e4366004610ca6565b6106e3565b6040516100879190610ea8565b600080600061010586896108ab565b905061011188826108c5565b9750600061011f858a6108ab565b905061012b89826108c5565b98506000610139878b6108ab565b90506101458a826108c5565b995060006101538a846108c5565b90506000610161828d6108ab565b905061016d85846108e1565b61017785836108e1565b9650965050505050505b9550959350505050565b600080610196610bc0565b61019f8861053e565b90506101ac8160006108f3565b156101be576000809250925050610181565b6101c6610bc0565b6101cf8661090a565b90506101d9610bc0565b60006102c68b6001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b15801561021757600080fd5b505afa15801561022b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061024f9190610d1b565b8c6001600160a01b03166321856b366040518163ffffffff1660e01b815260040160206040518083038186803b15801561028857600080fd5b505afa15801561029c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c09190610d1b565b906108e1565b90506102db846102d58361090a565b90610938565b91508a6001600160a01b03166364fb2d956040518163ffffffff1660e01b815260040160206040518083038186803b15801561031657600080fd5b505afa15801561032a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034e9190610d1b565b8911156103f85760006103d28c6001600160a01b03166364fb2d956040518163ffffffff1660e01b815260040160206040518083038186803b15801561039357600080fd5b505afa1580156103a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103cb9190610d1b565b8b906108c5565b90506103f46103ed620151806103e78461090a565b90610976565b8490610997565b9250505b610400610bc0565b6104098861090a565b9050610413610bc0565b61041d84866109ba565b156104335761042c600061090a565b9050610456565b610453610440600161090a565b61044e846102d5888a6109c2565b6109e5565b90505b61045e610bc0565b61047d670de0b6b3a76400006103e78f856109fc90919063ffffffff16565b90506000610498670de0b6b3a76400006103e78560646109fc565b519151919f919e50909c50505050505050505050505050565b60008061053186876001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b1580156104f157600080fd5b505afa158015610505573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105299190610d1b565b87878761018b565b9150915094509492505050565b610546610bc0565b6000610645670de0b6b3a764000061063f856001600160a01b031663b39699926040518163ffffffff1660e01b815260040160206040518083038186803b15801561059057600080fd5b505afa1580156105a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105c89190610d1b565b866001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b15801561060157600080fd5b505afa158015610615573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106399190610d1b565b90610a1d565b90610a44565b905061064f610bc0565b61065e61016d6103e78461090a565b90506106db846001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b15801561069c57600080fd5b505afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d49190610d1b565b8290610a60565b949350505050565b6106eb610bd3565b81511515806106fe575060008260200151115b6107235760405162461bcd60e51b815260040161071a90610e13565b60405180910390fd5b81516020830151606084015160009061073c90836108ab565b905061074882826108c5565b915084606001518110801561075d5750845115155b1561077a5760405162461bcd60e51b815260040161071a90610df7565b600061078a848760a001516108ab565b905061079684826108c5565b93508560a00151811080156107ab5750600083115b80156107bb575060008660800151115b156107d85760405162461bcd60e51b815260040161071a90610e2f565b60006107e88488608001516108ab565b90506107f484826108c5565b93508660800151811080156108095750600085115b80156108245750604087015160009061082290846108c5565b115b156108415760405162461bcd60e51b815260040161071a90610e4b565b604087015160009061085390846108c5565b9050600061086182886108ab565b905061086d87826108c5565b9650600061087b88886108e1565b6040805160a081018252978852602088019590955293860194909452606085015250608083015250949350505050565b60008183106108ba57816108bc565b825b90505b92915050565b60006108bc838360405180602001604052806000815250610a7a565b6000828201838110156108bc57600080fd5b60006108fe8261090a565b51835114905092915050565b610912610bc0565b60408051602081019091528061093084670de0b6b3a7640000610aa6565b905292915050565b610940610bc0565b604080516020810190915282518451829161096d9161096790670de0b6b3a7640000610aa6565b90610ae0565b90529392505050565b61097e610bc0565b60408051602081019091528351819061096d9085610ae0565b61099f610bc0565b604080516020810190915282518451829161096d9190610b22565b519051111590565b6109ca610bc0565b604080516020810190915282518451829161096d9190610b47565b6109ed610bc0565b81518351106108ba57816108bc565b610a04610bc0565b60408051602081019091528351819061096d9085610aa6565b600082610a2c575060006108bf565b82820282848281610a3957fe5b04146108bc57600080fd5b60006108bc838360405180602001604052806000815250610b89565b610a68610bc0565b6108bc83610a758461090a565b610997565b60008184841115610a9e5760405162461bcd60e51b815260040161071a9190610d6d565b505050900390565b600082610ab5575060006108bf565b82820282848281610ac257fe5b04146108bc5760405162461bcd60e51b815260040161071a90610e67565b60006108bc83836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610b89565b6000828201838110156108bc5760405162461bcd60e51b815260040161071a90610dc0565b60006108bc83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250610a7a565b60008183610baa5760405162461bcd60e51b815260040161071a9190610d6d565b506000838581610bb657fe5b0495945050505050565b6040518060200160405280600081525090565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b600060208284031215610c13578081fd5b81356108bc81610efa565b60008060008060808587031215610c33578283fd5b84356001600160a01b0381168114610c49578384fd5b966020860135965060408601359560600135945092505050565b600080600080600060a08688031215610c7a578081fd5b8535610c8581610efa565b97602087013597506040870135966060810135965060800135945092505050565b600060c08284031215610cb7578081fd5b60405160c0810181811067ffffffffffffffff82111715610cd6578283fd5b8060405250823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a08201528091505092915050565b600060208284031215610d2c578081fd5b5051919050565b600080600080600060a08688031215610d4a578081fd5b505083359560208501359550604085013594606081013594506080013592509050565b6000602080835283518082850152825b81811015610d9957858101830151858201604001528201610d7d565b81811115610daa5783604083870101525b50601f01601f1916929092016040019392505050565b6020808252601b908201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604082015260600190565b602080825260029082015261494f60f01b604082015260600190565b6020808252600290820152612d2d60f11b604082015260600190565b602080825260029082015261504f60f01b604082015260600190565b602080825260029082015261414960f01b604082015260600190565b60208082526021908201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6040820152607760f81b606082015260800190565b600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b9051815260200190565b918252602082015260400190565b6001600160a01b0381168114610f0f57600080fd5b5056fea26469706673582212201b20ab20c7f366a7393c7beeae7cb90da178d2d6fbb95b5ce8782bed66149ffd64736f6c634300060c0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c80635652172f1461006657806397aec1ab14610090578063a7beba8e146100a3578063da95434e146100b6578063f02cd2b4146100d6575b600080fd5b610079610074366004610d33565b6100f6565b604051610087929190610eec565b60405180910390f35b61007961009e366004610c63565b61018b565b6100796100b1366004610c1e565b6104b1565b6100c96100c4366004610c02565b61053e565b6040516100879190610ee2565b6100e96100e4366004610ca6565b6106e3565b6040516100879190610ea8565b600080600061010586896108ab565b905061011188826108c5565b9750600061011f858a6108ab565b905061012b89826108c5565b98506000610139878b6108ab565b90506101458a826108c5565b995060006101538a846108c5565b90506000610161828d6108ab565b905061016d85846108e1565b61017785836108e1565b9650965050505050505b9550959350505050565b600080610196610bc0565b61019f8861053e565b90506101ac8160006108f3565b156101be576000809250925050610181565b6101c6610bc0565b6101cf8661090a565b90506101d9610bc0565b60006102c68b6001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b15801561021757600080fd5b505afa15801561022b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061024f9190610d1b565b8c6001600160a01b03166321856b366040518163ffffffff1660e01b815260040160206040518083038186803b15801561028857600080fd5b505afa15801561029c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c09190610d1b565b906108e1565b90506102db846102d58361090a565b90610938565b91508a6001600160a01b03166364fb2d956040518163ffffffff1660e01b815260040160206040518083038186803b15801561031657600080fd5b505afa15801561032a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061034e9190610d1b565b8911156103f85760006103d28c6001600160a01b03166364fb2d956040518163ffffffff1660e01b815260040160206040518083038186803b15801561039357600080fd5b505afa1580156103a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103cb9190610d1b565b8b906108c5565b90506103f46103ed620151806103e78461090a565b90610976565b8490610997565b9250505b610400610bc0565b6104098861090a565b9050610413610bc0565b61041d84866109ba565b156104335761042c600061090a565b9050610456565b610453610440600161090a565b61044e846102d5888a6109c2565b6109e5565b90505b61045e610bc0565b61047d670de0b6b3a76400006103e78f856109fc90919063ffffffff16565b90506000610498670de0b6b3a76400006103e78560646109fc565b519151919f919e50909c50505050505050505050505050565b60008061053186876001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b1580156104f157600080fd5b505afa158015610505573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105299190610d1b565b87878761018b565b9150915094509492505050565b610546610bc0565b6000610645670de0b6b3a764000061063f856001600160a01b031663b39699926040518163ffffffff1660e01b815260040160206040518083038186803b15801561059057600080fd5b505afa1580156105a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105c89190610d1b565b866001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b15801561060157600080fd5b505afa158015610615573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106399190610d1b565b90610a1d565b90610a44565b905061064f610bc0565b61065e61016d6103e78461090a565b90506106db846001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b15801561069c57600080fd5b505afa1580156106b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106d49190610d1b565b8290610a60565b949350505050565b6106eb610bd3565b81511515806106fe575060008260200151115b6107235760405162461bcd60e51b815260040161071a90610e13565b60405180910390fd5b81516020830151606084015160009061073c90836108ab565b905061074882826108c5565b915084606001518110801561075d5750845115155b1561077a5760405162461bcd60e51b815260040161071a90610df7565b600061078a848760a001516108ab565b905061079684826108c5565b93508560a00151811080156107ab5750600083115b80156107bb575060008660800151115b156107d85760405162461bcd60e51b815260040161071a90610e2f565b60006107e88488608001516108ab565b90506107f484826108c5565b93508660800151811080156108095750600085115b80156108245750604087015160009061082290846108c5565b115b156108415760405162461bcd60e51b815260040161071a90610e4b565b604087015160009061085390846108c5565b9050600061086182886108ab565b905061086d87826108c5565b9650600061087b88886108e1565b6040805160a081018252978852602088019590955293860194909452606085015250608083015250949350505050565b60008183106108ba57816108bc565b825b90505b92915050565b60006108bc838360405180602001604052806000815250610a7a565b6000828201838110156108bc57600080fd5b60006108fe8261090a565b51835114905092915050565b610912610bc0565b60408051602081019091528061093084670de0b6b3a7640000610aa6565b905292915050565b610940610bc0565b604080516020810190915282518451829161096d9161096790670de0b6b3a7640000610aa6565b90610ae0565b90529392505050565b61097e610bc0565b60408051602081019091528351819061096d9085610ae0565b61099f610bc0565b604080516020810190915282518451829161096d9190610b22565b519051111590565b6109ca610bc0565b604080516020810190915282518451829161096d9190610b47565b6109ed610bc0565b81518351106108ba57816108bc565b610a04610bc0565b60408051602081019091528351819061096d9085610aa6565b600082610a2c575060006108bf565b82820282848281610a3957fe5b04146108bc57600080fd5b60006108bc838360405180602001604052806000815250610b89565b610a68610bc0565b6108bc83610a758461090a565b610997565b60008184841115610a9e5760405162461bcd60e51b815260040161071a9190610d6d565b505050900390565b600082610ab5575060006108bf565b82820282848281610ac257fe5b04146108bc5760405162461bcd60e51b815260040161071a90610e67565b60006108bc83836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610b89565b6000828201838110156108bc5760405162461bcd60e51b815260040161071a90610dc0565b60006108bc83836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250610a7a565b60008183610baa5760405162461bcd60e51b815260040161071a9190610d6d565b506000838581610bb657fe5b0495945050505050565b6040518060200160405280600081525090565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b600060208284031215610c13578081fd5b81356108bc81610efa565b60008060008060808587031215610c33578283fd5b84356001600160a01b0381168114610c49578384fd5b966020860135965060408601359560600135945092505050565b600080600080600060a08688031215610c7a578081fd5b8535610c8581610efa565b97602087013597506040870135966060810135965060800135945092505050565b600060c08284031215610cb7578081fd5b60405160c0810181811067ffffffffffffffff82111715610cd6578283fd5b8060405250823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a08201528091505092915050565b600060208284031215610d2c578081fd5b5051919050565b600080600080600060a08688031215610d4a578081fd5b505083359560208501359550604085013594606081013594506080013592509050565b6000602080835283518082850152825b81811015610d9957858101830151858201604001528201610d7d565b81811115610daa5783604083870101525b50601f01601f1916929092016040019392505050565b6020808252601b908201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604082015260600190565b602080825260029082015261494f60f01b604082015260600190565b6020808252600290820152612d2d60f11b604082015260600190565b602080825260029082015261504f60f01b604082015260600190565b602080825260029082015261414960f01b604082015260600190565b60208082526021908201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6040820152607760f81b606082015260800190565b600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b9051815260200190565b918252602082015260400190565b6001600160a01b0381168114610f0f57600080fd5b5056fea26469706673582212201b20ab20c7f366a7393c7beeae7cb90da178d2d6fbb95b5ce8782bed66149ffd64736f6c634300060c0033",
  "devdoc": {
    "author": "Goldfinch",
    "kind": "dev",
    "methods": {
      "allocatePayment(Accountant.AllocatePaymentParams)": {
        "details": "IO - Interest OwedPO - Principal OwedAI - Accrued Interest",
        "params": {
          "params": "specifying payment amounts and amounts owed"
        },
        "returns": {
          "_0": "payment allocation"
        }
      }
    },
    "title": "The Accountant",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "allocatePayment(Accountant.AllocatePaymentParams)": {
        "notice": "Allocate a payment.  1. interestOwed must be paid before principalOwed  2. principalOwed must be paid before interestAccrued  3. interestAccrued must be paid before the rest of the balance"
      },
      "splitPayment(uint256,uint256,uint256,uint256,uint256)": {
        "notice": "Given a lump sum, returns the amount of the payment that should be allocated         to paying interest, and the amount that should be allocated to paying principal"
      }
    },
    "notice": "Library for handling key financial calculations, such as interest and principal accrual.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}