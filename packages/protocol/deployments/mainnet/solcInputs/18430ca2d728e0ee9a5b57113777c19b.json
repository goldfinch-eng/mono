{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControlUpgradeable, IAccessControlUpgradeable) {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {\n    function __ERC1155Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __Pausable_init_unchained();\n        __ERC1155Pausable_init_unchained();\n    }\n\n    function __ERC1155Pausable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "BokkyPooBahsDateTimeLibrary/contracts/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "contracts/cake/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IAccessControl.sol\";\n\n/// @title Cake access control\n/// @author landakram\n/// @notice This contact centralizes contract-to-contract access control using a simple\n/// access-control list. There are two types of actors: operators and admins. Operators\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\n/// contract for which the current contract is a dependency. Admins are callers allowed\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\ncontract AccessControl is Initializable, IAccessControl {\n  /// @dev Mapping from contract address to contract admin;\n  mapping(address => address) public admins;\n\n  function initialize(address admin) public initializer {\n    admins[address(this)] = admin;\n    emit AdminSet(address(this), admin);\n  }\n\n  /// @inheritdoc IAccessControl\n  function setAdmin(address resource, address admin) external {\n    requireSuperAdmin(msg.sender);\n    admins[resource] = admin;\n    emit AdminSet(resource, admin);\n  }\n\n  /// @inheritdoc IAccessControl\n  function requireAdmin(address resource, address accessor) public view {\n    if (accessor == address(0)) revert ZeroAddress();\n    bool isAdmin = admins[resource] == accessor;\n    if (!isAdmin) revert RequiresAdmin(resource, accessor);\n  }\n\n  /// @inheritdoc IAccessControl\n  function requireSuperAdmin(address accessor) public view {\n    // The super admin is the admin of this AccessControl contract\n    requireAdmin({resource: address(this), accessor: accessor});\n  }\n}\n"
    },
    "contracts/cake/Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {Context} from \"./Context.sol\";\nimport \"./Routing.sol\" as Routing;\n\nusing Routing.Context for Context;\n\n/// @title Base contract for application-layer\n/// @author landakram\n/// @notice This base contract is what all application-layer contracts should inherit from.\n///  It provides `Context`, as well as some convenience functions for working with it and\n///  using access control. All public methods on the inheriting contract should likely\n///  use one of the modifiers to assert valid callers.\nabstract contract Base {\n  error RequiresOperator(address resource, address accessor);\n  error ZeroAddress();\n\n  /// @dev this is safe for proxies as immutable causes the context to be written to\n  ///  bytecode on deployment. The proxy then treats this as a constant.\n  Context immutable context;\n\n  constructor(Context _context) {\n    context = _context;\n  }\n\n  modifier onlyOperator(bytes4 operatorId) {\n    requireOperator(operatorId, msg.sender);\n    _;\n  }\n\n  modifier onlyOperators(bytes4[2] memory operatorIds) {\n    requireAnyOperator(operatorIds, msg.sender);\n    _;\n  }\n\n  modifier onlyAdmin() {\n    context.accessControl().requireAdmin(address(this), msg.sender);\n    _;\n  }\n\n  function requireAnyOperator(bytes4[2] memory operatorIds, address accessor) private view {\n    if (accessor == address(0)) revert ZeroAddress();\n\n    bool validOperator = isOperator(operatorIds[0], accessor) ||\n      isOperator(operatorIds[1], accessor);\n\n    if (!validOperator) revert RequiresOperator(address(this), accessor);\n  }\n\n  function requireOperator(bytes4 operatorId, address accessor) private view {\n    if (accessor == address(0)) revert ZeroAddress();\n    if (!isOperator(operatorId, accessor)) revert RequiresOperator(address(this), accessor);\n  }\n\n  function isOperator(bytes4 operatorId, address accessor) private view returns (bool) {\n    return context.router().contracts(operatorId) == accessor;\n  }\n}\n"
    },
    "contracts/cake/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {AccessControl} from \"./AccessControl.sol\";\nimport {Router} from \"./Router.sol\";\nimport \"./Routing.sol\" as Routing;\n\nusing Routing.Context for Context;\n\n/// @title Entry-point for all application-layer contracts.\n/// @author landakram\n/// @notice This contract provides an interface for retrieving other contract addresses and doing access\n///  control.\ncontract Context {\n  /// @notice Used for retrieving other contract addresses.\n  /// @dev This variable is immutable. This is done to save gas, as it is expected to be referenced\n  /// in every end-user call with a call-chain length > 0. Note that it is written into the contract\n  /// bytecode at contract creation time, so if the contract is deployed as the implementation for proxies,\n  /// every proxy will share the same Router address.\n  Router public immutable router;\n\n  constructor(Router _router) {\n    router = _router;\n  }\n}\n"
    },
    "contracts/cake/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// solhint-disable-next-line max-line-length\nimport {PausableUpgradeable as OZPausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport {Base} from \"./Base.sol\";\nimport \"./Routing.sol\" as Routing;\n\nabstract contract PausableUpgradeable is Base, OZPausableUpgradeable {\n  function pause() external onlyOperators([Routing.Keys.PauserAdmin, Routing.Keys.ProtocolAdmin]) {\n    _pause();\n  }\n\n  function unpause()\n    external\n    onlyOperators([Routing.Keys.PauserAdmin, Routing.Keys.ProtocolAdmin])\n  {\n    _unpause();\n  }\n}\n"
    },
    "contracts/cake/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControl} from \"./AccessControl.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\n\nimport \"./Routing.sol\" as Routing;\n\n/// @title Router\n/// @author landakram\n/// @notice This contract provides service discovery for contracts using the cake framework.\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\n///   and `Routing.Keys` libraries.\ncontract Router is Initializable, IRouter {\n  /// @notice Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of\n  ///   the contract's name. See Routing.sol for all options.\n  mapping(bytes4 => address) public contracts;\n\n  function initialize(AccessControl accessControl) public initializer {\n    contracts[Routing.Keys.AccessControl] = address(accessControl);\n  }\n\n  /// @notice Associate a routing key to a contract address\n  /// @dev This function is only callable by the Router admin\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\n  /// @param addr A contract address\n  function setContract(bytes4 key, address addr) public {\n    AccessControl accessControl = AccessControl(contracts[Routing.Keys.AccessControl]);\n    accessControl.requireAdmin(address(this), msg.sender);\n    contracts[key] = addr;\n    emit SetContract(key, addr);\n  }\n}\n"
    },
    "contracts/cake/Routing.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable const-name-snakecase\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\n\nimport {IMembershipVault} from \"../interfaces/IMembershipVault.sol\";\nimport {IGFILedger} from \"../interfaces/IGFILedger.sol\";\nimport {ICapitalLedger} from \"../interfaces/ICapitalLedger.sol\";\nimport {IMembershipDirector} from \"../interfaces/IMembershipDirector.sol\";\nimport {IMembershipOrchestrator} from \"../interfaces/IMembershipOrchestrator.sol\";\nimport {IMembershipLedger} from \"../interfaces/IMembershipLedger.sol\";\nimport {IMembershipCollector} from \"../interfaces/IMembershipCollector.sol\";\nimport {IBackerRewards} from \"../interfaces/IBackerRewards.sol\";\n\nimport {ISeniorPool} from \"../interfaces/ISeniorPool.sol\";\nimport {IPoolTokens} from \"../interfaces/IPoolTokens.sol\";\nimport {IStakingRewards} from \"../interfaces/IStakingRewards.sol\";\nimport {IGo} from \"../interfaces/IGo.sol\";\n\nimport {IERC20Splitter} from \"../interfaces/IERC20Splitter.sol\";\nimport {Context as ContextContract} from \"./Context.sol\";\nimport {IAccessControl} from \"../interfaces/IAccessControl.sol\";\n\n/// @title Routing.Keys\n/// @notice This library is used to define routing keys used by `Router`.\n/// @dev We use uints instead of enums for several reasons. First, keys can be re-ordered\n///   or removed. This is useful when routing keys are deprecated; they can be moved to a\n///   different section of the file. Second, other libraries or contracts can define their\n///   own routing keys independent of this global mapping. This is useful for test contracts.\nlibrary Keys {\n  // Membership\n  bytes4 internal constant MembershipOrchestrator = bytes4(keccak256(\"MembershipOrchestrator\"));\n  bytes4 internal constant MembershipDirector = bytes4(keccak256(\"MembershipDirector\"));\n  bytes4 internal constant GFILedger = bytes4(keccak256(\"GFILedger\"));\n  bytes4 internal constant CapitalLedger = bytes4(keccak256(\"CapitalLedger\"));\n  bytes4 internal constant MembershipCollector = bytes4(keccak256(\"MembershipCollector\"));\n  bytes4 internal constant MembershipLedger = bytes4(keccak256(\"MembershipLedger\"));\n  bytes4 internal constant MembershipVault = bytes4(keccak256(\"MembershipVault\"));\n\n  // Tokens\n  bytes4 internal constant GFI = bytes4(keccak256(\"GFI\"));\n  bytes4 internal constant FIDU = bytes4(keccak256(\"FIDU\"));\n  bytes4 internal constant USDC = bytes4(keccak256(\"USDC\"));\n\n  // Cake\n  bytes4 internal constant AccessControl = bytes4(keccak256(\"AccessControl\"));\n  bytes4 internal constant Router = bytes4(keccak256(\"Router\"));\n\n  // Core\n  bytes4 internal constant ReserveSplitter = bytes4(keccak256(\"ReserveSplitter\"));\n  bytes4 internal constant PoolTokens = bytes4(keccak256(\"PoolTokens\"));\n  bytes4 internal constant SeniorPool = bytes4(keccak256(\"SeniorPool\"));\n  bytes4 internal constant StakingRewards = bytes4(keccak256(\"StakingRewards\"));\n  bytes4 internal constant ProtocolAdmin = bytes4(keccak256(\"ProtocolAdmin\"));\n  bytes4 internal constant PauserAdmin = bytes4(keccak256(\"PauserAdmin\"));\n  bytes4 internal constant BackerRewards = bytes4(keccak256(\"BackerRewards\"));\n  bytes4 internal constant Go = bytes4(keccak256(\"Go\"));\n}\n\n/// @title Routing.Context\n/// @notice This library provides convenience functions for getting contracts from `Router`.\nlibrary Context {\n  function accessControl(ContextContract context) internal view returns (IAccessControl) {\n    return IAccessControl(context.router().contracts(Keys.AccessControl));\n  }\n\n  function membershipVault(ContextContract context) internal view returns (IMembershipVault) {\n    return IMembershipVault(context.router().contracts(Keys.MembershipVault));\n  }\n\n  function capitalLedger(ContextContract context) internal view returns (ICapitalLedger) {\n    return ICapitalLedger(context.router().contracts(Keys.CapitalLedger));\n  }\n\n  function gfiLedger(ContextContract context) internal view returns (IGFILedger) {\n    return IGFILedger(context.router().contracts(Keys.GFILedger));\n  }\n\n  function gfi(ContextContract context) internal view returns (IERC20Upgradeable) {\n    return IERC20Upgradeable(context.router().contracts(Keys.GFI));\n  }\n\n  function membershipDirector(ContextContract context) internal view returns (IMembershipDirector) {\n    return IMembershipDirector(context.router().contracts(Keys.MembershipDirector));\n  }\n\n  function membershipOrchestrator(\n    ContextContract context\n  ) internal view returns (IMembershipOrchestrator) {\n    return IMembershipOrchestrator(context.router().contracts(Keys.MembershipOrchestrator));\n  }\n\n  function stakingRewards(ContextContract context) internal view returns (IStakingRewards) {\n    return IStakingRewards(context.router().contracts(Keys.StakingRewards));\n  }\n\n  function poolTokens(ContextContract context) internal view returns (IPoolTokens) {\n    return IPoolTokens(context.router().contracts(Keys.PoolTokens));\n  }\n\n  function seniorPool(ContextContract context) internal view returns (ISeniorPool) {\n    return ISeniorPool(context.router().contracts(Keys.SeniorPool));\n  }\n\n  function fidu(ContextContract context) internal view returns (IERC20Upgradeable) {\n    return IERC20Upgradeable(context.router().contracts(Keys.FIDU));\n  }\n\n  function usdc(ContextContract context) internal view returns (IERC20Upgradeable) {\n    return IERC20Upgradeable(context.router().contracts(Keys.USDC));\n  }\n\n  function reserveSplitter(ContextContract context) internal view returns (IERC20Splitter) {\n    return IERC20Splitter(context.router().contracts(Keys.ReserveSplitter));\n  }\n\n  function membershipLedger(ContextContract context) internal view returns (IMembershipLedger) {\n    return IMembershipLedger(context.router().contracts(Keys.MembershipLedger));\n  }\n\n  function membershipCollector(\n    ContextContract context\n  ) internal view returns (IMembershipCollector) {\n    return IMembershipCollector(context.router().contracts(Keys.MembershipCollector));\n  }\n\n  function protocolAdmin(ContextContract context) internal view returns (address) {\n    return context.router().contracts(Keys.ProtocolAdmin);\n  }\n\n  function pauserAdmin(ContextContract context) internal view returns (address) {\n    return context.router().contracts(Keys.PauserAdmin);\n  }\n\n  function backerRewards(ContextContract context) internal view returns (IBackerRewards) {\n    return IBackerRewards(context.router().contracts(Keys.BackerRewards));\n  }\n\n  function go(ContextContract context) internal view returns (IGo) {\n    return IGo(context.router().contracts(Keys.Go));\n  }\n}\n"
    },
    "contracts/interfaces/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/// @title Cake access control\n/// @author landakram\n/// @notice This contact centralizes contract-to-contract access control using a simple\n/// access-control list. There are two types of actors: operators and admins. Operators\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\n/// contract for which the current contract is a dependency. Admins are callers allowed\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\ninterface IAccessControl {\n  error RequiresAdmin(address resource, address accessor);\n  error ZeroAddress();\n\n  event AdminSet(address indexed resource, address indexed admin);\n\n  /// @notice Set an admin for a given resource\n  /// @param resource An address which with `admin` should be allowed to administer\n  /// @param admin An address which should be allowed to administer `resource`\n  /// @dev This method is only callable by the super-admin (the admin of this AccessControl\n  ///   contract)\n  function setAdmin(address resource, address admin) external;\n\n  /// @notice Require a valid admin for a given resource\n  /// @param resource An address that `accessor` is attempting to access\n  /// @param accessor An address on which to assert access control checks\n  /// @dev This method reverts when `accessor` is not a valid admin\n  function requireAdmin(address resource, address accessor) external view;\n\n  /// @notice Require a super-admin. A super-admin is an admin of this AccessControl contract.\n  /// @param accessor An address on which to assert access control checks\n  /// @dev This method reverts when `accessor` is not a valid super-admin\n  function requireSuperAdmin(address accessor) external view;\n}\n"
    },
    "contracts/interfaces/IBackerRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport {ITranchedPool} from \"./ITranchedPool.sol\";\n\ninterface IBackerRewards {\n  struct BackerRewardsTokenInfo {\n    uint256 rewardsClaimed; // gfi claimed\n    uint256 accRewardsPerPrincipalDollarAtMint; // Pool's accRewardsPerPrincipalDollar at PoolToken mint()\n  }\n\n  struct BackerRewardsInfo {\n    uint256 accRewardsPerPrincipalDollar; // accumulator gfi per interest dollar\n  }\n\n  /// @notice Staking rewards parameters relevant to a TranchedPool\n  struct StakingRewardsPoolInfo {\n    // @notice the value `StakingRewards.accumulatedRewardsPerToken()` at the last checkpoint\n    uint256 accumulatedRewardsPerTokenAtLastCheckpoint;\n    // @notice last time the rewards info was updated\n    //\n    // we need this in order to know how much to pro rate rewards after the term is over.\n    uint256 lastUpdateTime;\n    // @notice staking rewards parameters for each slice of the tranched pool\n    StakingRewardsSliceInfo[] slicesInfo;\n  }\n\n  /// @notice Staking rewards paramters relevant to a TranchedPool slice\n  struct StakingRewardsSliceInfo {\n    // @notice fidu share price when the slice is first drawn down\n    //\n    // we need to save this to calculate what an equivalent position in\n    // the senior pool would be at the time the slice is downdown\n    uint256 fiduSharePriceAtDrawdown;\n    // @notice the amount of principal deployed at the last checkpoint\n    //\n    // we use this to calculate the amount of principal that should\n    // acctually accrue rewards during between the last checkpoint and\n    // and subsequent updates\n    uint256 principalDeployedAtLastCheckpoint;\n    // @notice the value of StakingRewards.accumulatedRewardsPerToken() at time of drawdown\n    //\n    // we need to keep track of this to use this as a base value to accumulate rewards\n    // for tokens. If the token has never claimed staking rewards, we use this value\n    // and the current staking rewards accumulator\n    uint256 accumulatedRewardsPerTokenAtDrawdown;\n    // @notice amount of rewards per token accumulated over the lifetime of the slice that a backer\n    //          can claim\n    uint256 accumulatedRewardsPerTokenAtLastCheckpoint;\n    // @notice the amount of rewards per token accumulated over the lifetime of the slice\n    //\n    // this value is \"unrealized\" because backers will be unable to claim against this value.\n    // we keep this value so that we can always accumulate rewards for the amount of capital\n    // deployed at any point in time, but not allow backers to withdraw them until a payment\n    // is made. For example: we want to accumulate rewards when a backer does a drawdown. but\n    // a backer shouldn't be allowed to claim rewards until a payment is made.\n    //\n    // this value is scaled depending on the current proportion of capital currently deployed\n    // in the slice. For example, if the staking rewards contract accrued 10 rewards per token\n    // between the current checkpoint and a new update, and only 20% of the capital was deployed\n    // during that period, we would accumulate 2 (10 * 20%) rewards.\n    uint256 unrealizedAccumulatedRewardsPerTokenAtLastCheckpoint;\n  }\n\n  /// @notice Staking rewards parameters relevant to a PoolToken\n  struct StakingRewardsTokenInfo {\n    // @notice the amount of rewards accumulated the last time a token's rewards were withdrawn\n    uint256 accumulatedRewardsPerTokenAtLastWithdraw;\n  }\n\n  /// @notice total amount of GFI rewards available, times 1e18\n  function totalRewards() external view returns (uint256);\n\n  /// @notice interest $ eligible for gfi rewards, times 1e18\n  function maxInterestDollarsEligible() external view returns (uint256);\n\n  /// @notice counter of total interest repayments, times 1e6\n  function totalInterestReceived() external view returns (uint256);\n\n  /// @notice totalRewards/totalGFISupply * 100, times 1e18\n  function totalRewardPercentOfTotalGFI() external view returns (uint256);\n\n  /// @notice Get backer rewards metadata for a pool token\n  function getTokenInfo(uint256 poolTokenId) external view returns (BackerRewardsTokenInfo memory);\n\n  /// @notice Get backer staking rewards metadata for a pool token\n  function getStakingRewardsTokenInfo(\n    uint256 poolTokenId\n  ) external view returns (StakingRewardsTokenInfo memory);\n\n  /// @notice Get backer staking rewards for a pool\n  function getBackerStakingRewardsPoolInfo(\n    ITranchedPool pool\n  ) external view returns (StakingRewardsPoolInfo memory);\n\n  /// @notice Calculates the accRewardsPerPrincipalDollar for a given pool,\n  ///   when a interest payment is received by the protocol\n  /// @param _interestPaymentAmount Atomic usdc amount of the interest payment\n  function allocateRewards(uint256 _interestPaymentAmount) external;\n\n  /// @notice callback for TranchedPools when they drawdown\n  /// @param sliceIndex index of the tranched pool slice\n  /// @dev initializes rewards info for the calling TranchedPool if it's the first\n  ///  drawdown for the given slice\n  function onTranchedPoolDrawdown(uint256 sliceIndex) external;\n\n  /// @notice When a pool token is minted for multiple drawdowns,\n  ///   set accRewardsPerPrincipalDollarAtMint to the current accRewardsPerPrincipalDollar price\n  /// @param poolAddress Address of the pool associated with the pool token\n  /// @param tokenId Pool token id\n  function setPoolTokenAccRewardsPerPrincipalDollarAtMint(\n    address poolAddress,\n    uint256 tokenId\n  ) external;\n\n  /// @notice PoolToken request to withdraw all allocated rewards\n  /// @param tokenId Pool token id\n  /// @return amount of rewards withdrawn\n  function withdraw(uint256 tokenId) external returns (uint256);\n\n  /**\n   * @notice Set BackerRewards and BackerStakingRewards metadata for tokens created by a pool token split.\n   * @param originalBackerRewardsTokenInfo backer rewards info for the pool token that was split\n   * @param originalStakingRewardsTokenInfo backer staking rewards info for the pool token that was split\n   * @param newTokenId id of one of the tokens in the split\n   * @param newRewardsClaimed rewardsClaimed value for the new token.\n   */\n  function setBackerAndStakingRewardsTokenInfoOnSplit(\n    BackerRewardsTokenInfo memory originalBackerRewardsTokenInfo,\n    StakingRewardsTokenInfo memory originalStakingRewardsTokenInfo,\n    uint256 newTokenId,\n    uint256 newRewardsClaimed\n  ) external;\n\n  /**\n   * @notice Calculate the gross available gfi rewards for a PoolToken\n   * @param tokenId Pool token id\n   * @return The amount of GFI claimable\n   */\n  function poolTokenClaimableRewards(uint256 tokenId) external view returns (uint256);\n\n  /// @notice Clear all BackerRewards and StakingRewards associated data for `tokenId`\n  function clearTokenInfo(uint256 tokenId) external;\n}\n"
    },
    "contracts/interfaces/IBorrower.sol": {
      "content": "// SPDX-Licence-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IBorrower {\n  function initialize(address owner, address _config) external;\n\n  function drawdown(address poolAddress, uint256 amount, address addressToSendTo) external;\n}\n"
    },
    "contracts/interfaces/ICallableLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ILoan} from \"./ILoan.sol\";\nimport {ISchedule} from \"./ISchedule.sol\";\nimport {IGoldfinchConfig} from \"./IGoldfinchConfig.sol\";\n\n/// A LoanPhase represents a period of time during which certain callable loan actions are prohibited.\n/// @param Prefunding Starts when a loan is created and ends at fundableAt.\n/// In Prefunding, all actions are prohibited or ineffectual.\n/// @param Funding Starts at the fundableAt timestamp and ends at the first borrower drawdown.\n/// In Funding, lenders can deposit principal to mint a pool token and they can withdraw their deposited principal.\n/// @param DrawdownPeriod Starts when the first borrower drawdown occurs and\n/// ends after ConfigHelper.DrawdownPeriodInSeconds elapses.\n/// In DrawdownPeriod, the borrower can drawdown principal as many times as they want.\n/// Lenders cannot withdraw their principal, deposit new principal, or submit call requests.\n/// @param InProgress Starts after ConfigHelper.DrawdownPeriodInSeconds elapses and never ends.\n/// In InProgress, all post-funding & drawdown actions are allowed (not withdraw, deposit, or drawdown).\n/// When a loan is fully paid back, we do not update the loan state, but most of these actions will\n/// be prohibited or ineffectual.\n/// There is no \"Closed\" or \"Finished\" state because after accounting variables reflect a balance of 0 - the loan\n/// will still behave the same.\nenum LoanPhase {\n  Prefunding,\n  Funding,\n  DrawdownPeriod,\n  InProgress\n}\n\n/// @dev A CallableLoan is a loan which allows the lender to call the borrower's principal.\n///     The lender can call the borrower's principal at any time, and the borrower must pay back the principal\n///     by the end of the call request period.\n/// @dev The ICallableLoanErrors interface contains all errors due to Solidity version compatibility with custom errors.\ninterface ICallableLoan is ILoan {\n  /*================================================================================\n  Structs\n  ================================================================================*/\n  /// @param principalDeposited The amount of principal deposited towards this call request period.\n  /// @param principalPaid The amount of principal which has already been paid back towards this call request period.\n  ///                      There are 3 ways principal paid can enter a CallRequestPeriod.\n  ///                      1. Converted from principalReserved after a call request period becomes due.\n  ///                      2. Moved from uncalled tranche as the result of a call request.\n  ///                      3. Paid directly when a CallRequestPeriod is past due and has a remaining balance.\n  /// @param principalReserved The amount of principal reserved for this call request period.\n  ///                          Payments to a not-yet-due CallRequestPeriod are applied to principalReserved.\n  /// @param interestPaid The amount of interest paid towards this call request period.\n  struct CallRequestPeriod {\n    uint256 principalDeposited;\n    uint256 principalPaid;\n    uint256 principalReserved;\n    uint256 interestPaid;\n  }\n\n  /// @param principalDeposited The amount of uncalled, deposited principal.\n  /// @param principalPaid The amount of principal which has already been paid back.\n  ///                      There are two ways uncalled principal can be paid.\n  ///                      1. Remainder after drawdowns.\n  ///                      2. Conversion from principalReserved after a call request period becomes due.\n  ///                         All call requested principal outstanding must already be paid\n  ///                         (or have principal reserved) before uncalled principal can be paid.\n  ///                      3. Paid directly after term end time.\n  /// @param principalReserved The amount of principal reserved for uncalled tranche.\n  ///                          principalReserved is greedily moved to call request periods (as much as can fill)\n  ///                          when a call request is submitted.\n  /// @param interestPaid The amount of interest paid towards uncalled capital.\n  struct UncalledCapitalInfo {\n    uint256 principalDeposited;\n    uint256 principalPaid;\n    uint256 principalReserved;\n    uint256 interestPaid;\n  }\n\n  /*================================================================================\n  Functions\n  ================================================================================*/\n  /// @notice Initialize the pool. Can only be called once, and should be called in the same transaction as\n  ///   contract creation to avoid initialization front-running\n  /// @param _config address of GoldfinchConfig\n  /// @param _borrower address of borrower, a non-transferrable role for performing privileged actions like\n  ///   drawdown\n  /// @param _numLockupPeriods the number of periods at the tail end of a principal period during which call requests\n  ///   are not allowed\n  /// @param _interestApr interest rate for the loan\n  /// @param _lateFeeApr late fee interest rate for the loan, which kicks in `LatenessGracePeriodInDays` days after a\n  ///   payment becomes late\n  /// @param _fundableAt earliest time at which the first slice can be funded\n  function initialize(\n    IGoldfinchConfig _config,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _numLockupPeriods,\n    ISchedule _schedule,\n    uint256 _lateFeeApr,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) external;\n\n  /// @notice Submits a call request for the specified pool token and amount\n  ///         Mints a new, called pool token of the called amount.\n  ///         Splits off any uncalled amount as a new uncalled pool token.\n  /// @param amountToCall The amount of the pool token that should be called.\n  /// @param poolTokenId The id of the pool token that should be called.\n  /// @return callRequestedTokenId  Token id of the call requested token.\n  /// @return remainingTokenId Token id of the remaining token.\n  function submitCall(\n    uint256 amountToCall,\n    uint256 poolTokenId\n  ) external returns (uint256, uint256);\n\n  function schedule() external view returns (ISchedule);\n\n  function nextDueTimeAt(uint256 timestamp) external view returns (uint256);\n\n  function nextPrincipalDueTime() external view returns (uint256);\n\n  function numLockupPeriods() external view returns (uint256);\n\n  function inLockupPeriod() external view returns (bool);\n\n  function getUncalledCapitalInfo() external view returns (UncalledCapitalInfo memory);\n\n  function getCallRequestPeriod(\n    uint256 callRequestPeriodIndex\n  ) external view returns (CallRequestPeriod memory);\n\n  function uncalledCapitalTrancheIndex() external view returns (uint256);\n\n  function availableToCall(uint256 tokenId) external view returns (uint256);\n\n  /// @notice Returns the current phase of the loan.\n  ///         See documentation on LoanPhase enum.\n  function loanPhase() external view returns (LoanPhase);\n\n  /// @notice Returns the current balance of the loan which will be used for\n  ///         interest calculations.\n  ///         Settles any principal reserved if a call request period has\n  ///         ended since the last checkpoint\n  ///         Excludes principal reserved for future call request periods\n  function interestBearingBalance() external view returns (uint256);\n\n  /// @notice Returns a naive estimate of the interest owed at the timestamp.\n  ///         Omits any late fees, and assumes no future payments.\n  function estimateOwedInterestAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Returns a naive estimate of the interest owed at the timestamp.\n  ///         Omits any late fees, and assumes no future payments.\n  function estimateOwedInterestAt(\n    uint256 balance,\n    uint256 timestamp\n  ) external view returns (uint256);\n\n  /*================================================================================\n  Events\n  ================================================================================*/\n  event CallRequestSubmitted(\n    uint256 indexed originalTokenId,\n    uint256 indexed callRequestedTokenId,\n    uint256 indexed remainingTokenId,\n    uint256 callAmount\n  );\n  event DepositsLocked(address indexed loan);\n}\n"
    },
    "contracts/interfaces/ICallableLoanErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4;\n\nimport {LoanPhase} from \"./ICallableLoan.sol\";\n\n/// @dev This interface is used to define errors for the CallableLoan contract.\n///      Ideally this would be on ICallableLoan, but custom errors are only supported\n///      in Solidity version >= 0.8.4, and ICallableLoan requires Solidity 0.6.x conformance.\ninterface ICallableLoanErrors {\n  /*================================================================================\n  Drawdowns\n  ================================================================================*/\n  error CannotDrawdownWhenDrawdownsPaused();\n  error DrawdownAmountExceedsDeposits(uint256 drawdownAmount, uint256 existingPrincipalPaid);\n\n  /*================================================================================\n  Zero Amounts\n  ================================================================================*/\n  error ZeroDrawdownAmount();\n  error ZeroPaymentAmount();\n  error ZeroDepositAmount();\n  error ZeroWithdrawAmount();\n  error ZeroCallSubmissionAmount();\n\n  /*================================================================================\n  Withdrawals\n  ================================================================================*/\n  error WithdrawAmountExceedsWithdrawable(uint256 withdrawAmount, uint256 withdrawableAmount);\n  error InvalidLoanPhase(LoanPhase currentLoanPhase, LoanPhase validLoanPhase);\n  error ArrayLengthMismatch(uint256 arrayLength1, uint256 arrayLength2);\n  error CannotWithdrawInDrawdownPeriod();\n  error NotAuthorizedToWithdraw(address withdrawSender, uint256 tokenId);\n\n  /*================================================================================\n  Payments\n  ================================================================================*/\n  error NoBalanceToPay(uint256 attemptedPrincipalPayment);\n\n  /*================================================================================\n  Call Requests\n  ================================================================================*/\n  error MustSubmitCallToUncalledTranche(uint256 inputTranche, uint256 uncalledTranche);\n  error OutOfCallRequestPeriodBounds(uint256 lastCallRequestPeriod);\n  error CannotSubmitCallInLockupPeriod();\n  error TooLateToSubmitCallRequests();\n  error NotAuthorizedToSubmitCall(address callSubmissionSender, uint256 tokenId);\n  error InvalidCallSubmissionPoolToken(uint256 tokenId);\n  error ExcessiveCallSubmissionAmount(\n    uint256 poolTokenId,\n    uint256 callSubmissionAmount,\n    uint256 maxCallSubmissionAmount\n  );\n\n  /*================================================================================\n  Deposits\n  ================================================================================*/\n  error MustDepositToUncalledTranche(uint256 inputTranche, uint256 uncalledTranche);\n  error InvalidUIDForDepositor(address depositor);\n  error DepositExceedsLimit(uint256 deposit, uint256 amountCurrentlyDeposited, uint256 limit);\n\n  /*================================================================================\n  Miscellaneous\n  ================================================================================*/\n  error CannotSetAllowedUIDTypesAfterDeposit();\n  error CannotSetFundableAtAfterFundableAt(uint256 existingFundableAt);\n  error RequiresLockerRole(address nonLockerAddress);\n  error RequiresUpgrade();\n\n  /*================================================================================\n  Initialization\n  ================================================================================*/\n  error HasInsufficientTranches(uint256 numPrincipalPeriods, uint256 minimumNumPrincipalPeriods);\n  error CannotReinitialize();\n  error InvalidNumLockupPeriods(uint256 numLockupPeriods, uint256 periodsPerPrincipalPeriod);\n  error UnsupportedOperation();\n\n  /*================================================================================\n  Timestamps\n  ================================================================================*/\n  error InputTimestampBeforeCheckpoint(uint256 inputTimestamp, uint256 checkpointedAt);\n  error InputTimestampInThePast(uint256 inputTimestamp);\n}\n"
    },
    "contracts/interfaces/ICapitalLedger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nenum CapitalAssetType {\n  INVALID,\n  ERC721\n}\n\ninterface ICapitalLedger {\n  /**\n   * @notice Emitted when a new capital erc721 deposit has been made\n   * @param owner address owning the deposit\n   * @param assetAddress address of the deposited ERC721\n   * @param positionId id for the deposit\n   * @param assetTokenId id of the token from the ERC721 `assetAddress`\n   * @param usdcEquivalent usdc equivalent value at the time of deposit\n   */\n  event CapitalERC721Deposit(\n    address indexed owner,\n    address indexed assetAddress,\n    uint256 positionId,\n    uint256 assetTokenId,\n    uint256 usdcEquivalent\n  );\n\n  /**\n   * @notice Emitted when a new ERC721 capital withdrawal has been made\n   * @param owner address owning the deposit\n   * @param positionId id for the capital position\n   * @param assetAddress address of the underlying ERC721\n   * @param depositTimestamp block.timestamp of the original deposit\n   */\n  event CapitalERC721Withdrawal(\n    address indexed owner,\n    uint256 positionId,\n    address assetAddress,\n    uint256 depositTimestamp\n  );\n\n  /**\n   * @notice Emitted when an ERC721 capital asset has been harvested\n   * @param positionId id for the capital position\n   * @param assetAddress address of the underlying ERC721\n   */\n  event CapitalERC721Harvest(uint256 indexed positionId, address assetAddress);\n\n  /**\n   * @notice Emitted when an ERC721 capital asset has been \"kicked\", which may cause the underlying\n   *  usdc equivalent value to change.\n   * @param positionId id for the capital position\n   * @param assetAddress address of the underlying ERC721\n   * @param usdcEquivalent new usdc equivalent value of the position\n   */\n  event CapitalPositionAdjustment(\n    uint256 indexed positionId,\n    address assetAddress,\n    uint256 usdcEquivalent\n  );\n\n  /// Thrown when called with an invalid asset type for the function. Valid\n  /// types are defined under CapitalAssetType\n  error InvalidAssetType(CapitalAssetType);\n\n  /**\n   * @notice Account for a deposit of `id` for the ERC721 asset at `assetAddress`.\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\n   * @param owner address that owns the position\n   * @param assetAddress address of the ERC20 address\n   * @param assetTokenId id of the ERC721 asset to add\n   * @return id of the newly created position\n   */\n  function depositERC721(\n    address owner,\n    address assetAddress,\n    uint256 assetTokenId\n  ) external returns (uint256);\n\n  /**\n   * @notice Get the id of the ERC721 asset held by position `id`. Pair this with\n   *  `assetAddressOf` to get the address & id of the nft.\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\n   * @param positionId id of the position\n   * @return id of the underlying ERC721 asset\n   */\n  function erc721IdOf(uint256 positionId) external view returns (uint256);\n\n  /**\n   * @notice Completely withdraw a position\n   * @param positionId id of the position\n   */\n  function withdraw(uint256 positionId) external;\n\n  /**\n   * @notice Harvests the associated rewards, interest, and other accrued assets\n   *  associated with the asset token. For example, if given a PoolToken asset,\n   *  this will collect the GFI rewards (if available), redeemable interest, and\n   *  redeemable principal, and send that to the `owner`.\n   * @param positionId id of the position\n   */\n  function harvest(uint256 positionId) external;\n\n  /**\n   * @notice Get the asset address of the position. Example: For an ERC721 position, this\n   *  returns the address of that ERC721 contract.\n   * @param positionId id of the position\n   * @return asset address of the position\n   */\n  function assetAddressOf(uint256 positionId) external view returns (address);\n\n  /**\n   * @notice Get the owner of a given position.\n   * @param positionId id of the position\n   * @return owner of the position\n   */\n  function ownerOf(uint256 positionId) external view returns (address);\n\n  /**\n   * @notice Total number of positions in the ledger\n   * @return number of positions in the ledger\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Get the number of capital positions held by an address\n   * @param addr address\n   * @return positions held by address\n   */\n  function balanceOf(address addr) external view returns (uint256);\n\n  /**\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\n   * @param owner owner of the positions\n   * @param index index of the owner's balance to get the position ID of\n   * @return position id\n   *\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n  /**\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\n   * @param index index to get the position ID at\n   * @return position id\n   *\n   * @dev use with {totalSupply} to enumerate all positions\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  /**\n   * @notice Get the USDC value of `owner`s positions, reporting what is currently\n   *  eligible and the total amount.\n   * @param owner address owning the positions\n   * @return eligibleAmount USDC value of positions eligible for rewards\n   * @return totalAmount total USDC value of positions\n   *\n   * @dev this is used by Membership to determine how much is eligible in\n   *  the current epoch vs the next epoch.\n   */\n  function totalsOf(\n    address owner\n  ) external view returns (uint256 eligibleAmount, uint256 totalAmount);\n}\n"
    },
    "contracts/interfaces/ICreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ILoan} from \"./ILoan.sol\";\n\nimport {ICreditLine} from \"./ICreditLine.sol\";\nimport {ISchedule} from \"./ISchedule.sol\";\n\ninterface ICreditLine {\n  function balance() external view returns (uint256);\n\n  function interestOwed() external view returns (uint256);\n\n  function principalOwed() external view returns (uint256);\n\n  function termEndTime() external view returns (uint256);\n\n  function nextDueTime() external view returns (uint256);\n\n  function interestAccruedAsOf() external view returns (uint256);\n\n  function lastFullPaymentTime() external view returns (uint256);\n\n  function borrower() external view returns (address);\n\n  function currentLimit() external view returns (uint256);\n\n  function limit() external view returns (uint256);\n\n  function maxLimit() external view returns (uint256);\n\n  function interestApr() external view returns (uint256);\n\n  function lateFeeApr() external view returns (uint256);\n\n  function isLate() external view returns (bool);\n\n  function withinPrincipalGracePeriod() external view returns (bool);\n\n  /// @notice Cumulative interest accrued up to now\n  function totalInterestAccrued() external view returns (uint256);\n\n  /// @notice Cumulative interest accrued up to `timestamp`\n  function totalInterestAccruedAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Cumulative interest paid back up to now\n  function totalInterestPaid() external view returns (uint256);\n\n  /// @notice Cumulative interest owed up to now\n  function totalInterestOwed() external view returns (uint256);\n\n  /// @notice Cumulative interest owed up to `timestamp`\n  function totalInterestOwedAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Interest that would be owed at `timestamp`\n  function interestOwedAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Interest accrued in the current payment period up to now. Converted to\n  ///   owed interest once we cross into the next payment period. Is 0 if the\n  ///   current time is after loan maturity (all interest accrued immediately becomes\n  ///   interest owed).\n  function interestAccrued() external view returns (uint256);\n\n  /// @notice Interest accrued in the current payment period for `timestamp`. Coverted to\n  ///   owed interest once we cross into the payment period after `timestamp`. Is 0\n  ///   if `timestamp` is after loan maturity (all interest accrued immediately becomes\n  ///   interest owed).\n  function interestAccruedAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Principal owed up to `timestamp`\n  function principalOwedAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Returns the total amount of principal thats been paid\n  function totalPrincipalPaid() external view returns (uint256);\n\n  /// @notice Cumulative principal owed at timestamp\n  function totalPrincipalOwedAt(uint256 timestamp) external view returns (uint256);\n\n  /// @notice Cumulative principal owed at current timestamp\n  function totalPrincipalOwed() external view returns (uint256);\n\n  function setLimit(uint256 newAmount) external;\n\n  function setMaxLimit(uint256 newAmount) external;\n\n  /// @notice Time of first drawdown\n  function termStartTime() external view returns (uint256);\n\n  /// @notice Process a bulk payment, allocating the payment amount based on the payment waterfall\n  function pay(uint paymentAmount) external returns (ILoan.PaymentAllocation memory);\n\n  /**\n   * Process a payment according to the waterfall described in `Accountant.allocatePayment`\n   * @param principalPayment principal payment amount\n   * @param interestPayment interest payment amount\n   * @return payment allocation\n   */\n  function pay(\n    uint256 principalPayment,\n    uint256 interestPayment\n  ) external returns (ILoan.PaymentAllocation memory);\n\n  /// @notice Drawdown on the line\n  /// @param amount amount to drawdown. Cannot exceed the line's limit\n  function drawdown(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/ICurveLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ICurveLP {\n  function coins(uint256) external view returns (address);\n\n  function token() external view returns (address);\n\n  function calc_token_amount(uint256[2] calldata amounts) external view returns (uint256);\n\n  function lp_price() external view returns (uint256);\n\n  function add_liquidity(\n    uint256[2] calldata amounts,\n    uint256 min_mint_amount,\n    bool use_eth,\n    address receiver\n  ) external returns (uint256);\n\n  function remove_liquidity(\n    uint256 _amount,\n    uint256[2] calldata min_amounts\n  ) external returns (uint256);\n\n  function remove_liquidity_one_coin(\n    uint256 token_amount,\n    uint256 i,\n    uint256 min_amount\n  ) external returns (uint256);\n\n  function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\n\n  function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external returns (uint256);\n\n  function balances(uint256 arg0) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n// Copied from: https://eips.ethereum.org/EIPS/eip-173\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\ninterface IERC173 {\n  /// @dev This emits when ownership of a contract changes.\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /// @notice Get the address of the owner\n  /// @return The address of the owner.\n  function owner() external view returns (address);\n\n  /// @notice Set the address of the new owner of the contract\n  /// @dev Set _newOwner to address(0) to renounce any ownership.\n  /// @param _newOwner The address of the new owner of the contract\n  function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// This file copied from OZ, but with the version pragma updated to use >=.\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IERC20Splitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IERC20Splitter {\n  function lastDistributionAt() external view returns (uint256);\n\n  function distribute() external;\n\n  function replacePayees(address[] calldata _payees, uint256[] calldata _shares) external;\n\n  function pendingDistributionFor(address payee) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20UpgradeableWithDec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\n/*\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\n*/\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20UpgradeableWithDec is IERC20Upgradeable {\n  /**\n   * @dev Returns the number of decimals used for the token\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IERC20WithName.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 standard along with the \"name()\" function.\n */\ninterface IERC20WithName is IERC20 {\n  function name() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IERC2981 {\n  /// @notice Called with the sale price to determine how much royalty\n  //          is owed and to whom.\n  /// @param _tokenId - the NFT asset queried for royalty information\n  /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n  /// @return receiver - address of who should be sent the royalty payment\n  /// @return royaltyAmount - the royalty payment amount for _salePrice\n  function royaltyInfo(\n    uint256 _tokenId,\n    uint256 _salePrice\n  ) external view returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "contracts/interfaces/IEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @notice Common events that can be emmitted by multiple contracts\ninterface IEvents {\n  /// @notice Emitted when a safety check fails\n  event SafetyCheckTriggered();\n}\n"
    },
    "contracts/interfaces/IGFILedger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IGFILedger {\n  struct Position {\n    // Owner of the position\n    address owner;\n    // Index of the position in the ownership array\n    uint256 ownedIndex;\n    // Amount of GFI held in the position\n    uint256 amount;\n    // When the position was deposited\n    uint256 depositTimestamp;\n  }\n\n  /**\n   * @notice Emitted when a new GFI deposit has been made\n   * @param owner address owning the deposit\n   * @param positionId id for the deposit\n   * @param amount how much GFI was deposited\n   */\n  event GFIDeposit(address indexed owner, uint256 indexed positionId, uint256 amount);\n\n  /**\n   * @notice Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed\n   * @param owner address owning the withdrawn position\n   * @param positionId id for the position\n   * @param remainingAmount how much GFI is remaining in the position\n   * @param depositTimestamp block.timestamp of the original deposit\n   */\n  event GFIWithdrawal(\n    address indexed owner,\n    uint256 indexed positionId,\n    uint256 withdrawnAmount,\n    uint256 remainingAmount,\n    uint256 depositTimestamp\n  );\n\n  /**\n   * @notice Account for a new deposit by the owner.\n   * @param owner address to account for the deposit\n   * @param amount how much was deposited\n   * @return how much was deposited\n   */\n  function deposit(address owner, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Account for a new withdraw by the owner.\n   * @param positionId id of the position\n   * @return how much was withdrawn\n   */\n  function withdraw(uint256 positionId) external returns (uint256);\n\n  /**\n   * @notice Account for a new withdraw by the owner.\n   * @param positionId id of the position\n   * @param amount how much to withdraw\n   * @return how much was withdrawn\n   */\n  function withdraw(uint256 positionId, uint256 amount) external returns (uint256);\n\n  /**\n   * @notice Get the number of GFI positions held by an address\n   * @param addr address\n   * @return positions held by address\n   */\n  function balanceOf(address addr) external view returns (uint256);\n\n  /**\n   * @notice Get the owner of a given position.\n   * @param positionId id of the position\n   * @return owner of the position\n   */\n  function ownerOf(uint256 positionId) external view returns (address);\n\n  /**\n   * @notice Total number of positions in the ledger\n   * @return number of positions in the ledger\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\n   * @param owner owner of the positions\n   * @param index index of the owner's balance to get the position ID of\n   * @return position id\n   *\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n  /**\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\n   * @param index index to get the position ID at\n   * @return token id\n   *\n   * @dev use with {totalSupply} to enumerate all positions\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  /**\n   * @notice Get amount of GFI of `owner`s positions, reporting what is currently\n   *  eligible and the total amount.\n   * @return eligibleAmount GFI amount of positions eligible for rewards\n   * @return totalAmount total GFI amount of positions\n   *\n   * @dev this is used by Membership to determine how much is eligible in\n   *  the current epoch vs the next epoch.\n   */\n  function totalsOf(\n    address owner\n  ) external view returns (uint256 eligibleAmount, uint256 totalAmount);\n}\n"
    },
    "contracts/interfaces/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nabstract contract IGo {\n  uint256 public constant ID_TYPE_0 = 0;\n  uint256 public constant ID_TYPE_1 = 1;\n  uint256 public constant ID_TYPE_2 = 2;\n  uint256 public constant ID_TYPE_3 = 3;\n  uint256 public constant ID_TYPE_4 = 4;\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  /// @notice Returns the address of the UniqueIdentity contract.\n  function uniqueIdentity() external virtual returns (address);\n\n  function go(address account) public view virtual returns (bool);\n\n  function goOnlyIdTypes(\n    address account,\n    uint256[] calldata onlyIdTypes\n  ) public view virtual returns (bool);\n\n  /**\n   * @notice Returns whether the provided account is go-listed for use of the SeniorPool on the Goldfinch protocol.\n   * @param account The account whose go status to obtain\n   * @return true if `account` is go listed\n   */\n  function goSeniorPool(address account) public view virtual returns (bool);\n}\n"
    },
    "contracts/interfaces/IGoldfinchConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IGoldfinchConfig {\n  /**\n   * @dev Adds a user to go-list\n   * @param _member address to add to go-list\n   */\n  function addToGoList(address _member) external;\n\n  /**\n   * @dev removes a user from go-list\n   * @param _member address to remove from go-list\n   */\n  function removeFromGoList(address _member) external;\n\n  /**\n   * @dev adds many users to go-list at once\n   * @param _members addresses to ad to go-list\n   */\n  function bulkAddToGoList(address[] calldata _members) external;\n\n  /**\n   * @dev removes many users from go-list at once\n   * @param _members addresses to remove from go-list\n   */\n  function bulkRemoveFromGoList(address[] calldata _members) external;\n\n  function getNumber(uint256 index) external view returns (uint256);\n\n  /*\n    Using custom getters in case we want to change underlying implementation later,\n    or add checks or validations later on.\n  */\n  function getAddress(uint256 index) external view returns (address);\n\n  function setAddress(uint256 index, address newAddress) external;\n\n  function setNumber(uint256 index, uint256 newNumber) external;\n}\n"
    },
    "contracts/interfaces/IGoldfinchFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ISchedule} from \"./ISchedule.sol\";\nimport {ICallableLoan} from \"./ICallableLoan.sol\";\n\ninterface IGoldfinchFactory {\n  function createCreditLine() external returns (address);\n\n  function createBorrower(address owner) external returns (address);\n\n  function createPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (address);\n\n  function createMigratedPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (address);\n\n  function createCallableLoan(\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _numLockupPeriods,\n    ISchedule _schedule,\n    uint256 _lateFeeApr,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (ICallableLoan);\n}\n"
    },
    "contracts/interfaces/IImplementationRepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title User Controlled Upgrades (UCU) Proxy Repository\n/// A repository maintaing a collection of \"lineages\" of implementation contracts\n///\n/// Lineages are a sequence of implementations each lineage can be thought of as\n/// a \"major\" revision of implementations. Implementations between lineages are\n/// considered incompatible.\ninterface IImplementationRepository {\n  /// @notice returns data that will be delegatedCalled when the given implementation\n  ///           is upgraded to\n  function upgradeDataFor(address key) external returns (bytes memory);\n\n  /// @notice Returns the id of the lineage a given implementation belongs to\n  function lineageIdOf(address key) external returns (uint256);\n\n  /// @notice Returns the id of the most recently created lineage\n  function currentLineageId() external view returns (uint256);\n\n  // //////// External ////////////////////////////////////////////////////////////\n\n  /// @notice set data that will be delegate called when a proxy upgrades to the given `implementation`\n  /// @dev reverts when caller is not an admin\n  /// @dev reverts when the contract is paused\n  /// @dev reverts if the given implementation isn't registered\n  function setUpgradeDataFor(address implementation, bytes calldata data) external;\n\n  /// @notice Create a new lineage of implementations.\n  ///\n  /// This creates a new \"root\" of a new lineage\n  /// @dev reverts if `implementation` is not a contract\n  /// @param implementation implementation that will be the first implementation in the lineage\n  /// @return newly created lineage's id\n  function createLineage(address implementation) external returns (uint256);\n\n  /// @notice add a new implementation and set it as the current implementation\n  /// @dev reverts if the sender is not an owner\n  /// @dev reverts if the contract is paused\n  /// @dev reverts if `implementation` is not a contract\n  /// @param implementation implementation to append\n  function append(address implementation) external;\n\n  /// @notice Append an implementation to a specified lineage\n  /// @dev reverts if the contract is paused\n  /// @dev reverts if the sender is not an owner\n  /// @dev reverts if `implementation` is not a contract\n  /// @param implementation implementation to append\n  /// @param lineageId id of lineage to append to\n  function append(address implementation, uint256 lineageId) external;\n\n  /// @notice Remove an implementation from the chain and \"stitch\" together its neighbors\n  /// @dev If you have a chain of `A -> B -> C` and I call `remove(B, C)` it will result in `A -> C`\n  /// @dev reverts if `previos` is not the ancestor of `toRemove`\n  /// @dev we need to provide the previous implementation here to be able to successfully \"stitch\"\n  ///       the chain back together. Because this is an admin action, we can source what the previous\n  ///       version is from events.\n  /// @param toRemove Implementation to remove\n  /// @param previous Implementation that currently has `toRemove` as its successor\n  function remove(address toRemove, address previous) external;\n\n  // //////// External view ////////////////////////////////////////////////////////////\n\n  /// @notice Returns `true` if an implementation has a next implementation set\n  /// @param implementation implementation to check\n  /// @return The implementation following the given implementation\n  function hasNext(address implementation) external view returns (bool);\n\n  /// @notice Returns `true` if an implementation has already been added\n  /// @param implementation Implementation to check existence of\n  /// @return `true` if the implementation has already been added\n  function has(address implementation) external view returns (bool);\n\n  /// @notice Get the next implementation for a given implementation or\n  ///           `address(0)` if it doesn't exist\n  /// @dev reverts when contract is paused\n  /// @param implementation implementation to get the upgraded implementation for\n  /// @return Next Implementation\n  function nextImplementationOf(address implementation) external view returns (address);\n\n  /// @notice Returns `true` if a given lineageId exists\n  function lineageExists(uint256 lineageId) external view returns (bool);\n\n  /// @notice Return the current implementation of a lineage with the given `lineageId`\n  function currentImplementation(uint256 lineageId) external view returns (address);\n\n  /// @notice return current implementaton of the current lineage\n  function currentImplementation() external view returns (address);\n\n  // //////// Events //////////////////////////////////////////////////////////////\n  event Added(\n    uint256 indexed lineageId,\n    address indexed newImplementation,\n    address indexed oldImplementation\n  );\n  event Removed(uint256 indexed lineageId, address indexed implementation);\n  event UpgradeDataSet(address indexed implementation, bytes data);\n}\n"
    },
    "contracts/interfaces/ILegacyCreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @notice Kept around so the frontend still has the ABI for old credit lines\n */\ninterface ILegacyCreditLine {\n  function borrower() external view returns (address);\n\n  function limit() external view returns (uint256);\n\n  function maxLimit() external view returns (uint256);\n\n  function interestApr() external view returns (uint256);\n\n  function paymentPeriodInDays() external view returns (uint256);\n\n  function principalGracePeriodInDays() external view returns (uint256);\n\n  function termInDays() external view returns (uint256);\n\n  function lateFeeApr() external view returns (uint256);\n\n  function isLate() external view returns (bool);\n\n  function withinPrincipalGracePeriod() external view returns (bool);\n\n  // Accounting variables\n  function balance() external view returns (uint256);\n\n  function interestOwed() external view returns (uint256);\n\n  function principalOwed() external view returns (uint256);\n\n  function termEndTime() external view returns (uint256);\n\n  function nextDueTime() external view returns (uint256);\n\n  function interestAccruedAsOf() external view returns (uint256);\n\n  function lastFullPaymentTime() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILegacyTranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ILegacyCreditLine} from \"./ILegacyCreditLine.sol\";\nimport {ISchedule} from \"./ISchedule.sol\";\n\n/**\n * @notice Kept around so the frontend still has the ABI for the old TranchedPool\n */\nabstract contract ILegacyTranchedPool {\n  ILegacyCreditLine public creditLine;\n  uint256 public createdAt;\n  enum Tranches {\n    Reserved,\n    Senior,\n    Junior\n  }\n\n  struct TrancheInfo {\n    uint256 id;\n    uint256 principalDeposited;\n    uint256 principalSharePrice;\n    uint256 interestSharePrice;\n    uint256 lockedUntil;\n  }\n\n  struct PoolSlice {\n    TrancheInfo seniorTranche;\n    TrancheInfo juniorTranche;\n    uint256 totalInterestAccrued;\n    uint256 principalDeployed;\n  }\n\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    ISchedule _schedule,\n    uint256 _lateFeeApr,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) public virtual;\n\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\n\n  function pay(uint256 amount) external virtual;\n\n  function poolSlices(uint256 index) external view virtual returns (PoolSlice memory);\n\n  function lockJuniorCapital() external virtual;\n\n  function lockPool() external virtual;\n\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\n\n  function totalJuniorDeposits() external view virtual returns (uint256);\n\n  function drawdown(uint256 amount) external virtual;\n\n  function setFundableAt(uint256 timestamp) external virtual;\n\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\n\n  function assess() external virtual;\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 tokenId);\n\n  function availableToWithdraw(\n    uint256 tokenId\n  ) external view virtual returns (uint256 interestRedeemable, uint256 principalRedeemable);\n\n  function withdraw(\n    uint256 tokenId,\n    uint256 amount\n  ) external virtual returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMax(\n    uint256 tokenId\n  ) external virtual returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMultiple(\n    uint256[] calldata tokenIds,\n    uint256[] calldata amounts\n  ) external virtual;\n\n  function numSlices() external view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\nimport {ISchedule} from \"./ISchedule.sol\";\nimport {ICreditLine} from \"./ICreditLine.sol\";\n\nenum LoanType {\n  TranchedPool,\n  CallableLoan\n}\n\ninterface ILoan {\n  /// @notice getLoanType was added to support the new callable loan type.\n  ///         It is not supported in older versions of ILoan (e.g. legacy TranchedPools)\n  function getLoanType() external view returns (LoanType);\n\n  /// @notice Pool's credit line, responsible for managing the loan's accounting variables\n  function creditLine() external view returns (ICreditLine);\n\n  /// @notice Time when the pool was initialized. Zero if uninitialized\n  function createdAt() external view returns (uint256);\n\n  /// @notice Pay down interest + principal. Excess payments are refunded to the caller\n  /// @param amount USDC amount to pay\n  /// @return PaymentAllocation info on how the payment was allocated\n  /// @dev {this} must be approved by msg.sender to transfer {amount} of USDC\n  function pay(uint256 amount) external returns (PaymentAllocation memory);\n\n  /// @notice Compute interest and principal owed on the current balance at a future timestamp\n  /// @param timestamp time to calculate up to\n  /// @return interestOwed amount of obligated interest owed at `timestamp`\n  /// @return interestAccrued amount of accrued interest (not yet owed) that can be paid at `timestamp`\n  /// @return principalOwed amount of principal owed at `timestamp`\n  function getAmountsOwed(\n    uint256 timestamp\n  ) external view returns (uint256 interestOwed, uint256 interestAccrued, uint256 principalOwed);\n\n  function getAllowedUIDTypes() external view returns (uint256[] memory);\n\n  /// @notice Drawdown the loan. The credit line's balance should increase by the amount drawn down.\n  ///   Junior capital must be locked before this function can be called. If senior capital isn't locked\n  ///   then this function will lock it for you (convenience to avoid calling lockPool() separately).\n  ///   This function should revert if the amount requested exceeds the the current slice's currentLimit\n  ///   This function should revert if the caller is not the borrower.\n  /// @param amount USDC to drawdown. This amount is transferred to the caller\n  function drawdown(uint256 amount) external;\n\n  /// @notice Update `fundableAt` to a new timestamp. Only the borrower can call this.\n  function setFundableAt(uint256 newFundableAt) external;\n\n  /// @notice Supply capital to this pool. Caller can't deposit to the junior tranche if the junior pool is locked.\n  ///   Caller can't deposit to a senior tranche if the pool is locked. Caller can't deposit if they are missing the\n  ///   required UID NFT.\n  /// @param tranche id of tranche to supply capital to. Id must correspond to a tranche in the current slice.\n  /// @param amount amount of capital to supply\n  /// @return tokenId NFT representing your position in this pool\n  function deposit(uint256 tranche, uint256 amount) external returns (uint256 tokenId);\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 tokenId);\n\n  /// @notice Query the max amount available to withdraw for tokenId's position\n  /// @param tokenId position to query max amount withdrawable for\n  /// @return interestRedeemable total interest withdrawable on the position\n  /// @return principalRedeemable total principal redeemable on the position\n  function availableToWithdraw(\n    uint256 tokenId\n  ) external view returns (uint256 interestRedeemable, uint256 principalRedeemable);\n\n  /// @notice Withdraw an already deposited amount if the funds are available. Caller must be the owner or\n  ///   approved by the owner on tokenId. Amount withdrawn is sent to the caller.\n  /// @param tokenId the NFT representing the position\n  /// @param amount amount to withdraw (must be <= interest+principal available to withdraw)\n  /// @return interestWithdrawn interest withdrawn\n  /// @return principalWithdrawn principal withdrawn\n  function withdraw(\n    uint256 tokenId,\n    uint256 amount\n  ) external returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  /// @notice Similar to withdraw but withdraw the max interest and principal available for `tokenId`\n  function withdrawMax(\n    uint256 tokenId\n  ) external returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  /// @notice Withdraw from multiple tokens\n  /// @param tokenIds NFT positions to withdraw. Caller must be an owner or approved on all tokens in the array\n  /// @param amounts amounts to withdraw from positions such that amounts[i] is withdrawn from position tokenIds[i]\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external;\n\n  /// @notice Result of applying a payment to a v2 pool\n  /// @param owedInterestPayment payment portion of interest owed\n  /// @param accruedInterestPayment payment portion of accrued (but not yet owed) interest\n  /// @param principalPayment payment portion on principal owed\n  /// @param additionalBalancePayment payment portion on any balance that is currently owed\n  /// @param paymentRemaining payment amount leftover\n  struct PaymentAllocation {\n    uint256 owedInterestPayment;\n    uint256 accruedInterestPayment;\n    uint256 principalPayment;\n    uint256 additionalBalancePayment;\n    uint256 paymentRemaining;\n  }\n  /// @notice Event emitted on payment\n  /// @param payer address that made the payment\n  /// @param pool pool to which the payment was made\n  /// @param interest amount of payment allocated to interest (obligated + additional)\n  /// @param principal amount of payment allocated to principal owed and remaining balance\n  /// @param remaining any excess payment amount that wasn't allocated to a debt owed\n  /// @param reserve of payment that went to the protocol reserve\n  event PaymentApplied(\n    address indexed payer,\n    address indexed pool,\n    uint256 interest,\n    uint256 principal,\n    uint256 remaining,\n    uint256 reserve\n  );\n  event DepositMade(\n    address indexed owner,\n    uint256 indexed tranche,\n    uint256 indexed tokenId,\n    uint256 amount\n  );\n\n  /// @notice While owner is the label of the first argument, it is actually the sender of the transaction.\n  event WithdrawalMade(\n    address indexed owner,\n    uint256 indexed tranche,\n    uint256 indexed tokenId,\n    uint256 interestWithdrawn,\n    uint256 principalWithdrawn\n  );\n  event ReserveFundsCollected(address indexed from, uint256 amount);\n  event DrawdownMade(address indexed borrower, uint256 amount);\n  event DrawdownsPaused(address indexed pool);\n  event DrawdownsUnpaused(address indexed pool);\n  event EmergencyShutdown(address indexed pool);\n}\n"
    },
    "contracts/interfaces/IMembershipCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IMembershipCollector {\n  /// @notice Have the collector distribute `amount` of Fidu to `addr`\n  /// @param addr address to distribute to\n  /// @param amount amount to distribute\n  function distributeFiduTo(address addr, uint256 amount) external;\n\n  /// @notice Get the last epoch finalized by the collector. This means the\n  ///  collector will no longer add rewards to the epoch.\n  /// @return the last finalized epoch\n  function lastFinalizedEpoch() external view returns (uint256);\n\n  /// @notice Get the rewards associated with `epoch`. This amount may change\n  ///  until `epoch` has been finalized (is less than or equal to getLastFinalizedEpoch)\n  /// @return rewards associated with `epoch`\n  function rewardsForEpoch(uint256 epoch) external view returns (uint256);\n\n  /// @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\n  ///  this will be the fixed, accurate reward for the epoch. For the current and other\n  ///  non-finalized epochs, this will be the value as if the epoch were finalized in that\n  ///  moment.\n  /// @param epoch epoch to estimate the rewards of\n  /// @return rewards associated with `epoch`\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\n\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\n  function finalizeEpochs() external;\n}\n"
    },
    "contracts/interfaces/IMembershipDirector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IMembershipDirector {\n  /**\n   * @notice Adjust an `owner`s membership score and position due to the change\n   *  in their GFI and Capital holdings\n   * @param owner address who's holdings changed\n   * @return id of membership position\n   */\n  function consumeHoldingsAdjustment(address owner) external returns (uint256);\n\n  /**\n   * @notice Collect all membership yield enhancements for the owner.\n   * @param owner address to claim rewards for\n   * @return amount of yield enhancements collected\n   */\n  function collectRewards(address owner) external returns (uint256);\n\n  /**\n   * @notice Check how many rewards are claimable for the owner. The return\n   *  value here is how much would be retrieved by calling `collectRewards`.\n   * @param owner address to calculate claimable rewards for\n   * @return the amount of rewards that could be claimed by the owner\n   */\n  function claimableRewards(address owner) external view returns (uint256);\n\n  /**\n   * @notice Calculate the membership score\n   * @param gfi Amount of gfi\n   * @param capital Amount of capital in USDC\n   * @return membership score\n   */\n  function calculateMembershipScore(uint256 gfi, uint256 capital) external view returns (uint256);\n\n  /**\n   * @notice Get the current score of `owner`\n   * @param owner address to check the score of\n   * @return eligibleScore score that is currently eligible for rewards\n   * @return totalScore score that will be elgible for rewards next epoch\n   */\n  function currentScore(\n    address owner\n  ) external view returns (uint256 eligibleScore, uint256 totalScore);\n\n  /**\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\n   * @return eligibleTotal sum of all member scores that are currently eligible\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\n   */\n  function totalMemberScores()\n    external\n    view\n    returns (uint256 eligibleTotal, uint256 nextEpochTotal);\n\n  /**\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\n   * @param memberAddress the member's address\n   * @param gfi the change in gfi holdings, denominated in GFI\n   * @param capital the change in gfi holdings, denominated in USDC\n   * @return score resulting score for the member given the GFI and capital changes\n   */\n  function estimateMemberScore(\n    address memberAddress,\n    int256 gfi,\n    int256 capital\n  ) external view returns (uint256 score);\n\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\n  function finalizeEpochs() external;\n}\n"
    },
    "contracts/interfaces/IMembershipLedger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\ninterface IMembershipLedger {\n  /**\n   * @notice Set `addr`s allocated rewards back to 0\n   * @param addr address to reset rewards on\n   */\n  function resetRewards(address addr) external;\n\n  /**\n   * @notice Allocate `amount` rewards for `addr` but do not send them\n   * @param addr address to distribute rewards to\n   * @param amount amount of rewards to allocate for `addr`\n   * @return rewards total allocated to `addr`\n   */\n  function allocateRewardsTo(address addr, uint256 amount) external returns (uint256 rewards);\n\n  /**\n   * @notice Get the rewards allocated to a certain `addr`\n   * @param addr the address to check pending rewards for\n   * @return rewards pending rewards for `addr`\n   */\n  function getPendingRewardsFor(address addr) external view returns (uint256 rewards);\n\n  /**\n   * @notice Get the alpha parameter for the cobb douglas function. Will always be in (0,1).\n   * @return numerator numerator for the alpha param\n   * @return denominator denominator for the alpha param\n   */\n  function alpha() external view returns (uint128 numerator, uint128 denominator);\n}\n"
    },
    "contracts/interfaces/IMembershipOrchestrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport {Context} from \"../cake/Context.sol\";\n\nstruct CapitalDeposit {\n  /// Address of the asset being deposited\n  /// @dev must be supported in CapitalAssets.sol\n  address assetAddress;\n  /// Id of the nft\n  uint256 id;\n}\n\nstruct Deposit {\n  /// Amount of gfi to deposit\n  uint256 gfi;\n  /// List of capital deposits\n  CapitalDeposit[] capitalDeposits;\n}\n\nstruct DepositResult {\n  uint256 membershipId;\n  uint256 gfiPositionId;\n  uint256[] capitalPositionIds;\n}\n\nstruct ERC20Withdrawal {\n  uint256 id;\n  uint256 amount;\n}\n\nstruct Withdrawal {\n  /// List of gfi token ids to withdraw\n  ERC20Withdrawal[] gfiPositions;\n  /// List of capital token ids to withdraw\n  uint256[] capitalPositions;\n}\n\n/**\n * @title MembershipOrchestrator\n * @notice Externally facing gateway to all Goldfinch membership functionality.\n * @author Goldfinch\n */\ninterface IMembershipOrchestrator {\n  /**\n   * @notice Deposit multiple assets defined in `multiDeposit`. Assets can include GFI, Staked Fidu,\n   *  and others.\n   * @param deposit struct describing all the assets to deposit\n   * @return ids all of the ids of the created depoits, in the same order as deposit. If GFI is\n   *  present, it will be the first id.\n   */\n  function deposit(Deposit calldata deposit) external returns (DepositResult memory);\n\n  /**\n   * @notice Withdraw multiple assets defined in `multiWithdraw`. Assets can be GFI or capital\n   *  positions ids. Caller must have been permitted to act upon all of the positions.\n   * @param withdrawal all of the GFI and Capital ids to withdraw\n   */\n  function withdraw(Withdrawal calldata withdrawal) external;\n\n  /**\n   * @notice Collect all membership rewards for the caller.\n   * @return how many rewards were collected and sent to caller\n   */\n  function collectRewards() external returns (uint256);\n\n  /**\n   * @notice Harvest the rewards, interest, redeemable principal, or other assets\n   *  associated with the underlying capital asset. For example, if given a PoolToken,\n   *  this will collect the GFI rewards (if available), redeemable interest, and\n   *  redeemable principal, and send that to the owner of the capital position.\n   * @param capitalPositionIds id of the capital position to harvest the underlying asset of\n   */\n  function harvest(uint256[] calldata capitalPositionIds) external;\n\n  /**\n   * @notice Check how many rewards are claimable at this moment in time for caller.\n   * @param addr the address to check claimable rewards for\n   * @return how many rewards could be claimed by a call to `collectRewards`\n   */\n  function claimableRewards(address addr) external view returns (uint256);\n\n  /**\n   * @notice Check the voting power of a given address\n   * @param addr the address to check the voting power of\n   * @return the voting power\n   */\n  function votingPower(address addr) external view returns (uint256);\n\n  /**\n   * @notice Get all GFI in Membership held by `addr`. This returns the current eligible amount and the\n   *  total amount of GFI.\n   * @param addr the owner\n   * @return eligibleAmount how much GFI is currently eligible for rewards\n   * @return totalAmount how much GFI is currently eligible for rewards\n   */\n  function totalGFIHeldBy(\n    address addr\n  ) external view returns (uint256 eligibleAmount, uint256 totalAmount);\n\n  /**\n   * @notice Get all capital, denominated in USDC, in Membership held by `addr`. This returns the current\n   *  eligible amount and the total USDC value of capital.\n   * @param addr the owner\n   * @return eligibleAmount how much USDC of capital is currently eligible for rewards\n   * @return totalAmount how much  USDC of capital is currently eligible for rewards\n   */\n  function totalCapitalHeldBy(\n    address addr\n  ) external view returns (uint256 eligibleAmount, uint256 totalAmount);\n\n  /**\n   * @notice Get the member score of `addr`\n   * @param addr the owner\n   * @return eligibleScore the currently eligible score\n   * @return totalScore the total score that will be eligible next epoch\n   *\n   * @dev if eligibleScore == totalScore then there are no changes between now and the next epoch\n   */\n  function memberScoreOf(\n    address addr\n  ) external view returns (uint256 eligibleScore, uint256 totalScore);\n\n  /**\n   * @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\n   *  this will be the fixed, accurate reward for the epoch. For the current and other\n   *  non-finalized epochs, this will be the value as if the epoch were finalized in that\n   *  moment.\n   * @param epoch epoch to estimate the rewards of\n   * @return rewards associated with `epoch`\n   */\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\n\n  /**\n   * @notice Calculate what the Membership Score would be if a `gfi` amount of GFI and `capital` amount\n   *  of Capital denominated in USDC were deposited.\n   * @param gfi amount of GFI to estimate with\n   * @param capital amount of capital to estimate with, denominated in USDC\n   * @return score the resulting score\n   */\n  function calculateMemberScore(uint256 gfi, uint256 capital) external view returns (uint256 score);\n\n  /**\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\n   * @return eligibleTotal sum of all member scores that are currently eligible\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\n   */\n  function totalMemberScores()\n    external\n    view\n    returns (uint256 eligibleTotal, uint256 nextEpochTotal);\n\n  /**\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\n   * @param memberAddress the member's address\n   * @param gfi the change in gfi holdings, denominated in GFI\n   * @param capital the change in gfi holdings, denominated in USDC\n   * @return score resulting score for the member given the GFI and capital changes\n   */\n  function estimateMemberScore(\n    address memberAddress,\n    int256 gfi,\n    int256 capital\n  ) external view returns (uint256 score);\n\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\n  function finalizeEpochs() external;\n}\n"
    },
    "contracts/interfaces/IMembershipVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\";\n\nstruct Position {\n  // address owning the position\n  address owner;\n  // how much of the position is eligible as of checkpointEpoch\n  uint256 eligibleAmount;\n  // how much of the postion is eligible the epoch after checkpointEpoch\n  uint256 nextEpochAmount;\n  // when the position was first created\n  uint256 createdTimestamp;\n  // epoch of the last checkpoint\n  uint256 checkpointEpoch;\n}\n\n/**\n * @title IMembershipVault\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\n *  are not accounted for until the next epoch for MEV protection.\n * @author Goldfinch\n */\ninterface IMembershipVault is IERC721Upgradeable {\n  /**\n   * @notice Emitted when an owner has adjusted their holdings in a vault\n   * @param owner the owner increasing their holdings\n   * @param eligibleAmount the new eligible amount\n   * @param nextEpochAmount the new next epoch amount\n   */\n  event AdjustedHoldings(address indexed owner, uint256 eligibleAmount, uint256 nextEpochAmount);\n\n  /**\n   * @notice Emitted when the total within the vault has changed\n   * @param eligibleAmount new current amount\n   * @param nextEpochAmount new next epoch amount\n   */\n  event VaultTotalUpdate(uint256 eligibleAmount, uint256 nextEpochAmount);\n\n  /**\n   * @notice Get the current value of `owner`. This changes depending on the current\n   *  block.timestamp as increased holdings are not accounted for until the subsequent epoch.\n   * @param owner address owning the positions\n   * @return sum of all positions held by an address\n   */\n  function currentValueOwnedBy(address owner) external view returns (uint256);\n\n  /**\n   * @notice Get the total value in the vault as of block.timestamp\n   * @return total value in the vault as of block.timestamp\n   */\n  function currentTotal() external view returns (uint256);\n\n  /**\n   * @notice Get the total value in the vault as of epoch\n   * @return total value in the vault as of epoch\n   */\n  function totalAtEpoch(uint256 epoch) external view returns (uint256);\n\n  /**\n   * @notice Get the position owned by `owner`\n   * @return position owned by `owner`\n   */\n  function positionOwnedBy(address owner) external view returns (Position memory);\n\n  /**\n   * @notice Record an adjustment in holdings. Eligible assets will update this epoch and\n   *  total assets will become eligible the subsequent epoch.\n   * @param owner the owner to checkpoint\n   * @param eligibleAmount amount of points to apply to the current epoch\n   * @param nextEpochAmount amount of points to apply to the next epoch\n   * @return id of the position\n   */\n  function adjustHoldings(\n    address owner,\n    uint256 eligibleAmount,\n    uint256 nextEpochAmount\n  ) external returns (uint256);\n\n  /**\n   * @notice Checkpoint a specific owner & the vault total\n   * @param owner the owner to checkpoint\n   *\n   * @dev to collect rewards, this must be called before `increaseHoldings` or\n   *  `decreaseHoldings`. Those functions must call checkpoint internally\n   *  so the historical data will be lost otherwise.\n   */\n  function checkpoint(address owner) external;\n}\n"
    },
    "contracts/interfaces/IMerkleDirectDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/interfaces/IMerkleDistributor.sol.\npragma solidity >=0.6.12;\n\n/// @notice Enables the transfer of GFI rewards (referred to as a \"grant\"), if the grant details exist in this\n/// contract's Merkle root.\ninterface IMerkleDirectDistributor {\n  /// @notice Returns the address of the GFI contract that is the token distributed as rewards by\n  ///   this contract.\n  function gfi() external view returns (address);\n\n  /// @notice Returns the merkle root of the merkle tree containing grant details available to accept.\n  function merkleRoot() external view returns (bytes32);\n\n  /// @notice Returns true if the index has been marked accepted.\n  function isGrantAccepted(uint256 index) external view returns (bool);\n\n  /// @notice Causes the sender to accept the grant consisting of the given details. Reverts if\n  /// the inputs (which includes who the sender is) are invalid.\n  function acceptGrant(uint256 index, uint256 amount, bytes32[] calldata merkleProof) external;\n\n  /// @notice This event is triggered whenever a call to #acceptGrant succeeds.\n  event GrantAccepted(uint256 indexed index, address indexed account, uint256 amount);\n}\n"
    },
    "contracts/interfaces/IMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/interfaces/IMerkleDistributor.sol.\npragma solidity >=0.6.12;\n\n/// @notice Enables the granting of a CommunityRewards grant, if the grant details exist in this\n/// contract's Merkle root.\ninterface IMerkleDistributor {\n  /// @notice Returns the address of the CommunityRewards contract whose grants are distributed by this contract.\n  function communityRewards() external view returns (address);\n\n  /// @notice Returns the merkle root of the merkle tree containing grant details available to accept.\n  function merkleRoot() external view returns (bytes32);\n\n  /// @notice Returns true if the index has been marked accepted.\n  function isGrantAccepted(uint256 index) external view returns (bool);\n\n  /// @notice Causes the sender to accept the grant consisting of the given details. Reverts if\n  /// the inputs (which includes who the sender is) are invalid.\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    bytes32[] calldata merkleProof\n  ) external;\n\n  /// @notice This event is triggered whenever a call to #acceptGrant succeeds.\n  event GrantAccepted(\n    uint256 indexed tokenId,\n    uint256 indexed index,\n    address indexed account,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  );\n}\n"
    },
    "contracts/interfaces/IMonthlyScheduleRepo.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ISchedule} from \"./ISchedule.sol\";\nimport {IPeriodMapper} from \"./IPeriodMapper.sol\";\n\ninterface IMonthlyScheduleRepo {\n  function periodMapper() external view returns (IPeriodMapper);\n\n  function getSchedule(\n    uint256 periodsInTerm,\n    uint256 periodsPerPrincipalPeriod,\n    uint256 periodsPerInterestPeriod,\n    uint256 gracePrincipalPeriods\n  ) external view returns (ISchedule);\n\n  /// @notice Add a schedule with the provided params to the repo\n  /// @return schedule the schedule\n  function createSchedule(\n    uint256 periodsInTerm,\n    uint256 periodsPerPrincipalPeriod,\n    uint256 periodsPerInterestPeriod,\n    uint256 gracePrincipalPeriods\n  ) external returns (ISchedule);\n}\n"
    },
    "contracts/interfaces/IPeriodMapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\n/// @title IPeriodMapper\n/// @notice A mapping of timestamps to \"periods\"\ninterface IPeriodMapper {\n  /// @notice Returns the period that a timestamp resides in\n  function periodOf(uint256 timestamp) external pure returns (uint256 period);\n\n  /// @notice Returns the starting timestamp of a given period\n  function startOf(uint256 period) external pure returns (uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nabstract contract IPool {\n  uint256 public sharePrice;\n\n  function deposit(uint256 amount) external virtual;\n\n  function withdraw(uint256 usdcAmount) external virtual;\n\n  function withdrawInFidu(uint256 fiduAmount) external virtual;\n\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) public virtual;\n\n  function transferFrom(address from, address to, uint256 amount) public virtual returns (bool);\n\n  function drawdown(address to, uint256 amount) public virtual returns (bool);\n\n  function sweepToCompound() public virtual;\n\n  function sweepFromCompound() public virtual;\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta) external virtual;\n\n  function assets() public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPoolTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./openzeppelin/IERC721.sol\";\n\ninterface IPoolTokens is IERC721 {\n  struct TokenInfo {\n    address pool;\n    uint256 tranche;\n    uint256 principalAmount;\n    uint256 principalRedeemed;\n    uint256 interestRedeemed;\n  }\n\n  struct MintParams {\n    uint256 principalAmount;\n    uint256 tranche;\n  }\n\n  struct PoolInfo {\n    uint256 totalMinted;\n    uint256 totalPrincipalRedeemed;\n    bool created;\n  }\n\n  /**\n   * @notice Called by pool to create a debt position in a particular tranche and amount\n   * @param params Struct containing the tranche and the amount\n   * @param to The address that should own the position\n   * @return tokenId The token ID (auto-incrementing integer across all pools)\n   */\n  function mint(MintParams calldata params, address to) external returns (uint256);\n\n  /**\n   * @notice Redeem principal and interest on a pool token. Called by valid pools as part of their redemption\n   *  flow\n   * @param tokenId pool token id\n   * @param principalRedeemed principal to redeem. This cannot exceed the token's principal amount, and\n   *  the redemption cannot cause the pool's total principal redeemed to exceed the pool's total minted\n   *  principal\n   * @param interestRedeemed interest to redeem.\n   */\n  function redeem(uint256 tokenId, uint256 principalRedeemed, uint256 interestRedeemed) external;\n\n  /**\n   * @notice Withdraw a pool token's principal up to the token's principalAmount. Called by valid pools\n   *  as part of their withdraw flow before the pool is locked (i.e. before the principal is committed)\n   * @param tokenId pool token id\n   * @param principalAmount principal to withdraw\n   */\n  function withdrawPrincipal(uint256 tokenId, uint256 principalAmount) external;\n\n  /**\n   * @notice Burns a specific ERC721 token and removes deletes the token metadata for PoolTokens, BackerReards,\n   *  and BackerStakingRewards\n   * @param tokenId uint256 id of the ERC721 token to be burned.\n   */\n  function burn(uint256 tokenId) external;\n\n  /**\n   * @notice Called by the GoldfinchFactory to register the pool as a valid pool. Only valid pools can mint/redeem\n   * tokens\n   * @param newPool The address of the newly created pool\n   */\n  function onPoolCreated(address newPool) external;\n\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\n\n  function getPoolInfo(address pool) external view returns (PoolInfo memory);\n\n  /// @notice Query if `pool` is a valid pool. A pool is valid if it was created by the Goldfinch Factory\n  function validPool(address pool) external view returns (bool);\n\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\n\n  /**\n   * @notice Splits a pool token into two smaller positions. The original token is burned and all\n   * its associated data is deleted.\n   * @param tokenId id of the token to split.\n   * @param newPrincipal1 principal amount for the first token in the split. The principal amount for the\n   *  second token in the split is implicitly the original token's principal amount less newPrincipal1\n   * @return tokenId1 id of the first token in the split\n   * @return tokenId2 id of the second token in the split\n   */\n  function splitToken(\n    uint256 tokenId,\n    uint256 newPrincipal1\n  ) external returns (uint256 tokenId1, uint256 tokenId2);\n\n  /**\n   * @notice Mint event emitted for a new TranchedPool deposit or when an existing pool token is\n   *  split\n   * @param owner address to which the token was minted\n   * @param pool tranched pool that the deposit was in\n   * @param tokenId ERC721 tokenId\n   * @param amount the deposit amount\n   * @param tranche id of the tranche of the deposit\n   */\n  event TokenMinted(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 tranche\n  );\n\n  /**\n   * @notice Redeem event emitted when interest and/or principal is redeemed in the token's pool\n   * @param owner owner of the pool token\n   * @param pool tranched pool that the token belongs to\n   * @param principalRedeemed amount of principal redeemed from the pool\n   * @param interestRedeemed amount of interest redeemed from the pool\n   * @param tranche id of the tranche the token belongs to\n   */\n  event TokenRedeemed(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed,\n    uint256 tranche\n  );\n\n  /**\n   * @notice Burn event emitted when the token owner/operator manually burns the token or burns\n   *  it implicitly by splitting it\n   * @param owner owner of the pool token\n   * @param pool tranched pool that the token belongs to\n   */\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\n\n  /**\n   * @notice Split event emitted when the token owner/operator splits the token\n   * @param pool tranched pool to which the orginal and split tokens belong\n   * @param tokenId id of the original token that was split\n   * @param newTokenId1 id of the first split token\n   * @param newPrincipal1 principalAmount of the first split token\n   * @param newTokenId2 id of the second split token\n   * @param newPrincipal2 principalAmount of the second split token\n   */\n  event TokenSplit(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 newTokenId1,\n    uint256 newPrincipal1,\n    uint256 newTokenId2,\n    uint256 newPrincipal2\n  );\n\n  /**\n   * @notice Principal Withdrawn event emitted when a token's principal is withdrawn from the pool\n   *  BEFORE the pool's drawdown period\n   * @param pool tranched pool of the token\n   * @param principalWithdrawn amount of principal withdrawn from the pool\n   */\n  event TokenPrincipalWithdrawn(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalWithdrawn,\n    uint256 tranche\n  );\n}\n"
    },
    "contracts/interfaces/IRequiresUID.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IRequiresUID {\n  function hasAllowedUID(address sender) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/// @title IRouter\n/// @author landakram\n/// @notice This contract provides service discovery for contracts using the cake framework.\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\n///   and `Routing.Keys` libraries.\ninterface IRouter {\n  event SetContract(bytes4 indexed key, address indexed addr);\n\n  /// @notice Associate a routing key to a contract address\n  /// @dev This function is only callable by the Router admin\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\n  /// @param addr A contract address\n  function setContract(bytes4 key, address addr) external;\n}\n"
    },
    "contracts/interfaces/ISchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ISchedule {\n  function periodsPerPrincipalPeriod() external view returns (uint256);\n\n  function periodsInTerm() external view returns (uint256);\n\n  function periodsPerInterestPeriod() external view returns (uint256);\n\n  function gracePrincipalPeriods() external view returns (uint256);\n\n  /**\n   * @notice Returns the period that timestamp resides in\n   */\n  function periodAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\n\n  /**\n   * @notice Returns the principal period that timestamp resides in\n   */\n  function principalPeriodAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\n\n  /**\n   * @notice Returns the interest period that timestamp resides in\n   */\n  function interestPeriodAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\n\n  /**\n   * @notice Returns true if the given timestamp resides in a principal grace period\n   */\n  function withinPrincipalGracePeriodAt(\n    uint256 startTime,\n    uint256 timestamp\n  ) external view returns (bool);\n\n  /**\n   * Returns the next timestamp where either principal or interest will come due following `timestamp`\n   */\n  function nextDueTimeAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\n\n  /**\n   * @notice Returns the previous timestamp where either principal or timestamp came due\n   */\n  function previousDueTimeAt(uint256 startTime, uint256 timestamp) external view returns (uint256);\n\n  /**\n   * @notice Returns the previous timestamp where new interest came due\n   */\n  function previousInterestDueTimeAt(\n    uint256 startTime,\n    uint256 timestamp\n  ) external view returns (uint256);\n\n  /**\n   * @notice Returns the previous timestamp where new principal came due\n   */\n  function previousPrincipalDueTimeAt(\n    uint256 startTime,\n    uint256 timestamp\n  ) external view returns (uint256);\n\n  /**\n   * @notice Returns the total number of principal periods\n   */\n  function totalPrincipalPeriods() external view returns (uint256);\n\n  /**\n   * @notice Returns the total number of interest periods\n   */\n  function totalInterestPeriods() external view returns (uint256);\n\n  /**\n   * @notice Returns the timestamp that the term will end\n   */\n  function termEndTime(uint256 startTime) external view returns (uint256);\n\n  /**\n   * @notice Returns the timestamp that the term began\n   */\n  function termStartTime(uint256 startTime) external view returns (uint256);\n\n  /**\n   * @notice Returns the next time principal will come due, or the termEndTime if there are no more due times\n   */\n  function nextPrincipalDueTimeAt(\n    uint256 startTime,\n    uint256 timestamp\n  ) external view returns (uint256);\n\n  /**\n   * @notice Returns the next time interest will come due, or the termEndTime if there are no more due times\n   */\n  function nextInterestDueTimeAt(\n    uint256 startTime,\n    uint256 timestamp\n  ) external view returns (uint256);\n\n  /**\n   * @notice Returns the end time of the given period.\n   */\n  function periodEndTime(uint256 startTime, uint256 period) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISeniorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {ITranchedPool} from \"./ITranchedPool.sol\";\nimport {ISeniorPoolEpochWithdrawals} from \"./ISeniorPoolEpochWithdrawals.sol\";\n\nabstract contract ISeniorPool is ISeniorPoolEpochWithdrawals {\n  uint256 public sharePrice;\n  uint256 public totalLoansOutstanding;\n  uint256 public totalWritedowns;\n\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\n\n  function depositWithPermit(\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 depositShares);\n\n  /**\n   * @notice Withdraw `usdcAmount` of USDC, bypassing the epoch withdrawal system. Callable\n   * by Zapper only.\n   */\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\n\n  /**\n   * @notice Withdraw `fiduAmount` of FIDU converted to USDC at the current share price,\n   * bypassing the epoch withdrawal system. Callable by Zapper only\n   */\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\n\n  function invest(ITranchedPool pool) external virtual returns (uint256);\n\n  function estimateInvestment(ITranchedPool pool) external view virtual returns (uint256);\n\n  function redeem(uint256 tokenId) external virtual;\n\n  function writedown(uint256 tokenId) external virtual;\n\n  function calculateWritedown(\n    uint256 tokenId\n  ) external view virtual returns (uint256 writedownAmount);\n\n  function sharesOutstanding() external view virtual returns (uint256);\n\n  function assets() external view virtual returns (uint256);\n\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\n\n  event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n  event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n  event InterestCollected(address indexed payer, uint256 amount);\n  event PrincipalCollected(address indexed payer, uint256 amount);\n  event ReserveFundsCollected(address indexed user, uint256 amount);\n  event ReserveSharesCollected(address indexed user, address indexed reserve, uint256 amount);\n\n  event PrincipalWrittenDown(address indexed tranchedPool, int256 amount);\n  event InvestmentMadeInSenior(address indexed tranchedPool, uint256 amount);\n  event InvestmentMadeInJunior(address indexed tranchedPool, uint256 amount);\n}\n"
    },
    "contracts/interfaces/ISeniorPoolEpochWithdrawals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\npragma experimental ABIEncoderV2;\n\ninterface ISeniorPoolEpochWithdrawals {\n  /**\n   * @notice A withdrawal epoch\n   * @param endsAt timestamp the epoch ends\n   * @param fiduRequested amount of fidu requested in the epoch, including fidu\n   *                      carried over from previous epochs\n   * @param fiduLiquidated Amount of fidu that was liquidated at the end of this epoch\n   * @param usdcAllocated Amount of usdc that was allocated to liquidate fidu.\n   *                      Does not consider withdrawal fees.\n   */\n  struct Epoch {\n    uint256 endsAt;\n    uint256 fiduRequested;\n    uint256 fiduLiquidated;\n    uint256 usdcAllocated;\n  }\n\n  /**\n   * @notice A user's request for withdrawal\n   * @param epochCursor id of next epoch the user can liquidate their request\n   * @param fiduRequested amount of fidu left to liquidate since last checkpoint\n   * @param usdcWithdrawable amount of usdc available for a user to withdraw\n   */\n  struct WithdrawalRequest {\n    uint256 epochCursor;\n    uint256 usdcWithdrawable;\n    uint256 fiduRequested;\n  }\n\n  /**\n   * @notice Returns the amount of unallocated usdc in the senior pool, taking into account\n   *         usdc that _will_ be allocated to withdrawals when a checkpoint happens\n   */\n  function usdcAvailable() external view returns (uint256);\n\n  /// @notice Current duration of withdrawal epochs, in seconds\n  function epochDuration() external view returns (uint256);\n\n  /// @notice Update epoch duration\n  function setEpochDuration(uint256 newEpochDuration) external;\n\n  /// @notice The current withdrawal epoch\n  function currentEpoch() external view returns (Epoch memory);\n\n  /// @notice Get request by tokenId. A request is considered active if epochCursor > 0.\n  function withdrawalRequest(uint256 tokenId) external view returns (WithdrawalRequest memory);\n\n  /**\n   * @notice Submit a request to withdraw `fiduAmount` of FIDU. Request is rejected\n   * if caller already owns a request token. A non-transferrable request token is\n   * minted to the caller\n   * @return tokenId token minted to caller\n   */\n  function requestWithdrawal(uint256 fiduAmount) external returns (uint256 tokenId);\n\n  /**\n   * @notice Add `fiduAmount` FIDU to a withdrawal request for `tokenId`. Caller\n   * must own tokenId\n   */\n  function addToWithdrawalRequest(uint256 fiduAmount, uint256 tokenId) external;\n\n  /**\n   * @notice Cancel request for tokenId. The fiduRequested (minus a fee) is returned\n   * to the caller. Caller must own tokenId.\n   * @return fiduReceived the fidu amount returned to the caller\n   */\n  function cancelWithdrawalRequest(uint256 tokenId) external returns (uint256 fiduReceived);\n\n  /**\n   * @notice Transfer the usdcWithdrawable of request for tokenId to the caller.\n   * Caller must own tokenId\n   */\n  function claimWithdrawalRequest(uint256 tokenId) external returns (uint256 usdcReceived);\n\n  /// @notice Emitted when the epoch duration is changed\n  event EpochDurationChanged(uint256 newDuration);\n\n  /// @notice Emitted when a new withdraw request has been created\n  event WithdrawalRequested(\n    uint256 indexed epochId,\n    uint256 indexed tokenId,\n    address indexed operator,\n    uint256 fiduRequested\n  );\n\n  /// @notice Emitted when a user adds to their existing withdraw request\n  /// @param epochId epoch that the withdraw was added to\n  /// @param tokenId id of token that represents the position being added to\n  /// @param operator address that added to the request\n  /// @param fiduRequested amount of additional fidu added to request\n  event WithdrawalAddedTo(\n    uint256 indexed epochId,\n    uint256 indexed tokenId,\n    address indexed operator,\n    uint256 fiduRequested\n  );\n\n  /// @notice Emitted when a withdraw request has been canceled\n  event WithdrawalCanceled(\n    uint256 indexed epochId,\n    uint256 indexed tokenId,\n    address indexed operator,\n    uint256 fiduCanceled,\n    uint256 reserveFidu\n  );\n\n  /// @notice Emitted when an epoch has been checkpointed\n  /// @param epochId id of epoch that ended\n  /// @param endTime timestamp the epoch ended\n  /// @param fiduRequested amount of FIDU oustanding when the epoch ended\n  /// @param usdcAllocated amount of USDC allocated to liquidate FIDU\n  /// @param fiduLiquidated amount of FIDU liquidated using `usdcAllocated`\n  event EpochEnded(\n    uint256 indexed epochId,\n    uint256 endTime,\n    uint256 fiduRequested,\n    uint256 usdcAllocated,\n    uint256 fiduLiquidated\n  );\n\n  /// @notice Emitted when an epoch could not be finalized and is extended instead\n  /// @param epochId id of epoch that was extended\n  /// @param newEndTime new epoch end time\n  /// @param oldEndTime previous epoch end time\n  event EpochExtended(uint256 indexed epochId, uint256 newEndTime, uint256 oldEndTime);\n}\n"
    },
    "contracts/interfaces/ISeniorPoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ISeniorPool.sol\";\nimport \"./ITranchedPool.sol\";\n\nabstract contract ISeniorPoolStrategy {\n  function getLeverageRatio(ITranchedPool pool) public view virtual returns (uint256);\n\n  /**\n   * @notice Determines how much money to invest in the senior tranche based on what is committed to the junior\n   * tranche, what is committed to the senior tranche, and a leverage ratio to the junior tranche. Because\n   * it takes into account what is already committed to the senior tranche, the value returned by this\n   * function can be used \"idempotently\" to achieve the investment target amount without exceeding that target.\n   * @param seniorPool The senior pool to invest from\n   * @param pool The tranched pool to invest into (as the senior)\n   * @return amount of money to invest into the tranched pool's senior tranche, from the senior pool\n   */\n  function invest(\n    ISeniorPool seniorPool,\n    ITranchedPool pool\n  ) public view virtual returns (uint256 amount);\n\n  /**\n   * @notice A companion of `invest()`: determines how much would be returned by `invest()`, as the\n   * value to invest into the senior tranche, if the junior tranche were locked and the senior tranche\n   * were not locked.\n   * @param seniorPool The senior pool to invest from\n   * @param pool The tranched pool to invest into (as the senior)\n   * @return The amount of money to invest into the tranched pool's senior tranche, from the senior pool\n   */\n  function estimateInvestment(\n    ISeniorPool seniorPool,\n    ITranchedPool pool\n  ) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport {IERC721} from \"./openzeppelin/IERC721.sol\";\nimport {IERC721Metadata} from \"./openzeppelin/IERC721Metadata.sol\";\nimport {IERC721Enumerable} from \"./openzeppelin/IERC721Enumerable.sol\";\n\ninterface IStakingRewards is IERC721, IERC721Metadata, IERC721Enumerable {\n  /// @notice Get the staking rewards position\n  /// @param tokenId id of the position token\n  /// @return position the position\n  function getPosition(uint256 tokenId) external view returns (StakedPosition memory position);\n\n  /// @notice Unstake an amount of `stakingToken()` (FIDU, FiduUSDCCurveLP, etc) associated with\n  ///   a given position and transfer to msg.sender. Any remaining staked amount will continue to\n  ///   accrue rewards.\n  /// @dev This function checkpoints rewards\n  /// @param tokenId A staking position token ID\n  /// @param amount Amount of `stakingToken()` to be unstaked from the position\n  function unstake(uint256 tokenId, uint256 amount) external;\n\n  /// @notice Add `amount` to an existing FIDU position (`tokenId`)\n  /// @param tokenId A staking position token ID\n  /// @param amount Amount of `stakingToken()` to be added to tokenId's position\n  function addToStake(uint256 tokenId, uint256 amount) external;\n\n  /// @notice Returns the staked balance of a given position token.\n  /// @dev The value returned is the bare amount, not the effective amount. The bare amount represents\n  ///   the number of tokens the user has staked for a given position. The effective amount is the bare\n  ///   amount multiplied by the token's underlying asset type multiplier. This multiplier is a crypto-\n  ///   economic parameter determined by governance.\n  /// @param tokenId A staking position token ID\n  /// @return Amount of staked tokens denominated in `stakingToken().decimals()`\n  function stakedBalanceOf(uint256 tokenId) external view returns (uint256);\n\n  /// @notice Deposit to FIDU and USDC into the Curve LP, and stake your Curve LP tokens in the same transaction.\n  /// @param fiduAmount The amount of FIDU to deposit\n  /// @param usdcAmount The amount of USDC to deposit\n  function depositToCurveAndStakeFrom(\n    address nftRecipient,\n    uint256 fiduAmount,\n    uint256 usdcAmount\n  ) external;\n\n  /// @notice \"Kick\" a user's reward multiplier. If they are past their lock-up period, their reward\n  ///   multiplier will be reset to 1x.\n  /// @dev This will also checkpoint their rewards up to the current time.\n  function kick(uint256 tokenId) external;\n\n  /// @notice Accumulated rewards per token at the last checkpoint\n  function accumulatedRewardsPerToken() external view returns (uint256);\n\n  /// @notice The block timestamp when rewards were last checkpointed\n  function lastUpdateTime() external view returns (uint256);\n\n  /// @notice Claim rewards for a given staked position\n  /// @param tokenId A staking position token ID\n  /// @return amount of rewards claimed\n  function getReward(uint256 tokenId) external returns (uint256);\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event RewardRemoved(uint256 reward);\n  event Staked(\n    address indexed user,\n    uint256 indexed tokenId,\n    uint256 amount,\n    StakedPositionType positionType,\n    uint256 baseTokenExchangeRate\n  );\n  event DepositedAndStaked(\n    address indexed user,\n    uint256 depositedAmount,\n    uint256 indexed tokenId,\n    uint256 amount\n  );\n  event DepositedToCurve(\n    address indexed user,\n    uint256 fiduAmount,\n    uint256 usdcAmount,\n    uint256 tokensReceived\n  );\n  event DepositedToCurveAndStaked(\n    address indexed user,\n    uint256 fiduAmount,\n    uint256 usdcAmount,\n    uint256 indexed tokenId,\n    uint256 amount\n  );\n  event AddToStake(\n    address indexed user,\n    uint256 indexed tokenId,\n    uint256 amount,\n    StakedPositionType positionType\n  );\n  event Unstaked(\n    address indexed user,\n    uint256 indexed tokenId,\n    uint256 amount,\n    StakedPositionType positionType\n  );\n  event UnstakedMultiple(address indexed user, uint256[] tokenIds, uint256[] amounts);\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\n  event RewardsParametersUpdated(\n    address indexed who,\n    uint256 targetCapacity,\n    uint256 minRate,\n    uint256 maxRate,\n    uint256 minRateAtPercent,\n    uint256 maxRateAtPercent\n  );\n  event EffectiveMultiplierUpdated(\n    address indexed who,\n    StakedPositionType positionType,\n    uint256 multiplier\n  );\n}\n\n/// @notice Indicates which ERC20 is staked\nenum StakedPositionType {\n  Fidu,\n  CurveLP\n}\n\nstruct Rewards {\n  uint256 totalUnvested;\n  uint256 totalVested;\n  // @dev DEPRECATED (definition kept for storage slot)\n  //   For legacy vesting positions, this was used in the case of slashing.\n  //   For non-vesting positions, this is unused.\n  uint256 totalPreviouslyVested;\n  uint256 totalClaimed;\n  uint256 startTime;\n  // @dev DEPRECATED (definition kept for storage slot)\n  //   For legacy vesting positions, this is the endTime of the vesting.\n  //   For non-vesting positions, this is 0.\n  uint256 endTime;\n}\n\nstruct StakedPosition {\n  // @notice Staked amount denominated in `stakingToken().decimals()`\n  uint256 amount;\n  // @notice Struct describing rewards owed with vesting\n  Rewards rewards;\n  // @notice Multiplier applied to staked amount when locking up position\n  uint256 leverageMultiplier;\n  // @notice Time in seconds after which position can be unstaked\n  uint256 lockedUntil;\n  // @notice Type of the staked position\n  StakedPositionType positionType;\n  // @notice Multiplier applied to staked amount to denominate in `baseStakingToken().decimals()`\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\n  //  If you need this field, use `safeEffectiveMultiplier()`, which correctly handles old staked positions.\n  uint256 unsafeEffectiveMultiplier;\n  // @notice Exchange rate applied to staked amount to denominate in `baseStakingToken().decimals()`\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\n  //  If you need this field, use `safeBaseTokenExchangeRate()`, which correctly handles old staked positions.\n  uint256 unsafeBaseTokenExchangeRate;\n}\n"
    },
    "contracts/interfaces/ITranchedCreditLineInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport {ISchedule} from \"./ISchedule.sol\";\n\ninterface ITranchedCreditLineInitializable {\n  /// @notice Initialize a brand new credit line\n  function initialize(\n    address _config,\n    address owner,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    ISchedule _schedule,\n    uint256 _lateFeeApr\n  ) external;\n}\n"
    },
    "contracts/interfaces/ITranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\nimport {ISchedule} from \"./ISchedule.sol\";\nimport {ILoan} from \"./ILoan.sol\";\nimport {ICreditLine} from \"./ICreditLine.sol\";\n\ninterface ITranchedPool is ILoan {\n  struct TrancheInfo {\n    uint256 id;\n    uint256 principalDeposited;\n    uint256 principalSharePrice;\n    uint256 interestSharePrice;\n    uint256 lockedUntil;\n  }\n  struct PoolSlice {\n    TrancheInfo seniorTranche;\n    TrancheInfo juniorTranche;\n    uint256 totalInterestAccrued;\n    uint256 principalDeployed;\n  }\n  enum Tranches {\n    Reserved,\n    Senior,\n    Junior\n  }\n\n  /// @notice Initialize the pool. Can only be called once, and should be called in the same transaction as\n  ///   contract creation to avoid initialization front-running\n  /// @param _config address of GoldfinchConfig\n  /// @param _borrower address of borrower, a non-transferrable role for performing privileged actions like\n  ///   drawdown\n  /// @param _juniorFeePercent percent (whole number) of senior interest that gets re-allocated to the junior tranche.\n  ///   valid range is [0, 100]\n  /// @param _limit the max USDC amount that can be drawn down across all pool slices\n  /// @param _interestApr interest rate for the loan\n  /// @param _lateFeeApr late fee interest rate for the loan, which kicks in `LatenessGracePeriodInDays` days after a\n  ///   payment becomes late\n  /// @param _fundableAt earliest time at which the first slice can be funded\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    ISchedule _schedule,\n    uint256 _lateFeeApr,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) external;\n\n  /// @notice Pay down the credit line, separating the principal and interest payments. You must pay back all interest\n  ///   before paying back principal. Excess payments are refunded to the caller\n  /// @param principalPayment USDC amount to pay down principal\n  /// @param interestPayment USDC amount to pay down interest\n  /// @return PaymentAllocation info on how the payment was allocated\n  /// @dev {this} must be approved by msg.sender to transfer {principalPayment} + {interestPayment} of USDC\n  function pay(\n    uint256 principalPayment,\n    uint256 interestPayment\n  ) external returns (PaymentAllocation memory);\n\n  /// @notice TrancheInfo for tranche with id `trancheId`. The senior tranche of slice i has id 2*(i-1)+1. The\n  ///   junior tranche of slice i has id 2*i. Slice indices start at 1.\n  /// @param trancheId id of tranche. Valid ids are in the range [1, 2*numSlices]\n  function getTranche(uint256 trancheId) external view returns (ITranchedPool.TrancheInfo memory);\n\n  /// @notice Get a slice by index\n  /// @param index of slice. Valid indices are on the interval [0, numSlices - 1]\n  function poolSlices(uint256 index) external view returns (ITranchedPool.PoolSlice memory);\n\n  /// @notice Lock the junior capital in the junior tranche of the current slice. The capital is locked for\n  ///   `DrawdownPeriodInSeconds` seconds and gives the senior pool time to decide how much to invest (ensure\n  ///   leverage ratio cannot change for the period). During this period the borrower has the option to lock\n  ///   the senior capital by calling `lockPool()`. Backers may withdraw their junior capital if the the senior\n  ///   tranche has not been locked and the drawdown period has ended. Only the borrower can call this function.\n  function lockJuniorCapital() external;\n\n  /// @notice Lock the senior capital in the senior tranche of the current slice and reset the lock period of\n  ///   the junior capital to match the senior capital lock period. During this period the borrower has the\n  ///   option to draw down the pool. Beyond the drawdown period any unused capital is available to withdraw by\n  ///   all depositors.\n  function lockPool() external;\n\n  /// @notice Initialize the next slice for the pool. Enables backers and the senior pool to provide additional\n  ///   capital to the borrower.\n  /// @param _fundableAt time at which the new slice (now the current slice) becomes fundable\n  function initializeNextSlice(uint256 _fundableAt) external;\n\n  /// @notice Query the total capital supplied to the pool's junior tranches\n  function totalJuniorDeposits() external view returns (uint256);\n\n  function assess() external;\n\n  /// @notice Get the current number of slices for this pool\n  /// @return numSlices total current slice count\n  function numSlices() external view returns (uint256);\n\n  // Note: This has to exactly match the event in the TranchingLogic library for events to be emitted\n  // correctly\n  event SharePriceUpdated(\n    address indexed pool,\n    uint256 indexed tranche,\n    uint256 principalSharePrice,\n    int256 principalDelta,\n    uint256 interestSharePrice,\n    int256 interestDelta\n  );\n  event CreditLineMigrated(ICreditLine indexed oldCreditLine, ICreditLine indexed newCreditLine);\n  event TrancheLocked(address indexed pool, uint256 trancheId, uint256 lockedUntil);\n  event SliceCreated(address indexed pool, uint256 sliceId);\n}\n"
    },
    "contracts/interfaces/IUcuProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IERC173} from \"./IERC173.sol\";\nimport {IImplementationRepository as IRepo} from \"./IImplementationRepository.sol\";\n\n/// @title User Controlled Upgrade (UCU) Proxy\n///\n/// The UCU Proxy contract allows the owner of the proxy to control _when_ they\n/// upgrade their proxy, but not to what implementation.  The implementation is\n/// determined by an externally controlled {ImplementationRepository} contract that\n/// specifices the upgrade path. A user is able to upgrade their proxy as many\n/// times as is available until they're reached the most up to date version\ninterface IUcuProxy is IERC173 {\n  // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\n\n  /// @notice upgrade the proxy implementation\n  /// @dev reverts if the repository has not been initialized or if there is no following version\n  function upgradeImplementation() external;\n\n  /// @notice Returns the associated {Repo}\n  ///   contract used for fetching implementations to upgrade to\n  function getRepository() external view returns (IRepo);\n\n  // /////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////////\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n}\n"
    },
    "contracts/interfaces/IUniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface IUniqueIdentity is IERC1155Upgradeable {\n  /// @notice Mint a new UniqueIdentity token to the msgSender\n  /// @param id The id representing the KYC type of the UniqueIdentity\n  /// @param expiresAt The expiration time of the signature\n  /// @param signature An EIP-191 signature of the corresponding mint params:\n  ///                  account, id, expiresAt, address(this), nonces[account], block.chainid\n  ///                  from an address with the SIGNER_ROLE.\n  function mint(uint256 id, uint256 expiresAt, bytes calldata signature) external payable;\n\n  /// @notice Mint a new UniqueIdentity token to the `recipient`\n  /// @param recipient The recipient address to be minted to.\n  /// @param id The id representing the KYC type of the UniqueIdentity\n  /// @param expiresAt The expiration time of the signature\n  /// @param signature An EIP-191 signature of the corresponding mintTo params:\n  ///                  (account, recipient, id, expiresAt, address(this), nonces[account], block.chainid)\n  ///                  from an address with the SIGNER_ROLE.\n  function mintTo(\n    address recipient,\n    uint256 id,\n    uint256 expiresAt,\n    bytes calldata signature\n  ) external payable;\n\n  /// @notice Burn a UniqueIdentity token of `id` from the `account`\n  /// @param account The account which currently owns the UID\n  /// @param id The id representing the KYC type of the UniqueIdentity\n  /// @param expiresAt The expiration time of the signature\n  /// @param signature An EIP-191 signature of the corresponding burn params:\n  ///                  (account, id, expiresAt, address(this), nonces[account], block.chainid)\n  ///                  from an address with the SIGNER_ROLE.\n  function burn(address account, uint256 id, uint256 expiresAt, bytes calldata signature) external;\n}\n"
    },
    "contracts/interfaces/IUniqueIdentity0612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\n\n/// @dev This interface provides a subset of the functionality of the IUniqueIdentity\n/// interface -- namely, the subset of functionality needed by Goldfinch protocol contracts\n/// compiled with Solidity version 0.6.12.\ninterface IUniqueIdentity0612 {\n  function balanceOf(address account, uint256 id) external view returns (uint256);\n\n  function isApprovedForAll(address account, address operator) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IVersioned.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title interface for implementers that have an arbitrary associated tag\ninterface IVersioned {\n  /// @notice Returns the version triplet `[major, minor, patch]`\n  function getVersion() external pure returns (uint8[3] memory);\n}\n"
    },
    "contracts/interfaces/IVersionedImplementationRepository.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IImplementationRepository.sol\";\n\ninterface IVersionedImplementationRepository is IImplementationRepository {\n  function getByVersion(uint8[3] calldata version) external view returns (address);\n\n  function hasVersion(uint8[3] calldata version) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/openzeppelin/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n// This file copied from OZ, but with the version pragma updated to use >=.\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/openzeppelin/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\n// This file copied from OZ, but with the version pragma updated to use >= & reference other >= pragma interfaces.\n// NOTE: Modified to reference our updated pragma version of IERC165\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  /**\n   * @dev Returns the number of NFTs in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the NFT specified by `tokenId`.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n   * another (`to`).\n   *\n   *\n   *\n   * Requirements:\n   * - `from`, `to` cannot be zero.\n   * - `tokenId` must be owned by `from`.\n   * - If the caller is not `from`, it must be have been allowed to move this\n   * NFT by either {approve} or {setApprovalForAll}.\n   */\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n  /**\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n   * another (`to`).\n   *\n   * Requirements:\n   * - If the caller is not `from`, it must be approved to move this NFT by\n   * either {approve} or {setApprovalForAll}.\n   */\n  function transferFrom(address from, address to, uint256 tokenId) external;\n\n  function approve(address to, uint256 tokenId) external;\n\n  function getApproved(uint256 tokenId) external view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/interfaces/openzeppelin/IERC721Enumerable.sol": {
      "content": "pragma solidity >=0.6.2;\n\n// This file copied from OZ, but with the version pragma updated to use >=.\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n  function totalSupply() external view returns (uint256);\n\n  function tokenOfOwnerByIndex(\n    address owner,\n    uint256 index\n  ) external view returns (uint256 tokenId);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/openzeppelin/IERC721Metadata.sol": {
      "content": "pragma solidity >=0.6.2;\n\n// This file copied from OZ, but with the version pragma updated to use >=.\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/openzeppelin/IERC721Receiver.sol": {
      "content": "pragma solidity >=0.6.12;\n\n// This file copied from OZ, but with the version pragma updated to use >= & reference other >= pragma interfaces.\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "contracts/library/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nlibrary Arrays {\n  /**\n   * @notice Removes an item from an array and replaces it with the (previously) last element in the array so\n   *  there are no empty spaces. Assumes that `array` is not empty and index is valid.\n   * @param array the array to remove from\n   * @param index index of the item to remove\n   * @return newLength length of the resulting array\n   * @return replaced whether or not the index was replaced. Only false if the removed item was the last item\n   *  in the array.\n   */\n  function reorderingRemove(\n    uint256[] storage array,\n    uint256 index\n  ) internal returns (uint256 newLength, bool replaced) {\n    newLength = array.length - 1;\n    replaced = newLength != index;\n\n    if (replaced) {\n      array[index] = array[newLength];\n    }\n\n    array.pop();\n  }\n}\n"
    },
    "contracts/library/FiduConversions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nlibrary FiduConversions {\n  uint256 internal constant FIDU_MANTISSA = 1e18;\n  uint256 internal constant USDC_MANTISSA = 1e6;\n  uint256 internal constant USDC_TO_FIDU_MANTISSA = FIDU_MANTISSA / USDC_MANTISSA;\n  uint256 internal constant FIDU_USDC_CONVERSION_DECIMALS = USDC_TO_FIDU_MANTISSA * FIDU_MANTISSA;\n\n  /**\n   * @notice Convert Usdc to Fidu using a given share price\n   * @param usdcAmount amount of usdc to convert\n   * @param sharePrice share price to use to convert\n   * @return fiduAmount converted fidu amount\n   */\n  function usdcToFidu(uint256 usdcAmount, uint256 sharePrice) internal pure returns (uint256) {\n    return sharePrice > 0 ? (usdcAmount * FIDU_USDC_CONVERSION_DECIMALS) / sharePrice : 0;\n  }\n\n  /**\n   * @notice Convert fidu to USDC using a given share price\n   * @param fiduAmount fidu amount to convert\n   * @param sharePrice share price to do the conversion with\n   * @return usdcReceived usdc that will be received after converting\n   */\n  function fiduToUsdc(uint256 fiduAmount, uint256 sharePrice) internal pure returns (uint256) {\n    return (fiduAmount * sharePrice) / FIDU_USDC_CONVERSION_DECIMALS;\n  }\n}\n"
    },
    "contracts/library/SaturatingSub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.18;\n\nlibrary SaturatingSub {\n  /// @notice Do a - b but if that would result in underflow error, then just return 0\n  function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n    unchecked {\n      return b > a ? 0 : a - b;\n    }\n  }\n}\n"
    },
    "contracts/protocol/core/BaseUpgradeablePausable08x.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PauserPausable} from \"./PauserPausable08x.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title BaseUpgradeablePausable contract\n * @notice This is our Base contract that most other contracts inherit from. It includes many standard\n *  useful abilities like upgradeability, pausability, access control, and re-entrancy guards.\n * @author Goldfinch\n */\n\ncontract BaseUpgradeablePausable is\n  Initializable,\n  AccessControlUpgradeable,\n  PauserPausable,\n  ReentrancyGuardUpgradeable\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  // Pre-reserving a few slots in the base contract in case we need to add things in the future.\n  // This does not actually take up gas cost or storage cost, but it does reserve the storage slots.\n  // See OpenZeppelin's use of this pattern here:\n  // https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/GSN/Context.sol#L37\n  uint256[50] private __gap1;\n  uint256[50] private __gap2;\n  uint256[50] private __gap3;\n  uint256[50] private __gap4;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __BaseUpgradeablePausable__init(address owner) public initializer {\n    require(owner != address(0), \"Owner cannot be the zero address\");\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/callable/CallableLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\n// solhint-disable-next-line max-line-length\nimport {IERC20PermitUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {ICallableLoan, LoanPhase} from \"../../../interfaces/ICallableLoan.sol\";\nimport {ICallableLoanErrors} from \"../../../interfaces/ICallableLoanErrors.sol\";\nimport {ILoan, LoanType} from \"../../../interfaces/ILoan.sol\";\nimport {IRequiresUID} from \"../../../interfaces/IRequiresUID.sol\";\nimport {IERC20UpgradeableWithDec} from \"../../../interfaces/IERC20UpgradeableWithDec.sol\";\nimport {ICreditLine} from \"../../../interfaces/ICreditLine.sol\";\nimport {IPoolTokens} from \"../../../interfaces/IPoolTokens.sol\";\nimport {IVersioned} from \"../../../interfaces/IVersioned.sol\";\nimport {ISchedule} from \"../../../interfaces/ISchedule.sol\";\nimport {IGoldfinchConfig} from \"../../../interfaces/IGoldfinchConfig.sol\";\n\nimport {BaseUpgradeablePausable} from \"../BaseUpgradeablePausable08x.sol\";\n\nimport {CallableLoanConfigHelper} from \"./CallableLoanConfigHelper.sol\";\nimport {Waterfall} from \"./structs/Waterfall.sol\";\n// solhint-disable-next-line max-line-length\nimport {CallableCreditLine, CallableCreditLineLogic, CheckpointedCallableCreditLineLogic, SettledTrancheInfo} from \"./structs/CallableCreditLine.sol\";\nimport {StaleCallableCreditLine, StaleCallableCreditLineLogic} from \"./structs/StaleCallableCreditLine.sol\";\nimport {SaturatingSub} from \"../../../library/SaturatingSub.sol\";\nimport {PaymentSchedule, PaymentScheduleLogic} from \"../schedule/PaymentSchedule.sol\";\nimport {CallableLoanAccountant} from \"./CallableLoanAccountant.sol\";\n\n// import {console2 as console} from \"forge-std/console2.sol\";\n\n/// @title CallableLoan\n/// @notice A loan that allows the lenders to call back capital from the borrower.\n/// @author Warbler Labs\ncontract CallableLoan is\n  BaseUpgradeablePausable,\n  ICallableLoan,\n  ICallableLoanErrors,\n  ICreditLine,\n  IRequiresUID,\n  IVersioned\n{\n  using CheckpointedCallableCreditLineLogic for CallableCreditLine;\n  using CallableLoanConfigHelper for IGoldfinchConfig;\n  using SafeERC20 for IERC20UpgradeableWithDec;\n  using SaturatingSub for uint256;\n\n  /*================================================================================\n  Constants\n  ================================================================================*/\n  bytes32 public constant LOCKER_ROLE = keccak256(\"LOCKER_ROLE\");\n  // When splitting a pool token as part of submitting a call, the remainder on a\n  // pool token should be voided if it does not meet this threshold.\n  // Why 5e3 (half a cent)? Large enough to rule out rounding errors, but small\n  // enough to not materially effect USD accounting.\n  uint256 public constant SPLIT_TOKEN_DUST_THRESHOLD = 5e3;\n\n  uint8 internal constant MAJOR_VERSION = 1;\n  uint8 internal constant MINOR_VERSION = 1;\n  uint8 internal constant PATCH_VERSION = 0;\n\n  /*================================================================================\n  Storage State\n  ================================================================================*/\n  StaleCallableCreditLine private _staleCreditLine;\n  bool public drawdownsPaused;\n  uint256[] public allowedUIDTypes;\n\n  /*================================================================================\n  Storage Static Configuration\n  ================================================================================*/\n  IGoldfinchConfig public config;\n  uint256 public override createdAt;\n  address public override borrower;\n\n  /*================================================================================\n  Initialization\n  ================================================================================*/\n\n  function initialize(\n    IGoldfinchConfig _config,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _numLockupPeriods,\n    ISchedule _schedule,\n    uint256 _lateFeeApr,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) external override initializer {\n    // NOTE: This check can be replaced with an after deploy verification rather than\n    //       a require statement which increases bytecode size.\n    // require(address(_config) != address(0) && address(_borrower) != address(0), \"00\");\n    if (_numLockupPeriods >= _schedule.periodsPerPrincipalPeriod()) {\n      revert InvalidNumLockupPeriods(_numLockupPeriods, _schedule.periodsPerPrincipalPeriod());\n    }\n\n    config = _config;\n    borrower = _borrower;\n    createdAt = block.timestamp;\n    allowedUIDTypes = _allowedUIDTypes;\n\n    {\n      address owner = config.protocolAdminAddress();\n      __BaseUpgradeablePausable__init(owner);\n\n      _setupRole(LOCKER_ROLE, _borrower);\n      _setupRole(LOCKER_ROLE, owner);\n      _setRoleAdmin(LOCKER_ROLE, OWNER_ROLE);\n    }\n\n    _staleCreditLine.initialize({\n      _config: _config,\n      _fundableAt: _fundableAt,\n      _numLockupPeriods: _numLockupPeriods,\n      _schedule: _schedule,\n      _interestApr: _interestApr,\n      _lateAdditionalApr: _lateFeeApr,\n      _limit: _limit\n    });\n    emit DrawdownsPaused(address(this));\n  }\n\n  /*================================================================================\n  Main Public/External Write functions\n  ================================================================================*/\n  /// @inheritdoc ICallableLoan\n  /// @notice Submit a call request for the given amount of capital.\n  ///         The borrower is obligated to pay the call request back at the end of the\n  ///         corresponding call request period.\n  /// @param callAmount Amount of capital to call back\n  /// @param poolTokenId Pool token id to be called back.\n  function submitCall(\n    uint256 callAmount,\n    uint256 poolTokenId\n  )\n    external\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 callRequestedTokenId, uint256 remainingTokenId)\n  {\n    // 1. Checkpoint the credit line and perform basic validation on the call request.\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n    IPoolTokens poolTokens = config.getPoolTokens();\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(poolTokenId);\n    if (!poolTokens.isApprovedOrOwner(msg.sender, poolTokenId) || !hasAllowedUID(msg.sender)) {\n      revert NotAuthorizedToSubmitCall(msg.sender, poolTokenId);\n    }\n    if (tokenInfo.tranche != cl.uncalledCapitalTrancheIndex()) {\n      revert InvalidCallSubmissionPoolToken(poolTokenId);\n    }\n\n    if (callAmount == 0) {\n      revert ZeroCallSubmissionAmount();\n    }\n\n    if (\n      callAmount >\n      cl.proportionalCallablePrincipal({\n        trancheId: tokenInfo.tranche,\n        principalDeposited: tokenInfo.principalAmount\n      })\n    ) {\n      revert ExcessiveCallSubmissionAmount(\n        poolTokenId,\n        callAmount,\n        cl.proportionalCallablePrincipal({\n          trancheId: tokenInfo.tranche,\n          principalDeposited: tokenInfo.principalAmount\n        })\n      );\n    }\n\n    // 2. Determine the total amount of principal and interest that can be withdrawn\n    //    on the given pool token. Withdraw all of this amount.\n    (uint256 totalInterestWithdrawable, uint256 totalPrincipalWithdrawable) = cl\n      .proportionalInterestAndPrincipalAvailable({\n        trancheId: tokenInfo.tranche,\n        principal: tokenInfo.principalAmount,\n        feePercent: _reserveFundsFeePercent()\n      });\n\n    {\n      uint256 netWithdrawableAmount = totalPrincipalWithdrawable -\n        tokenInfo.principalRedeemed +\n        totalInterestWithdrawable -\n        tokenInfo.interestRedeemed;\n      if (netWithdrawableAmount > 0) {\n        _withdraw(tokenInfo, poolTokenId, netWithdrawableAmount, cl);\n      }\n    }\n\n    // 3. Account for the call request in the credit line - this will return the corresponding\n    //    amounts of principal deposited, principal paid, and interest redeemable which have\n    //    been moved from the pool token to the call request token.\n    (\n      uint256 principalDepositedMoved,\n      uint256 principalPaidRedeemable,\n      ,\n      uint256 interestRedeemable\n    ) = cl.submitCall(callAmount);\n    interestRedeemable = (interestRedeemable * (100 - _reserveFundsFeePercent())) / 100;\n\n    {\n      // 4. Mint a new token representing the call requested pool token.\n      //    Redeem the principal paid and interest redeemed to make sure a user cannot\n      //    double withdraw their redeemable balances on the call requested token.\n      address owner = poolTokens.ownerOf(poolTokenId);\n      callRequestedTokenId = poolTokens.mint(\n        IPoolTokens.MintParams({\n          principalAmount: principalDepositedMoved,\n          tranche: cl.activeCallSubmissionTrancheIndex()\n        }),\n        owner\n      );\n\n      poolTokens.redeem(callRequestedTokenId, principalPaidRedeemable, interestRedeemable);\n\n      // 5. If an above SPLIT_TOKEN_DUST_THRESHOLD amount of principal remains on the pool token,\n      //    mint a new token representing the remainder.\n      //    Redeem the principal paid and interest redeemed to make sure a user cannot\n      //    double withdraw their redeemable balances on the call requested token.\n      if (tokenInfo.principalAmount - principalDepositedMoved > SPLIT_TOKEN_DUST_THRESHOLD) {\n        remainingTokenId = poolTokens.mint(\n          IPoolTokens.MintParams({\n            principalAmount: tokenInfo.principalAmount - principalDepositedMoved,\n            tranche: cl.uncalledCapitalTrancheIndex()\n          }),\n          owner\n        );\n\n        assert(principalPaidRedeemable <= totalPrincipalWithdrawable);\n        assert(interestRedeemable <= totalInterestWithdrawable);\n\n        poolTokens.redeem(\n          remainingTokenId,\n          totalPrincipalWithdrawable - principalPaidRedeemable,\n          totalInterestWithdrawable - interestRedeemable\n        );\n      }\n    }\n\n    // 6. Redeem the original pool token's balance so we can burn it. Then burn it.\n    poolTokens.redeem(poolTokenId, tokenInfo.principalAmount - totalPrincipalWithdrawable, 0);\n    poolTokens.burn(poolTokenId);\n\n    emit CallRequestSubmitted(poolTokenId, callRequestedTokenId, remainingTokenId, callAmount);\n  }\n\n  /// @inheritdoc ILoan\n  /// @notice Supply capital to the loan.\n  /// @param tranche Should always be uncalled capital tranche index.\n  /// @param amount amount of capital to supply\n  /// @return tokenId NFT representing your position in this pool\n  function deposit(\n    uint256 tranche,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256) {\n    return _deposit(tranche, amount);\n  }\n\n  /// @inheritdoc ILoan\n  /// @notice Supply capital to the loan.\n  /// @param tranche Should always be uncalled capital tranche index.\n  /// @param amount amount of capital to supply\n  /// @param deadline deadline of permit operation\n  /// @param v v portion of signature\n  /// @param r r portion of signature\n  /// @param s s portion of signature\n  /// @return tokenId NFT representing your position in this pool\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override nonReentrant whenNotPaused returns (uint256 tokenId) {\n    IERC20PermitUpgradeable(config.usdcAddress()).permit(\n      msg.sender,\n      address(this),\n      amount,\n      deadline,\n      v,\n      r,\n      s\n    );\n    return _deposit(tranche, amount);\n  }\n\n  /// @inheritdoc ILoan\n  function withdraw(\n    uint256 tokenId,\n    uint256 amount\n  ) external override nonReentrant whenNotPaused returns (uint256, uint256) {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    return _withdraw(tokenInfo, tokenId, amount);\n  }\n\n  /// @inheritdoc ILoan\n  function withdrawMultiple(\n    uint256[] calldata tokenIds,\n    uint256[] calldata amounts\n  ) external override nonReentrant whenNotPaused {\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n    if (tokenIds.length != amounts.length) {\n      revert ArrayLengthMismatch(tokenIds.length, amounts.length);\n    }\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenIds[i]);\n      _withdraw(tokenInfo, tokenIds[i], amounts[i], cl);\n    }\n  }\n\n  /// @inheritdoc ILoan\n  function withdrawMax(\n    uint256 tokenId\n  )\n    external\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn)\n  {\n    return _withdrawMax(tokenId);\n  }\n\n  /// @inheritdoc ILoan\n  function drawdown(\n    uint256 amount\n  ) external override(ICreditLine, ILoan) nonReentrant onlyLocker whenNotPaused {\n    if (drawdownsPaused) {\n      revert CannotDrawdownWhenDrawdownsPaused();\n    }\n    if (amount == 0) {\n      revert ZeroDrawdownAmount();\n    }\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n\n    cl.drawdown(amount);\n\n    config.getUSDC().safeTransfer(borrower, amount);\n    emit DrawdownMade(borrower, amount);\n  }\n\n  /// @inheritdoc ILoan\n  function pay(\n    uint256 amount\n  )\n    external\n    override(ICreditLine, ILoan)\n    nonReentrant\n    whenNotPaused\n    returns (PaymentAllocation memory)\n  {\n    return _pay(amount);\n  }\n\n  /// @notice Pauses all drawdowns (but not deposits/withdraws)\n  function pauseDrawdowns() external onlyAdmin {\n    drawdownsPaused = true;\n    emit DrawdownsPaused(address(this));\n  }\n\n  /// @notice Unpause drawdowns\n  function unpauseDrawdowns() external onlyAdmin {\n    drawdownsPaused = false;\n    emit DrawdownsUnpaused(address(this));\n  }\n\n  /// Set accepted UID types for the loan.\n  /// Requires that users have not already begun to deposit.\n  function setAllowedUIDTypes(uint256[] calldata ids) external onlyLocker {\n    if (_staleCreditLine.totalPrincipalDeposited() != 0) {\n      revert CannotSetAllowedUIDTypesAfterDeposit();\n    }\n    allowedUIDTypes = ids;\n  }\n\n  /// @inheritdoc ILoan\n  function setFundableAt(uint256 newFundableAt) external override onlyLocker {\n    _staleCreditLine.checkpoint().setFundableAt(newFundableAt);\n  }\n\n  /*================================================================================\n  Main Public/External View functions\n  ================================================================================*/\n\n  /// @inheritdoc ILoan\n  function getLoanType() external pure override returns (LoanType) {\n    return LoanType.CallableLoan;\n  }\n\n  function getFundableAt() external view returns (uint256) {\n    return _staleCreditLine.fundableAt();\n  }\n\n  function getAllowedUIDTypes() external view override returns (uint256[] memory) {\n    return allowedUIDTypes;\n  }\n\n  function inLockupPeriod() public view override returns (bool) {\n    return _staleCreditLine.inLockupPeriod();\n  }\n\n  function numLockupPeriods() public view override returns (uint256) {\n    return _staleCreditLine.numLockupPeriods();\n  }\n\n  /// @inheritdoc ICallableLoan\n  function estimateOwedInterestAt(\n    uint256 assumedBalance,\n    uint256 timestamp\n  ) public view override returns (uint256) {\n    return\n      (_staleCreditLine.totalInterestAccrued() +\n        CallableLoanAccountant.calculateInterest(\n          timestamp - block.timestamp,\n          assumedBalance,\n          _staleCreditLine.interestApr()\n        )).saturatingSub(_staleCreditLine.totalInterestPaid());\n  }\n\n  /// @inheritdoc ICallableLoan\n  function estimateOwedInterestAt(uint256 timestamp) external view override returns (uint256) {\n    return estimateOwedInterestAt(interestBearingBalance(), timestamp);\n  }\n\n  /// @inheritdoc ICallableLoan\n  function loanPhase() public view override returns (LoanPhase) {\n    return _staleCreditLine.loanPhase();\n  }\n\n  /// TODO: Low priority tests - currently only used for tests and frontend\n  /// @inheritdoc ICallableLoan\n  function interestBearingBalance() public view override returns (uint256) {\n    return\n      _staleCreditLine.totalPrincipalDeposited() -\n      _staleCreditLine.totalPrincipalPaidAt(block.timestamp);\n  }\n\n  /// @inheritdoc ILoan\n  function getAmountsOwed(\n    uint256 timestamp\n  )\n    external\n    view\n    override\n    returns (\n      uint256 returnedInterestOwed,\n      uint256 returnedInterestAccrued,\n      uint256 returnedPrincipalOwed\n    )\n  {\n    if (timestamp < block.timestamp) {\n      revert InputTimestampInThePast(timestamp);\n    }\n\n    return (interestOwedAt(timestamp), interestAccruedAt(timestamp), principalOwedAt(timestamp));\n  }\n\n  function uncalledCapitalTrancheIndex() public view override returns (uint256) {\n    return _staleCreditLine.uncalledCapitalTrancheIndex();\n  }\n\n  function getUncalledCapitalInfo() external view returns (UncalledCapitalInfo memory) {\n    SettledTrancheInfo memory info = _staleCreditLine.getSettledTrancheInfo(\n      uncalledCapitalTrancheIndex()\n    );\n    return\n      UncalledCapitalInfo({\n        interestPaid: info.interestPaid,\n        principalDeposited: info.principalDeposited,\n        principalPaid: info.principalPaid,\n        principalReserved: info.principalReserved\n      });\n  }\n\n  function getCallRequestPeriod(\n    uint256 callRequestPeriodIndex\n  ) external view returns (CallRequestPeriod memory) {\n    if (callRequestPeriodIndex >= uncalledCapitalTrancheIndex()) {\n      revert OutOfCallRequestPeriodBounds(uncalledCapitalTrancheIndex() - 1);\n    }\n    SettledTrancheInfo memory info = _staleCreditLine.getSettledTrancheInfo(callRequestPeriodIndex);\n    return\n      CallRequestPeriod({\n        interestPaid: info.interestPaid,\n        principalDeposited: info.principalDeposited,\n        principalPaid: info.principalPaid,\n        principalReserved: info.principalReserved\n      });\n  }\n\n  function availableToCall(uint256 tokenId) public view override returns (uint256) {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    if (tokenInfo.tranche != uncalledCapitalTrancheIndex()) {\n      revert MustSubmitCallToUncalledTranche(tokenInfo.tranche, uncalledCapitalTrancheIndex());\n    }\n    return\n      _staleCreditLine.proportionalCallablePrincipal({\n        trancheId: tokenInfo.tranche,\n        principalDeposited: tokenInfo.principalAmount\n      });\n  }\n\n  /// @inheritdoc ILoan\n  function availableToWithdraw(uint256 tokenId) public view override returns (uint256, uint256) {\n    return _availableToWithdraw(config.getPoolTokens().getTokenInfo(tokenId));\n  }\n\n  function hasAllowedUID(address sender) public view override returns (bool) {\n    return config.getGo().goOnlyIdTypes(sender, allowedUIDTypes);\n  }\n\n  /*================================================================================\n  Internal Write functions\n  ================================================================================*/\n  function _pay(uint256 amount) internal returns (ILoan.PaymentAllocation memory) {\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n    if (amount == 0) {\n      revert ZeroPaymentAmount();\n    }\n\n    ILoan.PaymentAllocation memory pa = CallableLoanAccountant.allocatePayment({\n      paymentAmount: amount,\n      interestOwed: cl.interestOwed(),\n      interestAccrued: cl.interestAccrued(),\n      principalOwed: cl.principalOwed(),\n      interestRate: cl.interestApr(),\n      balance: cl.totalPrincipalOutstanding(),\n      timeUntilNextPrincipalSettlement: cl.nextPrincipalDueTimeAt(block.timestamp).saturatingSub(\n        block.timestamp\n      ),\n      guaranteedFutureInterestPaid: cl.totalInterestPaid().saturatingSub(cl.totalInterestAccrued())\n    });\n\n    uint256 totalInterestPayment = pa.owedInterestPayment + pa.accruedInterestPayment;\n    uint256 totalPrincipalPayment = pa.principalPayment + pa.additionalBalancePayment;\n\n    uint256 reserveFundsFee = (_reserveFundsFeePercent() * totalInterestPayment) / 100;\n\n    cl.pay(totalPrincipalPayment, totalInterestPayment);\n    emit PaymentApplied({\n      payer: msg.sender,\n      pool: address(this),\n      interest: totalInterestPayment,\n      principal: totalPrincipalPayment,\n      remaining: pa.paymentRemaining,\n      reserve: reserveFundsFee\n    });\n\n    config.getUSDC().safeTransferFrom(\n      msg.sender,\n      address(this),\n      totalInterestPayment + totalPrincipalPayment\n    );\n    config.getUSDC().safeTransfer(config.reserveAddress(), reserveFundsFee);\n    emit ReserveFundsCollected(address(this), reserveFundsFee);\n    return pa;\n  }\n\n  /// @notice Supply capital to the loan.\n  /// @param tranche Should always be uncalled capital tranche index.\n  /// @param amount amount of capital to supply\n  /// @return tokenId NFT representing your position in this pool\n  function _deposit(uint256 tranche, uint256 amount) internal returns (uint256) {\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n    if (amount == 0) {\n      revert ZeroDepositAmount();\n    }\n    if (tranche != cl.uncalledCapitalTrancheIndex()) {\n      revert MustDepositToUncalledTranche(tranche, cl.uncalledCapitalTrancheIndex());\n    }\n    if (!hasAllowedUID(msg.sender)) {\n      revert InvalidUIDForDepositor(msg.sender);\n    }\n\n    cl.deposit(amount);\n    uint256 tokenId = config.getPoolTokens().mint(\n      IPoolTokens.MintParams({tranche: tranche, principalAmount: amount}),\n      msg.sender\n    );\n    config.getUSDC().safeTransferFrom(msg.sender, address(this), amount);\n\n    emit DepositMade(msg.sender, tranche, tokenId, amount);\n    return tokenId;\n  }\n\n  function _withdraw(\n    IPoolTokens.TokenInfo memory tokenInfo,\n    uint256 tokenId,\n    uint256 amount\n  ) internal returns (uint256, uint256) {\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n    return _withdraw(tokenInfo, tokenId, amount, cl);\n  }\n\n  function _withdraw(\n    IPoolTokens.TokenInfo memory tokenInfo,\n    uint256 tokenId,\n    uint256 amount,\n    CallableCreditLine storage cl\n  ) internal returns (uint256, uint256) {\n    if (amount == 0) {\n      revert ZeroWithdrawAmount();\n    }\n    IPoolTokens poolTokens = config.getPoolTokens();\n    if (!poolTokens.isApprovedOrOwner(msg.sender, tokenId) || !hasAllowedUID(msg.sender)) {\n      revert NotAuthorizedToWithdraw(msg.sender, tokenId);\n    }\n\n    // calculate the amount that will ever be redeemable\n    (uint256 interestWithdrawable, uint256 principalWithdrawable) = _availableToWithdraw(\n      tokenInfo,\n      cl\n    );\n\n    if (amount > interestWithdrawable + principalWithdrawable) {\n      revert WithdrawAmountExceedsWithdrawable(\n        amount,\n        interestWithdrawable + principalWithdrawable\n      );\n    }\n\n    // prefer to withdraw interest first, then principal\n    uint256 interestToRedeem = Math.min(interestWithdrawable, amount);\n    uint256 amountAfterInterest = amount - interestToRedeem;\n    uint256 principalToRedeem = Math.min(amountAfterInterest, principalWithdrawable);\n\n    {\n      LoanPhase _loanPhase = cl.loanPhase();\n      if (_loanPhase == LoanPhase.InProgress) {\n        poolTokens.redeem({\n          tokenId: tokenId,\n          principalRedeemed: principalToRedeem,\n          interestRedeemed: interestToRedeem\n        });\n      } else if (_loanPhase == LoanPhase.Funding) {\n        // if the pool is still funding, we need to decrease the deposit rather than the amount redeemed\n        assert(interestToRedeem == 0);\n        cl.withdraw(principalToRedeem);\n        poolTokens.withdrawPrincipal({tokenId: tokenId, principalAmount: principalToRedeem});\n      } else {\n        revert CannotWithdrawInDrawdownPeriod();\n      }\n    }\n\n    config.getUSDC().safeTransfer(msg.sender, interestToRedeem + principalToRedeem);\n\n    // While owner is the label of the first argument, it is actually the sender of the transaction.\n    emit WithdrawalMade({\n      owner: msg.sender,\n      tranche: tokenInfo.tranche,\n      tokenId: tokenId,\n      interestWithdrawn: interestToRedeem,\n      principalWithdrawn: principalToRedeem\n    });\n\n    return (interestToRedeem, principalToRedeem);\n  }\n\n  function _withdrawMax(uint256 tokenId) internal returns (uint256, uint256) {\n    CallableCreditLine storage cl = _staleCreditLine.checkpoint();\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    (uint256 interestWithdrawable, uint256 principalWithdrawable) = _availableToWithdraw(tokenInfo);\n    uint256 totalWithdrawable = interestWithdrawable + principalWithdrawable;\n    return _withdraw(tokenInfo, tokenId, totalWithdrawable, cl);\n  }\n\n  /*================================================================================\n  PaymentSchedule proxy functions\n  ================================================================================*/\n  function nextPrincipalDueTime() public view override returns (uint256) {\n    return _staleCreditLine.nextPrincipalDueTime();\n  }\n\n  function nextDueTimeAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.nextDueTimeAt(timestamp);\n  }\n\n  function nextInterestDueTimeAt(uint256 timestamp) public view returns (uint256) {\n    return _staleCreditLine.nextInterestDueTimeAt(timestamp);\n  }\n\n  function schedule() public view override returns (ISchedule) {\n    return _staleCreditLine.schedule();\n  }\n\n  /*================================================================================\n  Internal View functions\n  ================================================================================*/\n  function _reserveFundsFeePercent() public view returns (uint256) {\n    return uint256(100) / (config.getReserveDenominator());\n  }\n\n  function _availableToWithdraw(\n    IPoolTokens.TokenInfo memory tokenInfo\n  ) internal view returns (uint256 interestAvailable, uint256 principalAvailable) {\n    // Bail out early to account for proportion of zero or invalid phase for withdrawal\n    if (tokenInfo.principalAmount == 0 || loanPhase() == LoanPhase.DrawdownPeriod) {\n      return (0, 0);\n    }\n\n    (uint256 totalInterestWithdrawable, uint256 totalPrincipalWithdrawable) = _staleCreditLine\n      .proportionalInterestAndPrincipalAvailable({\n        trancheId: tokenInfo.tranche,\n        principal: tokenInfo.principalAmount,\n        feePercent: _reserveFundsFeePercent()\n      });\n\n    return\n      _availableToWithdrawGivenProportions(\n        tokenInfo,\n        totalInterestWithdrawable,\n        totalPrincipalWithdrawable\n      );\n  }\n\n  function _availableToWithdraw(\n    IPoolTokens.TokenInfo memory tokenInfo,\n    CallableCreditLine storage cl\n  ) internal view returns (uint256 interestAvailable, uint256 principalAvailable) {\n    if (tokenInfo.principalAmount == 0) {\n      // Bail out early to account for proportion of zero.\n      return (0, 0);\n    }\n\n    (uint256 totalInterestWithdrawable, uint256 totalPrincipalWithdrawable) = cl\n      .proportionalInterestAndPrincipalAvailable({\n        trancheId: tokenInfo.tranche,\n        principal: tokenInfo.principalAmount,\n        feePercent: _reserveFundsFeePercent()\n      });\n\n    return\n      _availableToWithdrawGivenProportions(\n        tokenInfo,\n        totalInterestWithdrawable,\n        totalPrincipalWithdrawable\n      );\n  }\n\n  function _availableToWithdrawGivenProportions(\n    IPoolTokens.TokenInfo memory tokenInfo,\n    uint256 totalInterestWithdrawable,\n    uint256 totalPrincipalWithdrawable\n  ) internal view returns (uint256 interestAvailable, uint256 principalAvailable) {\n    // Due to integer math, redeemeded amounts can be more than redeemable amounts after splitting.\n    assert(tokenInfo.principalRedeemed <= totalPrincipalWithdrawable + 1);\n    assert(tokenInfo.interestRedeemed <= totalInterestWithdrawable + 1);\n\n    return (\n      totalInterestWithdrawable.saturatingSub(tokenInfo.interestRedeemed),\n      totalPrincipalWithdrawable.saturatingSub(tokenInfo.principalRedeemed)\n    );\n  }\n\n  /*================================================================================\n  Legacy ICreditLine Conformance\n  ================================================================================*/\n  /// @inheritdoc ILoan\n  function creditLine() external view override returns (ICreditLine) {\n    return this;\n  }\n\n  /// @inheritdoc ICreditLine\n  function balance() public view returns (uint256) {\n    return _staleCreditLine.totalPrincipalOutstanding();\n  }\n\n  /// @inheritdoc ICreditLine\n  function interestOwed() public view override returns (uint256) {\n    return _staleCreditLine.interestOwed();\n  }\n\n  /// @inheritdoc ICreditLine\n  function principalOwed() public view override returns (uint256) {\n    return _staleCreditLine.principalOwed();\n  }\n\n  /// @inheritdoc ICreditLine\n  function termEndTime() public view override returns (uint256) {\n    return _staleCreditLine.termEndTime();\n  }\n\n  /// @inheritdoc ICreditLine\n  function nextDueTime() public view override returns (uint256) {\n    return _staleCreditLine.nextDueTime();\n  }\n\n  /// @notice We keep this to conform to the ICreditLine interface, but it's redundant information\n  ///   now that we have `checkpointedAsOf`\n  function interestAccruedAsOf() public view override returns (uint256) {\n    return _staleCreditLine.checkpointedAsOf();\n  }\n\n  /// @inheritdoc ICreditLine\n  function currentLimit() public view override returns (uint256) {\n    return _staleCreditLine.limit();\n  }\n\n  /// @inheritdoc ICreditLine\n  function limit() public view override returns (uint256) {\n    return _staleCreditLine.limit();\n  }\n\n  /// @inheritdoc ICreditLine\n  function interestApr() public view override returns (uint256) {\n    return _staleCreditLine.interestApr();\n  }\n\n  /// @inheritdoc ICreditLine\n  function lateFeeApr() public view override returns (uint256) {\n    return _staleCreditLine.lateAdditionalApr();\n  }\n\n  /// @inheritdoc ICreditLine\n  function isLate() public view override returns (bool) {\n    return _staleCreditLine.isLate();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function totalInterestAccrued() public view override returns (uint256) {\n    return _staleCreditLine.totalInterestAccrued();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function totalInterestAccruedAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.totalInterestAccruedAt(timestamp);\n  }\n\n  /// @inheritdoc ICreditLine\n  function totalInterestPaid() public view override returns (uint256) {\n    return _staleCreditLine.totalInterestPaid();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function totalInterestOwed() public view override returns (uint256) {\n    return _staleCreditLine.totalInterestOwed();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function totalInterestOwedAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.totalInterestOwedAt(timestamp);\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function interestOwedAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.interestOwedAt(timestamp);\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function interestAccrued() public view override returns (uint256) {\n    return _staleCreditLine.interestAccrued();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  /// @inheritdoc ICreditLine\n  function interestAccruedAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.interestAccruedAt(timestamp);\n  }\n\n  /// @inheritdoc ICreditLine\n  function principalOwedAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.principalOwedAt(timestamp);\n  }\n\n  /// @inheritdoc ICreditLine\n  function totalPrincipalPaid() public view override returns (uint256) {\n    return _staleCreditLine.totalPrincipalPaid();\n  }\n\n  /// @inheritdoc ICreditLine\n  function totalPrincipalOwedAt(uint256 timestamp) public view override returns (uint256) {\n    return _staleCreditLine.totalPrincipalOwedAt(timestamp);\n  }\n\n  /// @inheritdoc ICreditLine\n  function totalPrincipalOwed() public view override returns (uint256) {\n    return _staleCreditLine.totalPrincipalOwed();\n  }\n\n  /// @inheritdoc ICreditLine\n  function termStartTime() public view override returns (uint256) {\n    return _staleCreditLine.termStartTime();\n  }\n\n  /// @inheritdoc ICreditLine\n  function withinPrincipalGracePeriod() public view override returns (bool) {\n    return _staleCreditLine.withinPrincipalGracePeriod();\n  }\n\n  /// @inheritdoc ICreditLine\n  function lastFullPaymentTime() public view override returns (uint256) {\n    return _staleCreditLine.lastFullPaymentTime();\n  }\n\n  /// Unsupported in callable loans.\n  function pay(\n    uint256,\n    uint256\n  ) external pure override(ICreditLine) returns (PaymentAllocation memory) {\n    revert UnsupportedOperation();\n  }\n\n  /// Unsupported in callable loans.\n  function maxLimit() external pure override returns (uint256) {\n    revert UnsupportedOperation();\n  }\n\n  /// Unsupported in callable loans.\n\n  function setMaxLimit(uint256) external pure override {\n    revert UnsupportedOperation();\n  }\n\n  /// Unsupported ICreditLine method kept for ICreditLine conformance\n\n  function setLimit(uint256) external pure override {\n    revert UnsupportedOperation();\n  }\n\n  /*================================================================================\n  Modifiers\n  ================================================================================*/\n  /// @inheritdoc IVersioned\n  function getVersion() external pure override returns (uint8[3] memory version) {\n    (version[0], version[1], version[2]) = (MAJOR_VERSION, MINOR_VERSION, PATCH_VERSION);\n  }\n\n  modifier onlyLocker() {\n    if (!hasRole(LOCKER_ROLE, msg.sender)) {\n      revert RequiresLockerRole(msg.sender);\n    }\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/callable/CallableLoanAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {SaturatingSub} from \"../../../library/SaturatingSub.sol\";\nimport {ILoan} from \"../../../interfaces/ILoan.sol\";\n\n/**\n * @title CallableLoanAccountant\n * @notice Library for handling allocations of payments and interest calculations\n *         for callable loans.\n * @author Goldfinch\n */\nlibrary CallableLoanAccountant {\n  using SaturatingSub for uint256;\n\n  uint256 internal constant INTEREST_DECIMALS = 1e18;\n  uint256 internal constant SECONDS_PER_DAY = 60 * 60 * 24;\n  uint256 internal constant SECONDS_PER_YEAR = SECONDS_PER_DAY * 365;\n\n  /// @notice Allocate a payment to proper balances according to the payment waterfall.\n  ///         Expected payment waterfall:\n  ///         1. Interest owed\n  ///         2. Principal owed\n  ///         3. Interest accrued\n  ///         4. Interest guaranteed to accrue before the next principal settlement\n  ///         5. Any additional remaining balance\n  /// @param paymentAmount amount to allocate\n  /// @param balance Balance = Remaining principal outstanding\n  /// @param interestOwed interest owed on the credit line up to the last due time\n  /// @param interestAccrued interest accrued between the last due time and the present time\n  /// @param interestRate interest which is guaranteed to accrue between now and\n  ///                      the next time principal is settled\n  /// @param timeUntilNextPrincipalSettlement time at which the next principal payment is due\n  /// @param principalOwed principal owed on the credit line\n  /// @param guaranteedFutureInterestPaid guaranteed future interest which has already been paid\n  /// @return PaymentAllocation payment allocation\n  function allocatePayment(\n    uint256 paymentAmount,\n    uint256 interestOwed,\n    uint256 interestAccrued,\n    uint256 principalOwed,\n    uint256 interestRate,\n    uint256 timeUntilNextPrincipalSettlement,\n    uint256 balance,\n    uint256 guaranteedFutureInterestPaid\n  ) internal pure returns (ILoan.PaymentAllocation memory) {\n    uint256 paymentRemaining = paymentAmount;\n    uint256 owedInterestPayment = Math.min(interestOwed, paymentRemaining);\n    paymentRemaining -= owedInterestPayment;\n\n    uint256 principalPayment = Math.min(principalOwed, paymentRemaining);\n    paymentRemaining -= principalPayment;\n\n    uint256 accruedInterestPayment = Math.min(interestAccrued, paymentRemaining);\n    paymentRemaining -= accruedInterestPayment;\n\n    uint256 balanceRemaining = balance - principalPayment;\n    uint256 guaranteedFutureInterest = calculateInterest({\n      secondsElapsed: timeUntilNextPrincipalSettlement,\n      principal: balanceRemaining,\n      interestApr: interestRate\n    });\n    uint256 guaranteedFutureAccruedInterestPayment = Math.min(\n      guaranteedFutureInterest.saturatingSub(guaranteedFutureInterestPaid),\n      paymentRemaining\n    );\n    paymentRemaining -= guaranteedFutureAccruedInterestPayment;\n\n    uint256 additionalBalancePayment = Math.min(paymentRemaining, balanceRemaining);\n    paymentRemaining -= additionalBalancePayment;\n\n    return\n      ILoan.PaymentAllocation({\n        owedInterestPayment: owedInterestPayment,\n        accruedInterestPayment: accruedInterestPayment + guaranteedFutureAccruedInterestPayment,\n        principalPayment: principalPayment,\n        additionalBalancePayment: additionalBalancePayment,\n        paymentRemaining: paymentRemaining\n      });\n  }\n\n  /**\n   * Calculates flat interest accrued over a period of time given constant principal.\n   */\n  function calculateInterest(\n    uint256 secondsElapsed,\n    uint256 principal,\n    uint256 interestApr\n  ) internal pure returns (uint256) {\n    // More readable, but less gas efficient implementation:\n    // uint256 totalInterestPerYear = (principal * interestApr) / INTEREST_DECIMALS;\n    // interest = (totalInterestPerYear * secondsElapsed) / SECONDS_PER_YEAR;\n\n    return (principal * interestApr * secondsElapsed) / (INTEREST_DECIMALS * SECONDS_PER_YEAR);\n  }\n\n  /**\n   * Calculates interest accrued along with late interest over a given time period given constant principal\n   *\n   */\n  function calculateInterest(\n    uint256 start,\n    uint256 end,\n    uint256 lateFeesStartsAt,\n    uint256 lateFeesEndAt,\n    uint256 principal,\n    uint256 interestApr,\n    uint256 lateInterestAdditionalApr\n  ) internal pure returns (uint256 interest) {\n    if (end <= start) return 0;\n    uint256 totalDuration = end - start;\n    interest = calculateInterest(totalDuration, principal, interestApr);\n    if (lateFeesStartsAt < end && lateFeesEndAt > lateFeesStartsAt) {\n      uint256 lateDuration = Math.min(lateFeesEndAt, end).saturatingSub(\n        Math.max(lateFeesStartsAt, start)\n      );\n      interest += calculateInterest(lateDuration, principal, lateInterestAdditionalApr);\n    }\n  }\n}\n"
    },
    "contracts/protocol/core/callable/CallableLoanConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport {ConfigOptions} from \"../ConfigOptions.sol\";\nimport {IGoldfinchConfig} from \"../../../interfaces/IGoldfinchConfig.sol\";\nimport {IERC20UpgradeableWithDec} from \"../../../interfaces/IERC20UpgradeableWithDec.sol\";\nimport {IPoolTokens} from \"../../../interfaces/IPoolTokens.sol\";\nimport {IGoldfinchFactory} from \"../../../interfaces/IGoldfinchFactory.sol\";\nimport {IGo} from \"../../../interfaces/IGo.sol\";\nimport {ICurveLP} from \"../../../interfaces/ICurveLP.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the IGoldfinchConfig contract\n * @author Goldfinch\n */\n\nlibrary CallableLoanConfigHelper {\n  function getUSDC(IGoldfinchConfig config) internal view returns (IERC20UpgradeableWithDec) {\n    return IERC20UpgradeableWithDec(usdcAddress(config));\n  }\n\n  function getPoolTokens(IGoldfinchConfig config) internal view returns (IPoolTokens) {\n    return IPoolTokens(poolTokensAddress(config));\n  }\n\n  function getGo(IGoldfinchConfig config) internal view returns (IGo) {\n    return IGo(goAddress(config));\n  }\n\n  function poolTokensAddress(IGoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.PoolTokens));\n  }\n\n  function usdcAddress(IGoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.USDC));\n  }\n\n  function reserveAddress(IGoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TreasuryReserve));\n  }\n\n  function protocolAdminAddress(IGoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.ProtocolAdmin));\n  }\n\n  function goAddress(IGoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Go));\n  }\n\n  function getDrawdownPeriodInSeconds(IGoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.DrawdownPeriodInSeconds));\n  }\n\n  function getLatenessGracePeriodInDays(IGoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays));\n  }\n\n  function getReserveDenominator(IGoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.ReserveDenominator));\n  }\n\n  function getWithdrawFeeDenominator(IGoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator));\n  }\n}\n"
    },
    "contracts/protocol/core/callable/structs/CallableCreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\n// import {console2 as console} from \"forge-std/console2.sol\";\n\nimport {ISchedule} from \"../../../../interfaces/ISchedule.sol\";\nimport {IGoldfinchConfig} from \"../../../../interfaces/IGoldfinchConfig.sol\";\nimport {ICallableLoan} from \"../../../../interfaces/ICallableLoan.sol\";\nimport {ICallableLoanErrors} from \"../../../../interfaces/ICallableLoanErrors.sol\";\nimport {ILoan} from \"../../../../interfaces/ILoan.sol\";\n\nimport {SaturatingSub} from \"../../../../library/SaturatingSub.sol\";\nimport {CallableLoanAccountant} from \"../CallableLoanAccountant.sol\";\nimport {LoanPhase} from \"../../../../interfaces/ICallableLoan.sol\";\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n\nimport {Tranche} from \"./Tranche.sol\";\nimport {Waterfall} from \"./Waterfall.sol\";\nimport {PaymentSchedule, PaymentScheduleLogic} from \"../../schedule/PaymentSchedule.sol\";\nimport {CallableLoanConfigHelper} from \"../CallableLoanConfigHelper.sol\";\n\nusing CallableCreditLineLogic for CallableCreditLine global;\n\n/**\n * @notice Handles the accounting of borrower obligations in a callable loan.\n *         Supports\n *         - Deposit of funds before the loan is drawn down.\n *         - Drawdown of funds which should start the loan.\n *         - Repayment of borrowed funds.\n *         - Withdrawal of undrawndown funds which were not used to drawdown the loan.\n *         See \"./notes.md\" for notes on entities in the CallableCreditLine\n */\n\n// TODO: Add notes to fields to describe each (pseudo-natspec)\n/// @param _numLockupPeriods Describes when newly submitted call requests are rolled over\n///                          to the next call request period.\n///                          Number of periods is relative to the end date of a call request period.\n///                          e.g. if _numLockupPeriods is 2, then newly submitted call requests\n///                          in the last two periods of a call request period will be rolled over\n///                          to the next call request period.\nstruct CallableCreditLine {\n  IGoldfinchConfig _config;\n  uint256 _fundableAt;\n  uint256 _limit;\n  uint256 _interestApr;\n  uint256 _lateAdditionalApr;\n  uint256 _numLockupPeriods;\n  uint256 _checkpointedAsOf;\n  uint256 _lastFullPaymentTime;\n  uint256 _totalInterestOwedAtLastCheckpoint;\n  uint256 _totalInterestAccruedAtLastCheckpoint;\n  Waterfall _waterfall;\n  PaymentSchedule _paymentSchedule;\n  uint[20] __padding;\n}\n\nstruct SettledTrancheInfo {\n  uint256 principalDeposited;\n  uint256 principalPaid;\n  uint256 principalReserved;\n  uint256 interestPaid;\n}\n\nlibrary CallableCreditLineLogic {\n  using SaturatingSub for uint256;\n  using CallableLoanConfigHelper for IGoldfinchConfig;\n  using PreviewCallableCreditLineLogic for CallableCreditLine;\n  using CheckpointedCallableCreditLineLogic for CallableCreditLine;\n\n  /*================================================================================\n  Constants\n  ================================================================================*/\n  uint256 internal constant SECONDS_PER_DAY = 60 * 60 * 24;\n\n  /*================================================================================\n  Errors\n  ================================================================================*/\n  function initialize(\n    CallableCreditLine storage cl,\n    IGoldfinchConfig _config,\n    uint256 _fundableAt,\n    uint256 _numLockupPeriods,\n    ISchedule _schedule,\n    uint256 _interestApr,\n    uint256 _lateAdditionalApr,\n    uint256 _limit\n  ) internal {\n    if (cl._checkpointedAsOf != 0) {\n      revert ICallableLoanErrors.CannotReinitialize();\n    }\n    cl._config = _config;\n    cl._limit = _limit;\n    cl._numLockupPeriods = _numLockupPeriods;\n    cl._fundableAt = _fundableAt;\n    // Keep PaymentSchedule's startTime \"0\" until it is set at first drawdown (schedule start).\n    cl._paymentSchedule = PaymentSchedule({schedule: _schedule, startTime: 0});\n    cl._waterfall.initialize(_schedule.totalPrincipalPeriods());\n    cl._interestApr = _interestApr;\n    cl._lateAdditionalApr = _lateAdditionalApr;\n    cl._checkpointedAsOf = block.timestamp;\n\n    // Initialize cumulative/settled values\n    cl._lastFullPaymentTime = block.timestamp;\n    cl._totalInterestAccruedAtLastCheckpoint = 0;\n    cl._totalInterestOwedAtLastCheckpoint = 0;\n  }\n\n  /*================================================================================\n  Main Write Functions\n  ================================================================================*/\n  function pay(\n    CallableCreditLine storage cl,\n    uint256 principalPayment,\n    uint256 interestPayment\n  ) internal {\n    if (cl.loanPhase() != LoanPhase.InProgress) {\n      revert ICallableLoanErrors.InvalidLoanPhase(cl.loanPhase(), LoanPhase.InProgress);\n    }\n\n    cl._waterfall.pay({\n      principalAmount: principalPayment,\n      interestAmount: interestPayment,\n      reserveTranchesIndexStart: cl._paymentSchedule.currentPrincipalPeriod()\n    });\n\n    if (cl.principalOwed() == 0 && cl.interestOwed() == 0) {\n      cl._lastFullPaymentTime = Math.max(block.timestamp, cl._lastFullPaymentTime);\n    }\n\n    for (\n      uint256 periodIndex = cl._paymentSchedule.currentPeriod();\n      periodIndex < cl._paymentSchedule.schedule.periodsInTerm();\n      periodIndex++\n    ) {\n      uint256 periodEndTime = cl._paymentSchedule.periodEndTime(periodIndex);\n\n      if (\n        periodEndTime <= cl.nextPrincipalDueTime() &&\n        cl.principalOwedAt(periodEndTime) == 0 &&\n        cl.interestOwedAt(periodEndTime) == 0\n      ) {\n        cl._lastFullPaymentTime = Math.max(block.timestamp, periodEndTime);\n      } else {\n        // We break out of the loop if we hit a period in which:\n        // 1. There is still principal or interest owed\n        // 2. The period is after the next principal due time\n        break;\n      }\n    }\n  }\n\n  /// @notice Updates accounting for the given drawdown amount.\n  ///         If the loan is in the Funding state, then the loan will be permanently\n  ///         transitioned to the DrawdownPeriod state.\n  function drawdown(CallableCreditLine storage cl, uint256 amount) internal {\n    LoanPhase _loanPhase = cl.loanPhase();\n    if (_loanPhase == LoanPhase.Funding) {\n      cl._paymentSchedule.startAt(block.timestamp);\n      cl._lastFullPaymentTime = block.timestamp;\n      cl._checkpointedAsOf = block.timestamp;\n      _loanPhase = cl.loanPhase();\n      emit DepositsLocked(address(this));\n    }\n    if (_loanPhase != LoanPhase.DrawdownPeriod) {\n      revert ICallableLoanErrors.InvalidLoanPhase(_loanPhase, LoanPhase.DrawdownPeriod);\n    }\n\n    if (amount > cl.totalPrincipalPaid()) {\n      revert ICallableLoanErrors.DrawdownAmountExceedsDeposits(amount, cl.totalPrincipalPaid());\n    }\n    cl._waterfall.drawdown(amount);\n  }\n\n  function submitCall(\n    CallableCreditLine storage cl,\n    uint256 amount\n  )\n    internal\n    returns (\n      uint256 principalDepositedMoved,\n      uint256 principalPaidMoved,\n      uint256 principalReservedMoved,\n      uint256 interestMoved\n    )\n  {\n    if (cl.loanPhase() != LoanPhase.InProgress) {\n      revert ICallableLoanErrors.InvalidLoanPhase(cl.loanPhase(), LoanPhase.InProgress);\n    }\n\n    uint256 activeCallTranche = cl.activeCallSubmissionTrancheIndex();\n    if (activeCallTranche >= cl.uncalledCapitalTrancheIndex()) {\n      revert ICallableLoanErrors.TooLateToSubmitCallRequests();\n    }\n    if (cl.inLockupPeriod()) {\n      revert ICallableLoanErrors.CannotSubmitCallInLockupPeriod();\n    }\n    return cl._waterfall.move(amount, activeCallTranche);\n  }\n\n  function deposit(CallableCreditLine storage cl, uint256 amount) internal {\n    LoanPhase _loanPhase = cl.loanPhase();\n    if (_loanPhase != LoanPhase.Funding) {\n      revert ICallableLoanErrors.InvalidLoanPhase(_loanPhase, LoanPhase.Funding);\n    }\n\n    // !! Make assumption that Funding phase deposits are solely in the uncalled capital tranche.\n    if (\n      amount + cl._waterfall.getTranche(cl.uncalledCapitalTrancheIndex()).principalDeposited() >\n      cl.limit()\n    ) {\n      revert ICallableLoanErrors.DepositExceedsLimit(\n        amount,\n        cl._waterfall.totalPrincipalDeposited(),\n        cl.limit()\n      );\n    }\n    cl._waterfall.deposit(amount);\n  }\n\n  /// Withdraws funds from the specified tranche.\n  function withdraw(CallableCreditLine storage cl, uint256 amount) internal {\n    if (cl.loanPhase() != LoanPhase.Funding) {\n      revert ICallableLoanErrors.InvalidLoanPhase(cl.loanPhase(), LoanPhase.Funding);\n    }\n    cl._waterfall.withdraw(amount);\n  }\n\n  /// Settles payment reserves and updates the checkpointed values.\n  function checkpoint(CallableCreditLine storage cl) internal {\n    if (cl.loanPhase() == LoanPhase.Funding || cl.loanPhase() == LoanPhase.Prefunding) {\n      cl._checkpointedAsOf = block.timestamp;\n      return;\n    }\n\n    cl._lastFullPaymentTime = cl.lastFullPaymentTime();\n\n    /// !! IMPORTANT !!\n    /// The order of these assignments matter!\n    /// Calculating cl.previewTotalInterestOwed() depends on the value of cl._totalInterestAccruedAtLastCheckpoint.\n    /// _totalInterestOwedAtLastCheckpoint must use the ORIGINAL value of _totalInterestAccruedAtLastCheckpoint!\n    /// Otherwise cl.previewTotalInterestOwed() (and thus cl._totalInterestOwedAtLastCheckpoint) will be incorrect.\n    cl._totalInterestOwedAtLastCheckpoint = cl.previewTotalInterestOwed();\n    cl._totalInterestAccruedAtLastCheckpoint = cl.previewTotalInterestAccrued();\n\n    uint256 currentlyActivePrincipalPeriod = cl._paymentSchedule.currentPrincipalPeriod();\n    uint256 activePrincipalPeriodAtLastCheckpoint = cl._paymentSchedule.principalPeriodAt(\n      cl._checkpointedAsOf\n    );\n\n    if (currentlyActivePrincipalPeriod > activePrincipalPeriodAtLastCheckpoint) {\n      cl._waterfall.settleReserves(currentlyActivePrincipalPeriod);\n    }\n\n    cl._checkpointedAsOf = block.timestamp;\n  }\n\n  function setFundableAt(CallableCreditLine storage cl, uint256 newFundableAt) internal {\n    if (cl.loanPhase() != LoanPhase.Prefunding) {\n      revert ICallableLoanErrors.CannotSetFundableAtAfterFundableAt(cl._fundableAt);\n    }\n    cl._fundableAt = newFundableAt;\n  }\n\n  /*================================================================================\n  Main View Functions\n  ================================================================================*/\n  function loanPhase(CallableCreditLine storage cl) internal view returns (LoanPhase) {\n    if (!cl._paymentSchedule.isActive()) {\n      return block.timestamp < cl._fundableAt ? LoanPhase.Prefunding : LoanPhase.Funding;\n    } else if (block.timestamp < cl.termStartTime() + cl._config.getDrawdownPeriodInSeconds()) {\n      return LoanPhase.DrawdownPeriod;\n    } else {\n      return LoanPhase.InProgress;\n    }\n  }\n\n  function numLockupPeriods(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._numLockupPeriods;\n  }\n\n  function uncalledCapitalTrancheIndex(\n    CallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._waterfall.uncalledCapitalTrancheIndex();\n  }\n\n  function principalOwedAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256 returnedPrincipalOwed) {\n    return\n      cl.totalPrincipalOwedAt(timestamp).saturatingSub(\n        cl._waterfall.totalPrincipalPaidAfterSettlementUpToTranche(\n          cl.trancheIndexAtTimestamp(timestamp)\n        )\n      );\n  }\n\n  function principalOwed(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.principalOwedAt(block.timestamp);\n  }\n\n  function totalPrincipalOwed(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.totalPrincipalOwedAt(block.timestamp);\n  }\n\n  function totalPrincipalOwedAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._waterfall.totalPrincipalDepositedUpToTranche(cl.trancheIndexAtTimestamp(timestamp));\n  }\n\n  function totalPrincipalPaid(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.totalPrincipalPaidAt(block.timestamp);\n  }\n\n  /// Calculates total interest owed at a given timestamp.\n  /// IT: Invalid timestamp - timestamp must be after the last checkpoint.\n\n  function totalInterestOwedAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    if (timestamp < cl._checkpointedAsOf) {\n      revert ICallableLoanErrors.InputTimestampBeforeCheckpoint(timestamp, cl._checkpointedAsOf);\n    }\n    // After loan maturity there is no concept of additional interest. All interest accrued\n    // automatically becomes interest owed.\n    if (timestamp > cl.termEndTime()) {\n      return cl.totalInterestAccruedAt(timestamp);\n    }\n\n    uint256 lastInterestDueTimeAtTimestamp = cl._paymentSchedule.previousInterestDueTimeAt(\n      timestamp\n    );\n\n    if (lastInterestDueTimeAtTimestamp <= cl._checkpointedAsOf) {\n      return cl._totalInterestOwedAtLastCheckpoint;\n    } else {\n      return cl.totalInterestAccruedAt(lastInterestDueTimeAtTimestamp);\n    }\n  }\n\n  /// Calculates total interest owed at a given timestamp.\n  /// Assumes that principal outstanding is constant from now until the given `timestamp`.\n  /// @notice IT: Invalid timestamp\n  function interestOwedAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    if (timestamp < cl._checkpointedAsOf) {\n      revert ICallableLoanErrors.InputTimestampBeforeCheckpoint(timestamp, cl._checkpointedAsOf);\n    }\n    return cl.totalInterestOwedAt(timestamp).saturatingSub(cl.totalInterestPaid());\n  }\n\n  /// Interest accrued up to `timestamp`\n  /// PT: Past timestamp - timestamp must be now or in the future.\n  function interestAccruedAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    if (timestamp < block.timestamp) {\n      revert ICallableLoanErrors.InputTimestampInThePast(timestamp);\n    }\n    return\n      cl.totalInterestAccruedAt(timestamp).saturatingSub(\n        Math.max(cl._waterfall.totalInterestPaid(), cl.totalInterestOwedAt(timestamp))\n      );\n  }\n\n  /* Test cases\n   *S = Start B = Buffer Applied At L = Late Fees Start At E = End\n   *SBLE\n   *SBEL\n   *SLEB\n   *SLBE\n   *SELB\n   *SEBL\n\n   *LSEB\n   *LSBE\n   */\n\n  /// Calculates interest accrued over the duration bounded by the `cl._checkpointedAsOf` and `timestamp` timestamps.\n  /// Assumes cl._waterfall.totalPrincipalOutstanding() for the principal balance that the interest is applied to.\n  /// Assumes a checkpoint has occurred.\n  /// If a checkpoint has not occurred, late fees will not account for balance settlement or future payments.\n  /// Late fees should be applied to interest accrued up until block.timestamp.\n  /// Should not account for late fees in interest which will accrue in the future as payments could occur.\n  function totalInterestAccruedAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256 totalInterestAccruedReturned) {\n    if (timestamp < cl._checkpointedAsOf) {\n      revert ICallableLoanErrors.InputTimestampBeforeCheckpoint(timestamp, cl._checkpointedAsOf);\n    }\n\n    if (!cl._paymentSchedule.isActive()) {\n      return 0;\n    }\n\n    totalInterestAccruedReturned = cl._totalInterestAccruedAtLastCheckpoint;\n\n    uint256 firstInterestEndPoint = timestamp;\n    if (cl._checkpointedAsOf < cl.termEndTime()) {\n      firstInterestEndPoint = Math.min(\n        cl._paymentSchedule.nextPrincipalDueTimeAt(cl._checkpointedAsOf),\n        timestamp\n      );\n    }\n\n    // Late fees are already accounted for as of _checkpointedAsOf\n    // Late fees are already accounted for in _totalInterestAccruedAtLastCheckpoint\n    uint256 lateFeesStartAt = Math.max(\n      cl._checkpointedAsOf,\n      cl._paymentSchedule.nextDueTimeAt(cl._lastFullPaymentTime) +\n        (cl._config.getLatenessGracePeriodInDays() * (SECONDS_PER_DAY))\n    );\n\n    // Calculate interest accrued before balances are settled.\n    totalInterestAccruedReturned += CallableLoanAccountant.calculateInterest(\n      cl._checkpointedAsOf,\n      firstInterestEndPoint,\n      lateFeesStartAt,\n      block.timestamp,\n      cl._waterfall.totalPrincipalOutstandingBeforeReserves(),\n      cl._interestApr,\n      cl._lateAdditionalApr\n    );\n\n    if (firstInterestEndPoint < timestamp) {\n      // Calculate interest accrued after balances are settled.\n      totalInterestAccruedReturned += CallableLoanAccountant.calculateInterest(\n        firstInterestEndPoint,\n        timestamp,\n        lateFeesStartAt,\n        block.timestamp,\n        cl._waterfall.totalPrincipalOutstandingAfterReserves(),\n        cl._interestApr,\n        cl._lateAdditionalApr\n      );\n    }\n  }\n\n  function totalPrincipalPaidAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256 principalPaidSum) {\n    principalPaidSum = cl._waterfall.totalPrincipalPaid();\n\n    if (!cl.isActive()) {\n      return principalPaidSum;\n    }\n\n    uint256 trancheIndexAtGivenTimestamp = cl.trancheIndexAtTimestamp(timestamp);\n\n    /// If we entered a new principal period since checkpoint,\n    /// we should settle reserved principal in the uncalled tranche.\n    if (trancheIndexAtGivenTimestamp > cl.trancheIndexAtTimestamp(cl._checkpointedAsOf)) {\n      principalPaidSum += cl\n        ._waterfall\n        .getTranche(cl.uncalledCapitalTrancheIndex())\n        .principalReserved();\n    }\n\n    // Unsettled principal from previous call request periods which will settle.\n    principalPaidSum += cl._waterfall.totalPrincipalReservedUpToTranche(\n      Math.min(trancheIndexAtGivenTimestamp, cl.uncalledCapitalTrancheIndex())\n    );\n  }\n\n  function lastFullPaymentTime(\n    CallableCreditLine storage cl\n  ) internal view returns (uint256 fullPaymentTime) {\n    if (cl.loanPhase() != LoanPhase.InProgress) {\n      // The loan has not begun && paymentSchedule calls will revert.\n      return block.timestamp;\n    }\n\n    fullPaymentTime = cl._lastFullPaymentTime;\n\n    uint256 startPeriod = cl._paymentSchedule.periodAt(\n      Math.max(cl._checkpointedAsOf, fullPaymentTime)\n    );\n    uint256 currentlyActivePeriod = cl._paymentSchedule.currentPeriod();\n\n    for (uint256 periodIndex = startPeriod; periodIndex < currentlyActivePeriod; periodIndex++) {\n      uint256 periodEndTime = cl._paymentSchedule.periodEndTime(periodIndex);\n\n      if (cl.principalOwedAt(periodEndTime) == 0 && cl.interestOwedAt(periodEndTime) == 0) {\n        fullPaymentTime = periodEndTime;\n      } else {\n        // If we hit a period where there is still principal or interest owed, we can stop.\n        break;\n      }\n    }\n  }\n\n  function isLate(CallableCreditLine storage cl) internal view returns (bool) {\n    return cl.isLate(block.timestamp);\n  }\n\n  function isLate(CallableCreditLine storage cl, uint256 timestamp) internal view returns (bool) {\n    if (\n      cl.loanPhase() != LoanPhase.InProgress ||\n      ((cl.principalOwedAt(timestamp) + cl.interestOwedAt(timestamp)) == 0)\n    ) {\n      return false;\n    }\n\n    uint256 oldestUnpaidDueTime = cl._paymentSchedule.nextDueTimeAt(cl.lastFullPaymentTime());\n    return timestamp > oldestUnpaidDueTime;\n  }\n\n  /// Returns the total amount of principal outstanding - after applying reserved principal.\n  function totalPrincipalOutstanding(\n    CallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._waterfall.totalPrincipalOutstandingAfterReserves();\n  }\n\n  /// @notice Returns the tranche index which the given timestamp falls within.\n  /// @return The tranche index will go 1 beyond the max tranche index to represent the \"after loan\" period.\n  ///         This is not to be confused with activeCallSubmissionTrancheIndex, which is the tranche for which\n  ///         current call requests should be submitted to.\n  ///         See notes.md for explanation of relationship between principalPeriod, call request period and tranche.\n  function trancheIndexAtTimestamp(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._paymentSchedule.principalPeriodAt(timestamp);\n  }\n\n  /// Returns the index of the tranche which current call requests should be submitted to.\n  ///See notes.md for explanation of relationship between principalPeriod, call request period and tranche.\n  function activeCallSubmissionTrancheIndex(\n    CallableCreditLine storage cl\n  ) internal view returns (uint256 activeTrancheIndex) {\n    uint256 currentTranche = cl.trancheIndexAtTimestamp(block.timestamp);\n    // Call requests submitted in the current principal period's lockup period are\n    // submitted into the tranche of the NEXT principal period\n    return cl.inLockupPeriod() ? currentTranche + 1 : currentTranche;\n  }\n\n  /// Returns the balances of the given tranche - only settling principal if the tranche should be settled.\n  function getSettledTrancheInfo(\n    CallableCreditLine storage cl,\n    uint256 trancheId\n  ) internal view returns (SettledTrancheInfo memory settledTrancheInfo) {\n    Tranche storage tranche = cl._waterfall.getTranche(trancheId);\n    settledTrancheInfo.interestPaid = tranche.interestPaid();\n    settledTrancheInfo.principalDeposited = tranche.principalDeposited();\n\n    bool useSettledPrincipal;\n\n    if (cl.isActive()) {\n      if (trancheId == cl.uncalledCapitalTrancheIndex()) {\n        uint256 currentlyActivePrincipalPeriod = cl._paymentSchedule.currentPrincipalPeriod();\n        uint256 activePrincipalPeriodAtLastCheckpoint = cl._paymentSchedule.principalPeriodAt(\n          cl._checkpointedAsOf\n        );\n        useSettledPrincipal =\n          currentlyActivePrincipalPeriod > activePrincipalPeriodAtLastCheckpoint;\n      } else {\n        useSettledPrincipal = trancheId < cl._paymentSchedule.currentPrincipalPeriod();\n      }\n    }\n\n    if (useSettledPrincipal) {\n      settledTrancheInfo.principalPaid = tranche.principalPaid() + tranche.principalReserved();\n      settledTrancheInfo.principalReserved = 0;\n    } else {\n      settledTrancheInfo.principalPaid = tranche.principalPaid();\n      settledTrancheInfo.principalReserved = tranche.principalReserved();\n    }\n  }\n\n  function totalInterestPaid(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._waterfall.totalInterestPaid();\n  }\n\n  function totalPrincipalDeposited(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._waterfall.totalPrincipalDeposited();\n  }\n\n  function inLockupPeriod(CallableCreditLine storage cl) internal view returns (bool) {\n    uint256 currentPeriod = cl._paymentSchedule.currentPeriod();\n    uint256 numPeriodsPerPrincipalPeriod = cl._paymentSchedule.periodsPerPrincipalPeriod();\n    return\n      currentPeriod % numPeriodsPerPrincipalPeriod >=\n      numPeriodsPerPrincipalPeriod - cl._numLockupPeriods;\n  }\n\n  /*================================================================================\n  Payment Schedule Proxy Functions\n  ================================================================================*/\n\n  function isActive(CallableCreditLine storage cl) internal view returns (bool) {\n    return cl._paymentSchedule.isActive();\n  }\n\n  function withinPrincipalGracePeriod(CallableCreditLine storage cl) internal view returns (bool) {\n    return cl._paymentSchedule.withinPrincipalGracePeriodAt(block.timestamp);\n  }\n\n  function nextPrincipalDueTime(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.nextPrincipalDueTimeAt(block.timestamp);\n  }\n\n  function nextPrincipalDueTimeAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._paymentSchedule.nextPrincipalDueTimeAt(timestamp);\n  }\n\n  function nextInterestDueTimeAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._paymentSchedule.nextInterestDueTimeAt(timestamp);\n  }\n\n  function nextDueTime(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.nextDueTimeAt(block.timestamp);\n  }\n\n  function nextDueTimeAt(\n    CallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._paymentSchedule.nextDueTimeAt(timestamp);\n  }\n\n  function termStartTime(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._paymentSchedule.termStartTime();\n  }\n\n  function termEndTime(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._paymentSchedule.termEndTime();\n  }\n\n  /*================================================================================\n  Static Struct Config Getters\n  ================================================================================*/\n  function fundableAt(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._fundableAt;\n  }\n\n  function interestApr(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._interestApr;\n  }\n\n  function lateAdditionalApr(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._lateAdditionalApr;\n  }\n\n  function limit(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._limit;\n  }\n\n  function checkpointedAsOf(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._checkpointedAsOf;\n  }\n\n  event DepositsLocked(address indexed loan);\n}\n\n/// @notice Functions which make no assumption that a checkpoint has just occurred.\nlibrary PreviewCallableCreditLineLogic {\n  function previewProportionalInterestAndPrincipalAvailable(\n    CallableCreditLine storage cl,\n    uint256 trancheId,\n    uint256 principal,\n    uint256 feePercent\n  ) internal view returns (uint256, uint256) {\n    Tranche storage tranche = cl._waterfall.getTranche(trancheId);\n    if (cl.loanPhase() != LoanPhase.InProgress) {\n      return tranche.proportionalInterestAndPrincipalAvailable(principal, feePercent);\n    }\n    bool uncalledTrancheAndNeedsSettling = trancheId == cl.uncalledCapitalTrancheIndex() &&\n      cl.trancheIndexAtTimestamp(cl._checkpointedAsOf) <\n      cl._paymentSchedule.currentPrincipalPeriod();\n    bool callRequestTrancheAndNeedsSettling = trancheId < cl.uncalledCapitalTrancheIndex() &&\n      trancheId < cl._paymentSchedule.currentPrincipalPeriod();\n    bool needsSettling = uncalledTrancheAndNeedsSettling || callRequestTrancheAndNeedsSettling;\n\n    return\n      needsSettling\n        ? tranche.proportionalInterestAndPrincipalAvailableAfterReserves(principal, feePercent)\n        : tranche.proportionalInterestAndPrincipalAvailable(principal, feePercent);\n  }\n\n  function previewProportionalCallablePrincipal(\n    CallableCreditLine storage cl,\n    uint256 trancheId,\n    uint256 principalDeposited\n  ) internal view returns (uint256) {\n    uint256 currentlyActivePrincipalPeriod = cl._paymentSchedule.currentPrincipalPeriod();\n    uint256 activePrincipalPeriodAtLastCheckpoint = cl._paymentSchedule.principalPeriodAt(\n      cl._checkpointedAsOf\n    );\n    if (currentlyActivePrincipalPeriod > activePrincipalPeriodAtLastCheckpoint) {\n      return\n        cl._waterfall.getTranche(trancheId).proportionalPrincipalOutstandingAfterReserves(\n          principalDeposited\n        );\n    } else {\n      return\n        cl._waterfall.getTranche(trancheId).proportionalPrincipalOutstandingBeforeReserves(\n          principalDeposited\n        );\n    }\n  }\n\n  /// Returns the total interest owed less total interest paid\n  function previewInterestOwed(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.interestOwedAt(block.timestamp);\n  }\n\n  /// Returns the total interest owed\n  function previewTotalInterestOwed(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.totalInterestOwedAt(block.timestamp);\n  }\n\n  /// Interest accrued up to now minus the max(totalInterestPaid, totalInterestOwedAt)\n  function previewInterestAccrued(CallableCreditLine storage cl) internal view returns (uint256) {\n    return cl.interestAccruedAt(block.timestamp);\n  }\n\n  /// Returns the total interest accrued\n  function previewTotalInterestAccrued(\n    CallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl.totalInterestAccruedAt(block.timestamp);\n  }\n}\n\n/// @notice Functions which assume a checkpoint has just occurred.\nlibrary CheckpointedCallableCreditLineLogic {\n  using SaturatingSub for uint256;\n\n  function totalInterestOwed(CallableCreditLine storage cl) internal view returns (uint256) {\n    assert(cl._checkpointedAsOf == block.timestamp);\n    return cl._totalInterestOwedAtLastCheckpoint;\n  }\n\n  function totalInterestAccrued(CallableCreditLine storage cl) internal view returns (uint256) {\n    assert(cl._checkpointedAsOf == block.timestamp);\n    return cl._totalInterestAccruedAtLastCheckpoint;\n  }\n\n  function proportionalCallablePrincipal(\n    CallableCreditLine storage cl,\n    uint256 trancheId,\n    uint256 principalDeposited\n  ) internal view returns (uint256) {\n    return\n      cl._waterfall.getTranche(trancheId).proportionalPrincipalOutstandingBeforeReserves(\n        principalDeposited\n      );\n  }\n\n  function proportionalInterestAndPrincipalAvailable(\n    CallableCreditLine storage cl,\n    uint256 trancheId,\n    uint256 principal,\n    uint256 feePercent\n  ) internal view returns (uint256, uint256) {\n    assert(cl._checkpointedAsOf == block.timestamp);\n    Tranche storage tranche = cl._waterfall.getTranche(trancheId);\n    return tranche.proportionalInterestAndPrincipalAvailable(principal, feePercent);\n  }\n\n  /// Returns the total interest owed less total interest paid\n  function interestOwed(CallableCreditLine storage cl) internal view returns (uint256) {\n    assert(cl._checkpointedAsOf == block.timestamp);\n    return cl._totalInterestOwedAtLastCheckpoint.saturatingSub(cl.totalInterestPaid());\n  }\n\n  /// Interest accrued up to now minus the max(totalInterestPaid, totalInterestOwedAt)\n  function interestAccrued(CallableCreditLine storage cl) internal view returns (uint256) {\n    assert(cl._checkpointedAsOf == block.timestamp);\n    return\n      cl._totalInterestAccruedAtLastCheckpoint.saturatingSub(\n        Math.max(cl._waterfall.totalInterestPaid(), cl._totalInterestOwedAtLastCheckpoint)\n      );\n  }\n}\n"
    },
    "contracts/protocol/core/callable/structs/StaleCallableCreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport {ISchedule} from \"../../../../interfaces/ISchedule.sol\";\nimport {IGoldfinchConfig} from \"../../../../interfaces/IGoldfinchConfig.sol\";\nimport {LoanPhase} from \"../../../../interfaces/ICallableLoan.sol\";\nimport {Waterfall} from \"./Waterfall.sol\";\n// solhint-disable-next-line max-line-length\nimport {CallableCreditLine, CallableCreditLineLogic, PreviewCallableCreditLineLogic, SettledTrancheInfo} from \"./CallableCreditLine.sol\";\nimport {PaymentSchedule, PaymentScheduleLogic} from \"../../schedule/PaymentSchedule.sol\";\n\nstruct StaleCallableCreditLine {\n  CallableCreditLine _cl;\n}\n\nusing StaleCallableCreditLineLogic for StaleCallableCreditLine global;\n\n/**\n * Simple wrapper around CallableCreditLine which returns a checkpointed\n * CallableCreditLine after checkpoint() is called.\n */\nlibrary StaleCallableCreditLineLogic {\n  using PreviewCallableCreditLineLogic for CallableCreditLine;\n\n  function initialize(\n    StaleCallableCreditLine storage cl,\n    IGoldfinchConfig _config,\n    uint256 _fundableAt,\n    uint256 _numLockupPeriods,\n    ISchedule _schedule,\n    uint256 _interestApr,\n    uint256 _lateAdditionalApr,\n    uint256 _limit\n  ) internal {\n    cl._cl.initialize({\n      _config: _config,\n      _fundableAt: _fundableAt,\n      _numLockupPeriods: _numLockupPeriods,\n      _schedule: _schedule,\n      _interestApr: _interestApr,\n      _lateAdditionalApr: _lateAdditionalApr,\n      _limit: _limit\n    });\n  }\n\n  function checkpoint(\n    StaleCallableCreditLine storage cl\n  ) internal returns (CallableCreditLine storage) {\n    cl._cl.checkpoint();\n    return cl._cl;\n  }\n\n  function schedule(StaleCallableCreditLine storage cl) internal view returns (ISchedule) {\n    return cl._cl._paymentSchedule.schedule;\n  }\n\n  function termStartTime(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.termStartTime();\n  }\n\n  function lastFullPaymentTime(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.lastFullPaymentTime();\n  }\n\n  function fundableAt(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.fundableAt();\n  }\n\n  function limit(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.limit();\n  }\n\n  function interestApr(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.interestApr();\n  }\n\n  function lateAdditionalApr(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.lateAdditionalApr();\n  }\n\n  function isLate(StaleCallableCreditLine storage cl) internal view returns (bool) {\n    return cl._cl.isLate();\n  }\n\n  function loanPhase(StaleCallableCreditLine storage cl) internal view returns (LoanPhase) {\n    return cl._cl.loanPhase();\n  }\n\n  function checkpointedAsOf(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.checkpointedAsOf();\n  }\n\n  function numLockupPeriods(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.numLockupPeriods();\n  }\n\n  function inLockupPeriod(StaleCallableCreditLine storage cl) internal view returns (bool) {\n    return cl._cl.inLockupPeriod();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function interestOwed(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.previewInterestOwed();\n  }\n\n  function principalOwed(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.principalOwed();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function interestOwedAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.interestOwedAt(timestamp);\n  }\n\n  function principalOwedAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.principalOwedAt(timestamp);\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function totalInterestOwedAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.totalInterestOwedAt(timestamp);\n  }\n\n  function totalPrincipalOwedAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.totalPrincipalOwedAt(timestamp);\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function totalInterestOwed(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.previewTotalInterestOwed();\n  }\n\n  function totalPrincipalDeposited(\n    StaleCallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._cl.totalPrincipalDeposited();\n  }\n\n  function totalPrincipalOwed(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.totalPrincipalOwed();\n  }\n\n  function totalPrincipalOutstanding(\n    StaleCallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._cl.totalPrincipalOutstanding();\n  }\n\n  // Currently unused\n  // function totalPrincipalOutstandingBeforeReserves(\n  //   StaleCallableCreditLine storage cl\n  // ) internal view returns (uint256) {\n  //   return cl._cl.totalPrincipalOutstandingBeforeReserves();\n  // }\n\n  function nextInterestDueTimeAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.nextInterestDueTimeAt(timestamp);\n  }\n\n  function nextPrincipalDueTime(\n    StaleCallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._cl.nextPrincipalDueTime();\n  }\n\n  // Currently unused\n  // function nextPrincipalDueTimeAt(\n  //   StaleCallableCreditLine storage cl,\n  //   uint256 timestamp\n  // ) internal view returns (uint256) {\n  //   return cl._cl.nextPrincipalDueTimeAt(timestamp);\n  // }\n\n  function nextDueTimeAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.nextDueTimeAt(timestamp);\n  }\n\n  function nextDueTime(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.nextDueTime();\n  }\n\n  function termEndTime(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.termEndTime();\n  }\n\n  function proportionalCallablePrincipal(\n    StaleCallableCreditLine storage cl,\n    uint256 trancheId,\n    uint256 principalDeposited\n  ) internal view returns (uint256) {\n    return cl._cl.previewProportionalCallablePrincipal(trancheId, principalDeposited);\n  }\n\n  function proportionalInterestAndPrincipalAvailable(\n    StaleCallableCreditLine storage cl,\n    uint256 trancheId,\n    uint256 principal,\n    uint256 feePercent\n  ) internal view returns (uint256, uint256) {\n    return\n      cl._cl.previewProportionalInterestAndPrincipalAvailable({\n        trancheId: trancheId,\n        principal: principal,\n        feePercent: feePercent\n      });\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function totalInterestAccrued(\n    StaleCallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._cl.previewTotalInterestAccrued();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function totalInterestAccruedAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.totalInterestAccruedAt(timestamp);\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function interestAccrued(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.previewInterestAccrued();\n  }\n\n  /// @notice If a checkpoint has not occurred, late fees may be overestimated beyond the next due time.\n  function interestAccruedAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.interestAccruedAt(timestamp);\n  }\n\n  function totalInterestPaid(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.totalInterestPaid();\n  }\n\n  function totalPrincipalPaidAt(\n    StaleCallableCreditLine storage cl,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return cl._cl.totalPrincipalPaidAt(timestamp);\n  }\n\n  function totalPrincipalPaid(StaleCallableCreditLine storage cl) internal view returns (uint256) {\n    return cl._cl.totalPrincipalPaid();\n  }\n\n  function withinPrincipalGracePeriod(\n    StaleCallableCreditLine storage cl\n  ) internal view returns (bool) {\n    return cl._cl.withinPrincipalGracePeriod();\n  }\n\n  function uncalledCapitalTrancheIndex(\n    StaleCallableCreditLine storage cl\n  ) internal view returns (uint256) {\n    return cl._cl.uncalledCapitalTrancheIndex();\n  }\n\n  function getSettledTrancheInfo(\n    StaleCallableCreditLine storage cl,\n    uint256 trancheId\n  ) internal view returns (SettledTrancheInfo memory) {\n    return cl._cl.getSettledTrancheInfo(trancheId);\n  }\n}\n"
    },
    "contracts/protocol/core/callable/structs/Tranche.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\nimport {ICallableLoanErrors} from \"../../../../interfaces/ICallableLoanErrors.sol\";\n\nusing TrancheLogic for Tranche global;\n\n/**\n * @notice Handles the accounting of borrower obligations for a single tranche.\n *         Supports\n *         - Deposit of funds\n *         - Drawdown of funds\n *         - Repayment of borrowed funds\n *         - Withdrawal of paid funds\n *         See \"./notes.md\" for notes on relationships between struct entities in Callable Loans.\n */\n\nstruct Tranche {\n  uint256 _principalDeposited;\n  uint256 _principalPaid;\n  uint256 _principalReserved;\n  uint256 _interestPaid;\n  // TODO: verify that this works for upgradeability\n  uint[28] __padding;\n}\n\nlibrary TrancheLogic {\n  function settleReserves(Tranche storage t) internal {\n    t._principalPaid += t._principalReserved;\n    t._principalReserved = 0;\n  }\n\n  function pay(Tranche storage t, uint256 principalAmount, uint256 interestAmount) internal {\n    assert(t._principalPaid + t._principalReserved + principalAmount <= t.principalDeposited());\n\n    t._interestPaid += interestAmount;\n    t._principalPaid += principalAmount;\n  }\n\n  function reserve(Tranche storage t, uint256 principalAmount, uint256 interestAmount) internal {\n    assert(t._principalPaid + t._principalReserved + principalAmount <= t.principalDeposited());\n\n    t._interestPaid += interestAmount;\n    t._principalReserved += principalAmount;\n  }\n\n  /**\n   * Returns principal outstanding, omitting _principalReserved.\n   */\n  function principalOutstandingBeforeReserves(Tranche storage t) internal view returns (uint256) {\n    return t._principalDeposited - t._principalPaid;\n  }\n\n  /**\n   * Returns principal outstanding, taking into account any _principalReserved.\n   */\n  function principalOutstandingAfterReserves(Tranche storage t) internal view returns (uint256) {\n    return t._principalDeposited - t._principalPaid - t._principalReserved;\n  }\n\n  /**\n   * @notice Only valid for Uncalled Tranche\n   * @notice Withdraw principal from tranche - effectively nullifying the deposit.\n   * @dev reverts if interest has been paid to tranche\n   */\n  function withdraw(Tranche storage t, uint256 principal) internal {\n    assert(t._interestPaid == 0);\n    t._principalDeposited -= principal;\n    t._principalPaid -= principal;\n  }\n\n  /// @notice Only valid for Uncalled Tranche\n  /// @notice remove `principalOutstanding` from the Tranche and its corresponding interest.\n  ///         Take as much reserved principal as possible.\n  ///         Only applicable to the uncalled tranche.\n  function take(\n    Tranche storage t,\n    uint256 principalOutstandingToTake\n  )\n    internal\n    returns (\n      uint256 principalDepositedTaken,\n      uint256 principalPaidTaken,\n      uint256 principalReservedTaken,\n      uint256 interestTaken\n    )\n  {\n    uint tranchePrincipalOutstandingBeforeReserves = t.principalOutstandingBeforeReserves();\n\n    // Sanity check - expect `take` to always be called with valid inputs.\n    assert(principalOutstandingToTake <= tranchePrincipalOutstandingBeforeReserves);\n\n    principalReservedTaken = Math.min(t._principalReserved, principalOutstandingToTake);\n    principalDepositedTaken =\n      (t._principalDeposited * principalOutstandingToTake) /\n      tranchePrincipalOutstandingBeforeReserves;\n    principalPaidTaken = principalDepositedTaken - principalOutstandingToTake;\n\n    // Same formula, real implementation makes sure to multiply before dividing\n    // to reduce precision errors.\n    // interestTaken = (t._interestPaid * principalDepositedTaken) /\n    //                 tranchePrincipalOutstandingBeforeReserves;\n    interestTaken =\n      (t._interestPaid * principalOutstandingToTake) /\n      tranchePrincipalOutstandingBeforeReserves;\n\n    t._principalPaid -= principalPaidTaken;\n    t._interestPaid -= interestTaken;\n    t._principalDeposited -= principalDepositedTaken;\n    t._principalReserved -= principalReservedTaken;\n\n    // Sanity check - accounting math should always bear this out.\n    assert(t._principalDeposited >= t._principalPaid + t._principalReserved);\n  }\n\n  /// @notice Only valid for Uncalled Tranche\n  /// @notice depositing into the tranche for the first time(uncalled)\n  function deposit(Tranche storage t, uint256 principal) internal {\n    // SAFETY but gas cost\n    assert(t._interestPaid == 0);\n    t._principalDeposited += principal;\n    // NOTE: this is so that principalOutstanding = 0 before drawdown\n    t._principalPaid += principal;\n  }\n\n  /// @notice Only valid for Callable Principal Tranches in the context of a call submission\n  function addToBalances(\n    Tranche storage t,\n    uint256 addToPrincipalDeposited,\n    uint256 addToPrincipalPaid,\n    uint256 addToPrincipalReserved,\n    uint256 addToInterestPaid\n  ) internal {\n    t._principalDeposited += addToPrincipalDeposited;\n    t._principalPaid += addToPrincipalPaid;\n    t._principalReserved += addToPrincipalReserved;\n    t._interestPaid += addToInterestPaid;\n  }\n\n  function principalDeposited(Tranche storage t) internal view returns (uint256) {\n    return t._principalDeposited;\n  }\n\n  /// @notice Returns the amount of principal paid to the tranche\n  function principalPaid(Tranche storage t) internal view returns (uint256) {\n    return t._principalPaid;\n  }\n\n  /// @notice Returns the amount of principal paid to the tranche\n  function principalReserved(Tranche storage t) internal view returns (uint256) {\n    return t._principalReserved;\n  }\n\n  /// @notice Returns the amount of principal paid + principal reserved\n  function principalPaidAfterSettlement(Tranche storage t) internal view returns (uint256) {\n    return t._principalPaid + t._principalReserved;\n  }\n\n  function interestPaid(Tranche storage t) internal view returns (uint256) {\n    return t._interestPaid;\n  }\n\n  // returns principal, interest withdrawable\n  function proportionalInterestAndPrincipalAvailableAfterReserves(\n    Tranche storage t,\n    uint256 principalAmount,\n    uint256 feePercent\n  ) internal view returns (uint256, uint256) {\n    return (\n      t.proportionalInterestWithdrawable(principalAmount, feePercent),\n      t.proportionalPrincipalAvailableAfterReserves(principalAmount)\n    );\n  }\n\n  function proportionalInterestAndPrincipalAvailable(\n    Tranche storage t,\n    uint256 principalAmount,\n    uint256 feePercent\n  ) internal view returns (uint256, uint256) {\n    return (\n      t.proportionalInterestWithdrawable(principalAmount, feePercent),\n      t.proportionalPrincipalWithdrawable(principalAmount)\n    );\n  }\n\n  function proportionalPrincipalAvailableAfterReserves(\n    Tranche storage t,\n    uint256 principalAmount\n  ) internal view returns (uint256) {\n    return ((t.principalPaid() + t._principalReserved) * principalAmount) / t.principalDeposited();\n  }\n\n  function proportionalPrincipalWithdrawable(\n    Tranche storage t,\n    uint256 principalAmount\n  ) internal view returns (uint256) {\n    return (t.principalPaid() * principalAmount) / t.principalDeposited();\n  }\n\n  function proportionalPrincipalOutstandingBeforeReserves(\n    Tranche storage t,\n    uint256 principalAmount\n  ) internal view returns (uint256) {\n    return (t.principalOutstandingBeforeReserves() * principalAmount) / t.principalDeposited();\n  }\n\n  function proportionalPrincipalOutstandingAfterReserves(\n    Tranche storage t,\n    uint256 principalAmount\n  ) internal view returns (uint256) {\n    return (t.principalOutstandingAfterReserves() * principalAmount) / t.principalDeposited();\n  }\n\n  function proportionalInterestWithdrawable(\n    Tranche storage t,\n    uint256 principalAmount,\n    uint256 feePercent\n  ) internal view returns (uint256) {\n    return\n      (t.interestPaid() * principalAmount * (100 - feePercent)) / (t.principalDeposited() * 100);\n  }\n\n  /// @notice Only valid for Uncalled Tranche\n  /// Updates the tranche as the result of a drawdown\n  function drawdown(Tranche storage t, uint256 principalAmount) internal {\n    if (principalAmount > t._principalPaid) {\n      revert ICallableLoanErrors.DrawdownAmountExceedsDeposits(principalAmount, t._principalPaid);\n    }\n    t._principalPaid -= principalAmount;\n  }\n}\n"
    },
    "contracts/protocol/core/callable/structs/Waterfall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport {MathUpgradeable as Math} from \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\";\n// import {console2 as console} from \"forge-std/console2.sol\";\nimport {Tranche} from \"./Tranche.sol\";\nimport {ICallableLoanErrors} from \"../../../../interfaces/ICallableLoanErrors.sol\";\n\nusing Math for uint256;\nusing WaterfallLogic for Waterfall global;\n\n/**\n * @notice Handles the accounting of borrower obligations across all tranches.\n *         Supports\n *         - Deposit of funds (into the uncalled tranche)\n *         - Drawdown of funds  (from the uncalled tranche)\n *         - Repayment of borrowed funds - across all tranches\n *         - Withdrawal of paid funds (from the uncalled tranche)\n *         - Summing accounting variables across all tranches\n *         See \"./notes.md\" for notes on relationships between struct entities in Callable Loans.\n */\n\nstruct Waterfall {\n  Tranche[] _tranches;\n  uint[31] __padding;\n}\n\nlibrary WaterfallLogic {\n  /*================================================================================\n  Constants\n  ================================================================================*/\n  uint256 internal constant MINIMUM_WATERFALL_TRANCHES = 2;\n\n  function initialize(Waterfall storage w, uint256 nTranches) internal {\n    if (w._tranches.length != 0) {\n      revert ICallableLoanErrors.CannotReinitialize();\n    }\n    if (nTranches < MINIMUM_WATERFALL_TRANCHES) {\n      revert ICallableLoanErrors.HasInsufficientTranches(nTranches, MINIMUM_WATERFALL_TRANCHES);\n    }\n    for (uint256 i = 0; i < nTranches; i++) {\n      Tranche memory t;\n      w._tranches.push(t);\n    }\n  }\n\n  /*================================================================================\n  Main Write Functions\n  ================================================================================*/\n  /// @notice apply a payment to tranches in the waterfall.\n  ///         The principal payment is applied to the tranches in order of priority\n  ///         The interest payment is applied to the tranches pro rata\n  /// @param principalAmount: the amount of principal to apply to the tranches\n  /// @param interestAmount: the amount of interest to apply to the tranches\n  /// @param reserveTranchesIndexStart: After this index (inclusive), tranches will reserve principal\n  function pay(\n    Waterfall storage w,\n    uint256 principalAmount,\n    uint256 interestAmount,\n    uint256 reserveTranchesIndexStart\n  ) internal {\n    uint256 _totalPrincipalOutstandingBeforeReserves = w.totalPrincipalOutstandingBeforeReserves();\n    if (_totalPrincipalOutstandingBeforeReserves == 0) {\n      revert ICallableLoanErrors.NoBalanceToPay(principalAmount);\n    }\n\n    // assume that tranches are ordered in priority. First is highest priority\n    // NOTE: if we start i at the earliest unpaid tranche/quarter and end at the current quarter\n    //        then we skip iterations that would result in a no-op\n    uint256 principalLeft = principalAmount;\n    uint256 interestLeft = interestAmount;\n    for (uint256 i = 0; i < w._tranches.length - 1; i++) {\n      Tranche storage tranche = w.getTranche(i);\n      uint256 proRataInterestPayment = (interestAmount *\n        tranche.principalOutstandingBeforeReserves()) / _totalPrincipalOutstandingBeforeReserves;\n      uint256 principalPayment = Math.min(\n        tranche.principalOutstandingAfterReserves(),\n        principalLeft\n      );\n      // subtract so that future iterations can't re-allocate a principal payment\n      principalLeft -= principalPayment;\n      interestLeft -= proRataInterestPayment;\n      if (i < reserveTranchesIndexStart) {\n        tranche.pay({principalAmount: principalPayment, interestAmount: proRataInterestPayment});\n      } else {\n        tranche.reserve({\n          principalAmount: principalPayment,\n          interestAmount: proRataInterestPayment\n        });\n      }\n    }\n\n    // Use remaining interest to avoid USDC integer division precision error.\n    {\n      uint256 uncalledCapitalTrancheIdx = w.uncalledCapitalTrancheIndex();\n      Tranche storage uncalledTranche = w.getTranche(uncalledCapitalTrancheIdx);\n      uint256 principalPayment = Math.min(\n        uncalledTranche.principalOutstandingAfterReserves(),\n        principalLeft\n      );\n      principalLeft -= principalPayment;\n      if (uncalledCapitalTrancheIdx < reserveTranchesIndexStart) {\n        uncalledTranche.pay({principalAmount: principalPayment, interestAmount: interestLeft});\n      } else {\n        uncalledTranche.reserve({principalAmount: principalPayment, interestAmount: interestLeft});\n      }\n    }\n\n    // Sanity check - CallableLoanAccountant should have already accounted for any excess payment.\n    assert(principalLeft == 0);\n  }\n\n  function drawdown(Waterfall storage w, uint256 principalAmount) internal {\n    Tranche storage tranche = w.getTranche(w.uncalledCapitalTrancheIndex());\n    tranche.drawdown(principalAmount);\n  }\n\n  /**\n   * @notice Move principal and paid interest from one tranche to another\n   */\n  function move(\n    Waterfall storage w,\n    uint256 principalOutstanding,\n    uint256 toCallRequestPeriodTrancheId\n  )\n    internal\n    returns (\n      uint256 principalDeposited,\n      uint256 principalPaid,\n      uint256 principalReserved,\n      uint256 interestPaid\n    )\n  {\n    (principalDeposited, principalPaid, principalReserved, interestPaid) = w\n      .getTranche(w.uncalledCapitalTrancheIndex())\n      .take(principalOutstanding);\n\n    w.getTranche(toCallRequestPeriodTrancheId).addToBalances(\n      principalDeposited,\n      principalPaid,\n      principalReserved,\n      interestPaid\n    );\n  }\n\n  /**\n   * @notice Withdraw principal from the uncalled tranche.\n            Assumes that the caller is allowed to withdraw.\n   */\n  function withdraw(Waterfall storage w, uint256 principalAmount) internal {\n    return w.getTranche(w.uncalledCapitalTrancheIndex()).withdraw(principalAmount);\n  }\n\n  /**\n   * @notice Deposits principal into the uncalled tranche.\n            Assumes that the caller is allowed to deposit.\n   */\n  function deposit(Waterfall storage w, uint256 principalAmount) internal {\n    return w.getTranche(w.uncalledCapitalTrancheIndex()).deposit(principalAmount);\n  }\n\n  /*================================================================================\n  Main View Functions\n  ================================================================================*/\n  /// Settle all past due tranches as well as the last tranche.\n  /// @param currentTrancheIndex - Index of the current tranche. All previous tranches are due.\n  function settleReserves(Waterfall storage w, uint256 currentTrancheIndex) internal {\n    uint256 uncalledCapitalTrancheIdx = w.uncalledCapitalTrancheIndex();\n    Tranche storage uncalledCapitalTranche = w.getTranche(uncalledCapitalTrancheIdx);\n    uncalledCapitalTranche.settleReserves();\n    for (uint256 i = 0; i < currentTrancheIndex && i < uncalledCapitalTrancheIdx; i++) {\n      w._tranches[i].settleReserves();\n    }\n  }\n\n  function getTranche(\n    Waterfall storage w,\n    uint256 trancheId\n  ) internal view returns (Tranche storage) {\n    return w._tranches[trancheId];\n  }\n\n  function numTranches(Waterfall storage w) internal view returns (uint256) {\n    return w._tranches.length;\n  }\n\n  function uncalledCapitalTrancheIndex(Waterfall storage w) internal view returns (uint256) {\n    return w.numTranches() - 1;\n  }\n\n  /// @notice Returns the total amount of principal paid to all tranches\n  function totalPrincipalDeposited(Waterfall storage w) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < w.numTranches(); i++) {\n      sum += w.getTranche(i).principalDeposited();\n    }\n  }\n\n  /// @notice Returns the total amount of interest paid to all tranches\n  function totalInterestPaid(Waterfall storage w) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < w.numTranches(); i++) {\n      sum += w.getTranche(i).interestPaid();\n    }\n  }\n\n  /// @notice Returns the total amount of principal paid to all tranches\n  function totalPrincipalPaidAfterSettlementUpToTranche(\n    Waterfall storage w,\n    uint256 trancheIndex\n  ) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < trancheIndex; i++) {\n      sum += w.getTranche(i).principalPaidAfterSettlement();\n    }\n  }\n\n  /// @notice Returns the total amount of principal paid to all tranches\n  function totalPrincipalPaid(\n    Waterfall storage w\n  ) internal view returns (uint256 totalPrincipalPaidSum) {\n    for (uint256 i = 0; i < w.numTranches(); i++) {\n      totalPrincipalPaidSum += w.getTranche(i).principalPaid();\n    }\n  }\n\n  function totalPrincipalOutstandingBeforeReserves(\n    Waterfall storage w\n  ) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < w._tranches.length; i++) {\n      sum += w.getTranche(i).principalOutstandingBeforeReserves();\n    }\n  }\n\n  function totalPrincipalOutstandingAfterReserves(\n    Waterfall storage w\n  ) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < w._tranches.length; i++) {\n      sum += w.getTranche(i).principalOutstandingAfterReserves();\n    }\n  }\n\n  /**\n   *\n   * @param trancheIndex Exclusive upper bound (i.e. the tranche at this index is not included)\n   */\n  function totalPrincipalReservedUpToTranche(\n    Waterfall storage w,\n    uint256 trancheIndex\n  ) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < trancheIndex; i++) {\n      sum += w.getTranche(i).principalReserved();\n    }\n  }\n\n  /**\n   *\n   * @param trancheIndex Exclusive upper bound (i.e. the tranche at this index is not included)\n   */\n  function totalPrincipalDepositedUpToTranche(\n    Waterfall storage w,\n    uint256 trancheIndex\n  ) internal view returns (uint256 sum) {\n    for (uint256 i = 0; i < trancheIndex; i++) {\n      sum += w.getTranche(i).principalDeposited();\n    }\n  }\n}\n"
    },
    "contracts/protocol/core/ConfigOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ConfigOptions\n * @notice A central place for enumerating the configurable options of our GoldfinchConfig contract\n * @author Goldfinch\n */\n\nlibrary ConfigOptions {\n  // NEVER EVER CHANGE THE ORDER OF THESE!\n  // You can rename or append. But NEVER change the order.\n  enum Numbers {\n    TransactionLimit,\n    /// @dev: TotalFundsLimit used to represent a total cap on senior pool deposits\n    /// but is now deprecated\n    TotalFundsLimit,\n    MaxUnderwriterLimit,\n    ReserveDenominator,\n    WithdrawFeeDenominator,\n    LatenessGracePeriodInDays,\n    LatenessMaxDays,\n    DrawdownPeriodInSeconds,\n    TransferRestrictionPeriodInDays,\n    LeverageRatio,\n    /// A number in the range [0, 10000] representing basis points of FIDU taken as a fee\n    /// when a withdrawal request is canceled.\n    SeniorPoolWithdrawalCancelationFeeInBps\n  }\n  /// @dev TrustedForwarder is deprecated because we no longer use GSN. CreditDesk\n  ///   and Pool are deprecated because they are no longer used in the protocol.\n  enum Addresses {\n    Pool, // deprecated\n    CreditLineImplementation,\n    GoldfinchFactory,\n    CreditDesk, // deprecated\n    Fidu,\n    USDC,\n    TreasuryReserve,\n    ProtocolAdmin,\n    OneInch,\n    TrustedForwarder, // deprecated\n    CUSDCContract,\n    GoldfinchConfig,\n    PoolTokens,\n    TranchedPoolImplementation, // deprecated\n    SeniorPool,\n    SeniorPoolStrategy,\n    MigratedTranchedPoolImplementation,\n    BorrowerImplementation,\n    GFI,\n    Go,\n    BackerRewards,\n    StakingRewards,\n    FiduUSDCCurveLP,\n    TranchedPoolImplementationRepository,\n    WithdrawalRequestToken,\n    MonthlyScheduleRepo,\n    CallableLoanImplementationRepository\n  }\n}\n"
    },
    "contracts/protocol/core/ERC721NonTransferable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {IERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\";\n\n/**\n * @title A read only ERC721 token\n * @notice A abstract registry of NFTs that only allows reading the NFTs and nothing\n *         else (no minting, transferring, etc). This acts as a \"view\" into some set\n *         of NFTs that may not otherwise adhere to the ERC721 standard.\n * @dev See `Transfer Mechanism` in the following link for the inspiration\n *      behind this class: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md#rationale\n */\n\nabstract contract ERC721NonTransferable is IERC721Upgradeable {\n  // Throw if a mutating function is called\n  error ReadOnly();\n\n  function safeTransferFrom(address, address, uint256) external pure {\n    revert ReadOnly();\n  }\n\n  function transferFrom(address, address, uint256) external pure {\n    revert ReadOnly();\n  }\n\n  function approve(address, uint256) external pure {\n    revert ReadOnly();\n  }\n\n  function getApproved(uint256) external pure returns (address) {\n    revert ReadOnly();\n  }\n\n  function setApprovalForAll(address, bool) external pure {\n    revert ReadOnly();\n  }\n\n  function isApprovedForAll(address, address) external pure returns (bool) {\n    revert ReadOnly();\n  }\n\n  function safeTransferFrom(address, address, uint256, bytes calldata) external pure {\n    revert ReadOnly();\n  }\n}\n"
    },
    "contracts/protocol/core/ERCInterfaces.sol": {
      "content": "pragma solidity ^0.8.16;\n\nlibrary ERCInterfaces {\n  bytes4 internal constant ERC721 = 0x80ac58cd;\n  bytes4 internal constant ERC721_ENUMERABLE = 0x780e9d63;\n  bytes4 internal constant ERC165 = 0x01ffc9a7;\n}\n"
    },
    "contracts/protocol/core/membership/assets/StakedFiduAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../../../../library/FiduConversions.sol\";\nimport {Context} from \"../../../../cake/Context.sol\";\nimport \"../../../../cake/Routing.sol\" as Routing;\n\nimport {CapitalAssetType} from \"../../../../interfaces/ICapitalLedger.sol\";\nimport {IStakingRewards, StakedPositionType} from \"../../../../interfaces/IStakingRewards.sol\";\nimport {ISeniorPool} from \"../../../../interfaces/ISeniorPool.sol\";\n\nusing Routing.Context for Context;\nusing SafeERC20 for IERC20Upgradeable;\n\nlibrary StakedFiduAsset {\n  CapitalAssetType public constant AssetType = CapitalAssetType.ERC721;\n\n  /**\n   * @notice Get the type of asset that this contract adapts.\n   * @return the asset type\n   */\n  function isType(Context context, address assetAddress) internal view returns (bool) {\n    return assetAddress == address(context.stakingRewards());\n  }\n\n  /**\n   * @notice Get whether or not the given asset is valid\n   * @return true if the asset is Fidu type (not CurveLP)\n   */\n  function isValid(Context context, uint256 assetTokenId) internal view returns (bool) {\n    return\n      context.stakingRewards().getPosition(assetTokenId).positionType == StakedPositionType.Fidu;\n  }\n\n  /**\n   * @notice Get the point-in-time USDC equivalent value of the ERC721 asset. This\n   *  specifically attempts to return the \"principle\" or \"at-risk\" USDC value of\n   *  the asset and does not include rewards, interest, or other benefits.\n   * @param context goldfinch context for routing\n   * @param assetTokenId id of the position to evaluate\n   * @return USDC equivalent value\n   */\n  function getUsdcEquivalent(\n    Context context,\n    uint256 assetTokenId\n  ) internal view returns (uint256) {\n    uint256 stakedFiduBalance = context.stakingRewards().stakedBalanceOf(assetTokenId);\n    return FiduConversions.fiduToUsdc(stakedFiduBalance, context.seniorPool().sharePrice());\n  }\n\n  /**\n   * @notice Harvest GFI rewards on a staked fidu token and send them to `owner`.\n   * @param context goldfinch context for routing\n   * @param owner address to send the GFI to\n   * @param assetTokenId id of the position to harvest\n   */\n  function harvest(Context context, address owner, uint256 assetTokenId) internal {\n    // Sends reward to owner (this contract)\n    uint256 reward = context.stakingRewards().getReward(assetTokenId);\n\n    if (reward > 0) {\n      context.gfi().safeTransfer(owner, reward);\n    }\n  }\n}\n"
    },
    "contracts/protocol/core/membership/Epochs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nlibrary Epochs {\n  uint256 internal constant EPOCH_SECONDS = 7 days;\n\n  /**\n   * @notice Get the epoch containing the timestamp `s`\n   * @param s the timestamp\n   * @return corresponding epoch\n   */\n  function fromSeconds(uint256 s) internal pure returns (uint256) {\n    return s / EPOCH_SECONDS;\n  }\n\n  /**\n   * @notice Get the current epoch for the block.timestamp\n   * @return current epoch\n   */\n  function current() internal view returns (uint256) {\n    return fromSeconds(block.timestamp);\n  }\n\n  /**\n   * @notice Get the start timestamp for the current epoch\n   * @return current epoch start timestamp\n   */\n  function currentEpochStartTimestamp() internal view returns (uint256) {\n    return startOf(current());\n  }\n\n  /**\n   * @notice Get the previous epoch given block.timestamp\n   * @return previous epoch\n   */\n  function previous() internal view returns (uint256) {\n    return current() - 1;\n  }\n\n  /**\n   * @notice Get the next epoch given block.timestamp\n   * @return next epoch\n   */\n  function next() internal view returns (uint256) {\n    return current() + 1;\n  }\n\n  /**\n   * @notice Get the Unix timestamp of the start of `epoch`\n   * @param epoch the epoch\n   * @return unix timestamp\n   */\n  function startOf(uint256 epoch) internal pure returns (uint256) {\n    return epoch * EPOCH_SECONDS;\n  }\n}\n"
    },
    "contracts/protocol/core/membership/ERC20Splitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"openzeppelin-contracts-0-8-x/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts-0-8-x/token/ERC20/utils/SafeERC20.sol\";\nimport \"openzeppelin-contracts-0-8-x/utils/Address.sol\";\n\nimport {Context} from \"../../../cake/Context.sol\";\nimport {Base} from \"../../../cake/Base.sol\";\nimport {PausableUpgradeable} from \"../../../cake/Pausable.sol\";\nimport {IERC20Splitter} from \"../../../interfaces/IERC20Splitter.sol\";\n\nusing Address for address;\nusing SafeERC20 for IERC20;\n\ninterface IERC20SplitterReceiver {\n  function onReceive(uint256 amount) external returns (bytes4 retval);\n}\n\n/// @title ERC20Splitter\n/// @author landakram\n/// @notice Splits the ERC20 balance of this contract amongst a list of payees.\n///   Unlike similar splitter contracts, all shares of the balance are distributed\n///   in a single `distribute` transaction. If a payee is a smart contract implementing\n///   `IERC20SplitterReceiver`, then its `onReceive` handler function will be called\n///   after it receives its share.\ncontract ERC20Splitter is IERC20Splitter, Base, PausableUpgradeable {\n  error LengthMismatch();\n  error InvalidReceiver();\n  error IntraBlockDistribution();\n\n  event Distributed(uint256 total);\n  event PayeeAdded(address indexed payee, uint256 share);\n\n  /// @notice The total number of shares in the splitter. A payee's proportion\n  ///   of the split can be calculated as its share / totalShares.\n  uint256 public totalShares;\n\n  /// @notice A list of payees\n  address[] public payees;\n\n  /// @notice Payee shares\n  mapping(address => uint256) public shares;\n\n  /// @notice The ERC20 that is distributed to payees\n  IERC20 public immutable erc20;\n\n  /// @notice The block.timestamp when `distribute` was last called\n  uint256 public lastDistributionAt;\n\n  constructor(Context _context, IERC20 _erc20) Base(_context) {\n    erc20 = _erc20;\n  }\n\n  function initialize() external initializer {\n    __Pausable_init_unchained();\n  }\n\n  function pendingDistributionFor(address payee) external view returns (uint256) {\n    return (erc20.balanceOf(address(this)) * shares[payee]) / totalShares;\n  }\n\n  /// @notice Distribute the current balance to payees. If a payee is a smart contract\n  ///   implementing `IERC20SplitterReceiver`, then its `onReceive` handler function will\n  ///   be called after it receives its share.\n  function distribute() external whenNotPaused {\n    if (lastDistributionAt == block.timestamp) revert IntraBlockDistribution();\n\n    lastDistributionAt = block.timestamp;\n\n    uint256 totalToDistribute = erc20.balanceOf(address(this));\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      address payee = payees[i];\n      uint256 share = shares[payee];\n\n      // Due to integer division, this could result in some dust being left over in the\n      // contract. This is acceptable as the dust will be included in the next distribution.\n      uint256 owedToPayee = (totalToDistribute * share) / totalShares;\n      if (owedToPayee > 0) {\n        erc20.safeTransfer(payee, owedToPayee);\n      }\n\n      if (payee.isContract()) {\n        // Call this even if there is nothing owed to payee. Some recipients may still need\n        // to account for the event.\n        triggerOnReceive(payee, owedToPayee);\n      }\n    }\n\n    emit Distributed(totalToDistribute);\n  }\n\n  function triggerOnReceive(address payee, uint256 amount) internal {\n    try IERC20SplitterReceiver(payee).onReceive(amount) returns (bytes4 retval) {\n      if (retval != IERC20SplitterReceiver.onReceive.selector) revert InvalidReceiver();\n    } catch (bytes memory reason) {\n      // A zero-length reason means the payee does not implement IERC20SplitterReceiver.\n      // In that case, just continue.\n      if (reason.length > 0) {\n        assembly {\n          revert(add(32, reason), mload(reason))\n        }\n      }\n    }\n  }\n\n  /// @notice Replace all current payees with a new set of payees and shares\n  /// @param _payees An array of addresses to receive distributions\n  /// @param _shares An array of shares (ordered by `_payees`) to use for distributions\n  function replacePayees(\n    address[] calldata _payees,\n    uint256[] calldata _shares\n  ) external onlyAdmin {\n    delete payees;\n    _setUpPayees(_payees, _shares);\n  }\n\n  function _setUpPayees(address[] calldata _payees, uint256[] calldata _shares) internal {\n    if (_payees.length != _shares.length) revert LengthMismatch();\n\n    totalShares = 0;\n    payees = _payees;\n\n    for (uint256 i = 0; i < _shares.length; i++) {\n      address payee = _payees[i];\n      uint256 share = _shares[i];\n      shares[payee] = share;\n      totalShares += share;\n      emit PayeeAdded({payee: payee, share: share});\n    }\n  }\n}\n"
    },
    "contracts/protocol/core/membership/FixedMath0x.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable max-line-length\n\npragma solidity ^0.8.16;\n\n// Below is code from 0x's LibFixedMath.sol. Changes:\n// - addition of 0.8-style errors\n// - removal of unused functions\n// - added comments for clarity\n// https://github.com/0xProject/exchange-v3/blob/aae46bef841bfd1cc31028f41793db4fe7197084/contracts/staking/contracts/src/libs/LibFixedMath.sol\n\n/*\n\n  Copyright 2017 Bprotocol Foundation, 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\nlibrary FixedMath0x {\n  /// Thrown when the natural log function is given too large of an argument\n  error LnTooLarge(int256 x);\n  /// Thrown when the natural log would have returned a number outside of \n  error LnNonRealResult(int256 x);\n  /// Thrown when exp is given too large of an argument\n  error ExpTooLarge(int256 x);\n  /// Thrown when an unsigned value is too large to be converted to a signed value\n  error UnsignedValueTooLarge(uint256 x);\n\n  // Base for the fixed point numbers (this is our 1)\n  int256 internal constant FIXED_1 =\n    int256(0x0000000000000000000000000000000080000000000000000000000000000000);\n  // Maximum ln argument (1)\n  int256 private constant LN_MAX_VAL = FIXED_1;\n  // Minimum ln argument. Notice this is related to EXP_MIN_VAL (e ^ -63.875)\n  int256 private constant LN_MIN_VAL =\n    int256(0x0000000000000000000000000000000000000000000000000000000733048c5a);\n  // Maximum exp argument (0)\n  int256 private constant EXP_MAX_VAL = 0;\n  // Minimum exp argument. Notice this is related to LN_MIN_VAL (-63.875)\n  int256 private constant EXP_MIN_VAL =\n    -int256(0x0000000000000000000000000000001ff0000000000000000000000000000000);\n\n  /// @dev Get the natural logarithm of a fixed-point number 0 < `x` <= LN_MAX_VAL\n  function ln(int256 x) internal pure returns (int256 r) {\n    if (x > LN_MAX_VAL) {\n      revert LnTooLarge(x);\n    }\n    if (x <= 0) {\n      revert LnNonRealResult(x);\n    }\n    if (x == FIXED_1) {\n      return 0;\n    }\n    if (x <= LN_MIN_VAL) {\n      return EXP_MIN_VAL;\n    }\n\n    int256 y;\n    int256 z;\n    int256 w;\n\n    // Rewrite the input as a quotient of negative natural exponents and a single residual q, such that 1 < q < 2\n    // For example: log(0.3) = log(e^-1 * e^-0.25 * 1.0471028872385522)\n    //              = 1 - 0.25 - log(1 + 0.0471028872385522)\n    // e ^ -32\n    if (x <= int256(0x00000000000000000000000000000000000000000001c8464f76164760000000)) {\n      r -= int256(0x0000000000000000000000000000001000000000000000000000000000000000); // - 32\n      x =\n        (x * FIXED_1) /\n        int256(0x00000000000000000000000000000000000000000001c8464f76164760000000); // / e ^ -32\n    }\n    // e ^ -16\n    if (x <= int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000)) {\n      r -= int256(0x0000000000000000000000000000000800000000000000000000000000000000); // - 16\n      x =\n        (x * FIXED_1) /\n        int256(0x00000000000000000000000000000000000000f1aaddd7742e90000000000000); // / e ^ -16\n    }\n    // e ^ -8\n    if (x <= int256(0x00000000000000000000000000000000000afe10820813d78000000000000000)) {\n      r -= int256(0x0000000000000000000000000000000400000000000000000000000000000000); // - 8\n      x =\n        (x * FIXED_1) /\n        int256(0x00000000000000000000000000000000000afe10820813d78000000000000000); // / e ^ -8\n    }\n    // e ^ -4\n    if (x <= int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000)) {\n      r -= int256(0x0000000000000000000000000000000200000000000000000000000000000000); // - 4\n      x =\n        (x * FIXED_1) /\n        int256(0x0000000000000000000000000000000002582ab704279ec00000000000000000); // / e ^ -4\n    }\n    // e ^ -2\n    if (x <= int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000)) {\n      r -= int256(0x0000000000000000000000000000000100000000000000000000000000000000); // - 2\n      x =\n        (x * FIXED_1) /\n        int256(0x000000000000000000000000000000001152aaa3bf81cc000000000000000000); // / e ^ -2\n    }\n    // e ^ -1\n    if (x <= int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000)) {\n      r -= int256(0x0000000000000000000000000000000080000000000000000000000000000000); // - 1\n      x =\n        (x * FIXED_1) /\n        int256(0x000000000000000000000000000000002f16ac6c59de70000000000000000000); // / e ^ -1\n    }\n    // e ^ -0.5\n    if (x <= int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000)) {\n      r -= int256(0x0000000000000000000000000000000040000000000000000000000000000000); // - 0.5\n      x =\n        (x * FIXED_1) /\n        int256(0x000000000000000000000000000000004da2cbf1be5828000000000000000000); // / e ^ -0.5\n    }\n    // e ^ -0.25\n    if (x <= int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000)) {\n      r -= int256(0x0000000000000000000000000000000020000000000000000000000000000000); // - 0.25\n      x =\n        (x * FIXED_1) /\n        int256(0x0000000000000000000000000000000063afbe7ab2082c000000000000000000); // / e ^ -0.25\n    }\n    // e ^ -0.125\n    if (x <= int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) {\n      r -= int256(0x0000000000000000000000000000000010000000000000000000000000000000); // - 0.125\n      x =\n        (x * FIXED_1) /\n        int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d); // / e ^ -0.125\n    }\n    // `x` is now our residual in the range of 1 <= x <= 2 (or close enough).\n\n    // Add the taylor series for log(1 + z), where z = x - 1\n    z = y = x - FIXED_1;\n    w = (y * y) / FIXED_1;\n    r += (z * (0x100000000000000000000000000000000 - y)) / 0x100000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\n    r += (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) / 0x200000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\n    r += (z * (0x099999999999999999999999999999999 - y)) / 0x300000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\n    r += (z * (0x092492492492492492492492492492492 - y)) / 0x400000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\n    r += (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) / 0x500000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\n    r += (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) / 0x600000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\n    r += (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) / 0x700000000000000000000000000000000;\n    z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\n    r += (z * (0x088888888888888888888888888888888 - y)) / 0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\n  }\n\n  /// @dev Compute the natural exponent for a fixed-point number EXP_MIN_VAL <= `x` <= 1\n  function exp(int256 x) internal pure returns (int256 r) {\n    if (x < EXP_MIN_VAL) {\n      // Saturate to zero below EXP_MIN_VAL.\n      return 0;\n    }\n    if (x == 0) {\n      return FIXED_1;\n    }\n    if (x > EXP_MAX_VAL) {\n      revert ExpTooLarge(x);\n    }\n\n    // Rewrite the input as a product of natural exponents and a\n    // single residual q, where q is a number of small magnitude.\n    // For example: e^-34.419 = e^(-32 - 2 - 0.25 - 0.125 - 0.044)\n    //              = e^-32 * e^-2 * e^-0.25 * e^-0.125 * e^-0.044\n    //              -> q = -0.044\n\n    // Multiply with the taylor series for e^q\n    int256 y;\n    int256 z;\n    // q = x % 0.125 (the residual)\n    z = y = x % 0x0000000000000000000000000000000010000000000000000000000000000000;\n    z = (z * y) / FIXED_1;\n    r += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x000000000001c638; // add y^16 * (20! / 16!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x000000000000017c; // add y^18 * (20! / 18!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000000000000014; // add y^19 * (20! / 19!)\n    z = (z * y) / FIXED_1;\n    r += z * 0x0000000000000001; // add y^20 * (20! / 20!)\n    r = r / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\n\n    // Multiply with the non-residual terms.\n    x = -x;\n    // e ^ -32\n    if ((x & int256(0x0000000000000000000000000000001000000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x00000000000000000000000000000000000000f1aaddd7742e56d32fb9f99744)) /\n        int256(0x0000000000000000000000000043cbaf42a000812488fc5c220ad7b97bf6e99e); // * e ^ -32\n    }\n    // e ^ -16\n    if ((x & int256(0x0000000000000000000000000000000800000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x00000000000000000000000000000000000afe10820813d65dfe6a33c07f738f)) /\n        int256(0x000000000000000000000000000005d27a9f51c31b7c2f8038212a0574779991); // * e ^ -16\n    }\n    // e ^ -8\n    if ((x & int256(0x0000000000000000000000000000000400000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x0000000000000000000000000000000002582ab704279e8efd15e0265855c47a)) /\n        int256(0x0000000000000000000000000000001b4c902e273a58678d6d3bfdb93db96d02); // * e ^ -8\n    }\n    // e ^ -4\n    if ((x & int256(0x0000000000000000000000000000000200000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x000000000000000000000000000000001152aaa3bf81cb9fdb76eae12d029571)) /\n        int256(0x00000000000000000000000000000003b1cc971a9bb5b9867477440d6d157750); // * e ^ -4\n    }\n    // e ^ -2\n    if ((x & int256(0x0000000000000000000000000000000100000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x000000000000000000000000000000002f16ac6c59de6f8d5d6f63c1482a7c86)) /\n        int256(0x000000000000000000000000000000015bf0a8b1457695355fb8ac404e7a79e3); // * e ^ -2\n    }\n    // e ^ -1\n    if ((x & int256(0x0000000000000000000000000000000080000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x000000000000000000000000000000004da2cbf1be5827f9eb3ad1aa9866ebb3)) /\n        int256(0x00000000000000000000000000000000d3094c70f034de4b96ff7d5b6f99fcd8); // * e ^ -1\n    }\n    // e ^ -0.5\n    if ((x & int256(0x0000000000000000000000000000000040000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x0000000000000000000000000000000063afbe7ab2082ba1a0ae5e4eb1b479dc)) /\n        int256(0x00000000000000000000000000000000a45af1e1f40c333b3de1db4dd55f29a7); // * e ^ -0.5\n    }\n    // e ^ -0.25\n    if ((x & int256(0x0000000000000000000000000000000020000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x0000000000000000000000000000000070f5a893b608861e1f58934f97aea57d)) /\n        int256(0x00000000000000000000000000000000910b022db7ae67ce76b441c27035c6a1); // * e ^ -0.25\n    }\n    // e ^ -0.125\n    if ((x & int256(0x0000000000000000000000000000000010000000000000000000000000000000)) != 0) {\n      r =\n        (r * int256(0x00000000000000000000000000000000783eafef1c0a8f3978c7f81824d62ebf)) /\n        int256(0x0000000000000000000000000000000088415abbe9a76bead8d00cf112e4d4a8); // * e ^ -0.125\n    }\n  }\n}\n"
    },
    "contracts/protocol/core/membership/GFILedger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Context} from \"../../../cake/Context.sol\";\nimport {Base} from \"../../../cake/Base.sol\";\nimport \"../../../cake/Routing.sol\" as Routing;\n\nimport {Arrays} from \"../../../library/Arrays.sol\";\nimport {UserEpochTotals, UserEpochTotal} from \"./UserEpochTotals.sol\";\n\nimport \"../../../interfaces/IGFILedger.sol\";\n\nusing Routing.Context for Context;\nusing UserEpochTotals for UserEpochTotal;\nusing Arrays for uint256[];\nusing SafeERC20 for IERC20Upgradeable;\n\n/**\n * @title GFILedger\n * @notice Track GFI held by owners and ensure the GFI has been accounted for.\n * @author Goldfinch\n */\ncontract GFILedger is IGFILedger, Base {\n  /// Thrown when depositing zero GFI for a position\n  error ZeroDepositAmount();\n  /// Thrown when withdrawing an invalid amount for a position\n  error InvalidWithdrawAmount(uint256 requested, uint256 max);\n  /// Thrown when depositing from address(0)\n  error InvalidOwnerIndex();\n  /// Thrown when querying token supply with an index greater than the supply\n  error IndexGreaterThanTokenSupply();\n\n  // All positions in the ledger\n  mapping(uint256 => Position) public positions;\n\n  // Which positions an address owns\n  mapping(address => uint256[]) private owners;\n\n  /// Total held by each user, while being aware of the deposit epoch\n  mapping(address => UserEpochTotal) private totals;\n\n  // Most recent position minted\n  uint256 private positionCounter;\n\n  /// @notice Construct the contract\n  constructor(Context _context) Base(_context) {}\n\n  /// @inheritdoc IGFILedger\n  function deposit(\n    address owner,\n    uint256 amount\n  ) external onlyOperator(Routing.Keys.MembershipOrchestrator) returns (uint256 positionId) {\n    if (amount == 0) {\n      revert ZeroDepositAmount();\n    }\n    positionId = _mintPosition(owner, amount);\n\n    totals[owner].recordIncrease(amount);\n\n    context.gfi().safeTransferFrom(\n      address(context.membershipOrchestrator()),\n      address(this),\n      amount\n    );\n  }\n\n  /// @inheritdoc IGFILedger\n  function withdraw(\n    uint256 positionId\n  ) external onlyOperator(Routing.Keys.MembershipOrchestrator) returns (uint256) {\n    return _withdraw(positionId);\n  }\n\n  /// @inheritdoc IGFILedger\n  function withdraw(\n    uint256 positionId,\n    uint256 amount\n  ) external onlyOperator(Routing.Keys.MembershipOrchestrator) returns (uint256) {\n    Position memory position = positions[positionId];\n\n    if (amount > position.amount) revert InvalidWithdrawAmount(amount, position.amount);\n    if (amount == position.amount) return _withdraw(positionId);\n\n    positions[positionId].amount -= amount;\n    totals[position.owner].recordDecrease(amount, position.depositTimestamp);\n\n    context.gfi().safeTransfer(position.owner, amount);\n\n    emit GFIWithdrawal({\n      owner: position.owner,\n      positionId: positionId,\n      withdrawnAmount: amount,\n      remainingAmount: position.amount - amount,\n      depositTimestamp: position.depositTimestamp\n    });\n\n    return amount;\n  }\n\n  /// @inheritdoc IGFILedger\n  function balanceOf(address addr) external view returns (uint256 balance) {\n    return owners[addr].length;\n  }\n\n  /// @inheritdoc IGFILedger\n  function ownerOf(uint256 positionId) external view returns (address) {\n    return positions[positionId].owner;\n  }\n\n  /// @inheritdoc IGFILedger\n  function totalsOf(\n    address addr\n  ) external view returns (uint256 eligibleAmount, uint256 totalAmount) {\n    return totals[addr].getTotals();\n  }\n\n  /// @inheritdoc IGFILedger\n  function totalSupply() public view returns (uint256) {\n    return positionCounter;\n  }\n\n  /// @inheritdoc IGFILedger\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\n    if (index >= owners[owner].length) revert InvalidOwnerIndex();\n\n    return owners[owner][index];\n  }\n\n  /// @inheritdoc IGFILedger\n  function tokenByIndex(uint256 index) external view returns (uint256) {\n    if (index >= totalSupply()) revert IndexGreaterThanTokenSupply();\n\n    return index + 1;\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // Private\n\n  function _mintPosition(address owner, uint256 amount) private returns (uint256 positionId) {\n    positionCounter++;\n\n    positionId = positionCounter;\n\n    positions[positionId] = Position({\n      owner: owner,\n      ownedIndex: owners[owner].length,\n      amount: amount,\n      depositTimestamp: block.timestamp\n    });\n\n    owners[owner].push(positionId);\n\n    emit GFIDeposit({owner: owner, positionId: positionId, amount: amount});\n  }\n\n  function _withdraw(uint256 positionId) private returns (uint256) {\n    Position memory position = positions[positionId];\n    delete positions[positionId];\n\n    uint256[] storage ownersList = owners[position.owner];\n    (, bool replaced) = ownersList.reorderingRemove(position.ownedIndex);\n    if (replaced) {\n      positions[ownersList[position.ownedIndex]].ownedIndex = position.ownedIndex;\n    }\n\n    totals[position.owner].recordDecrease(position.amount, position.depositTimestamp);\n\n    context.gfi().safeTransfer(position.owner, position.amount);\n\n    emit GFIWithdrawal({\n      owner: position.owner,\n      positionId: positionId,\n      withdrawnAmount: position.amount,\n      remainingAmount: 0,\n      depositTimestamp: position.depositTimestamp\n    });\n\n    return position.amount;\n  }\n}\n"
    },
    "contracts/protocol/core/membership/MembershipCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\";\n// solhint-disable-next-line max-line-length\nimport {SafeERC20Upgradeable as SafeERC20} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {Context} from \"../../../cake/Context.sol\";\nimport {Base} from \"../../../cake/Base.sol\";\nimport \"../../../cake/Routing.sol\" as Routing;\n\nimport {IERC20SplitterReceiver} from \"./ERC20Splitter.sol\";\nimport {ISeniorPool} from \"../../../interfaces/ISeniorPool.sol\";\nimport {IERC20} from \"../../../interfaces/IERC20.sol\";\nimport {IMembershipCollector} from \"../../../interfaces/IMembershipCollector.sol\";\n\nimport {Epochs} from \"./Epochs.sol\";\n\nusing Routing.Context for Context;\nusing SafeERC20 for IERC20Upgradeable;\n\n/// @title MembershipCollector\n/// @author landakram\n/// @notice Responsible for receiving USDC from ERC20Splitter, using it to acquire fidu, and allocating\n///   it to epochs, where it can be claimed by membership participants.\ncontract MembershipCollector is IERC20SplitterReceiver, IMembershipCollector, Base {\n  error InvalidReceiveCaller();\n\n  /// @notice Emitted once `epoch` has been finalized and will no longer change\n  /// @param epoch epoch that is now finalized\n  /// @param totalRewards all of the rewards in that epoch\n  event EpochFinalized(uint256 indexed epoch, uint256 totalRewards);\n\n  /// @notice The last block.timestamp when epochs were finalized. The last\n  ///   finalized epoch is the most recent epoch that ends before lastCheckpointAt.\n  uint256 public lastCheckpointAt;\n\n  /// @notice A mapping of epochs to fidu reward amounts\n  mapping(uint256 => uint256) public rewardsForEpoch;\n\n  /// @notice The first epoch rewards should be provided in\n  uint256 public immutable firstRewardEpoch;\n\n  constructor(Context _context, uint256 _firstRewardEpoch) Base(_context) {\n    firstRewardEpoch = _firstRewardEpoch;\n  }\n\n  /// @notice Receive handler for the reserve ERC20Splitter. This handler uses the USDC\n  ///   amount it has received to acquire fidu from the senior pool and distribute it across\n  ///   epochs that have elapsed since the last distribution. The fidu rewards are distributed\n  ///   proportionaly across epochs based on their portion of total elapsed time. Once an epoch\n  ///   has passed, it is consider \"finalized\" and no longer considered for future runs of this\n  ///   function.\n  /// @param amount USDC reward amount\n  /// @return The 4 byte selector required by IERC20SplitterReceiver\n  function onReceive(uint256 amount) external returns (bytes4) {\n    if (msg.sender != address(context.reserveSplitter())) revert InvalidReceiveCaller();\n\n    // Acquire fidu\n    uint256 fiduAmount = 0;\n    if (amount > 0) {\n      ISeniorPool seniorPool = context.seniorPool();\n      context.usdc().approve(address(seniorPool), amount);\n      fiduAmount = seniorPool.deposit(amount);\n    }\n\n    // Distribute fidu amount to epochs which have passed since last distribution\n    allocateToElapsedEpochs(fiduAmount);\n\n    return IERC20SplitterReceiver.onReceive.selector;\n  }\n\n  function finalizeEpochs() external onlyOperator(Routing.Keys.MembershipDirector) {\n    if (context.reserveSplitter().lastDistributionAt() == block.timestamp) return;\n\n    context.reserveSplitter().distribute();\n\n    // splitter will then callback to allocateToElapsedEpochs and epochs will be finalized\n  }\n\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256) {\n    /// @dev epochs fall into 6 different cases:\n    ///\n    ///                    first reward epoch     last finalized                     current\n    ///                   |                       |                                   |\n    /// |  epoch a  |  epoch a  |  epoch b  |  epoch c  |  epoch d  |  epoch e  |  epoch f  |  epoch g  |\n    /// |  case 2   |               case 3              |         case 6        |  case 4&5 |   case 1  |\n\n    // Case 1: Epoch is in the future\n    if (epoch > Epochs.current()) return 0;\n\n    // Case 2: Before first reward epoch\n    if (epoch < firstRewardEpoch) return 0;\n\n    // Case 3: Epoch has already been finalized\n    uint256 _lastFinalizedEpoch = lastFinalizedEpoch();\n    if (epoch <= _lastFinalizedEpoch) return rewardsForEpoch[epoch];\n\n    uint256 pendingDistributionUsdc = context.reserveSplitter().pendingDistributionFor(\n      address(this)\n    );\n    uint256 pendingDistribution = context.seniorPool().getNumShares(pendingDistributionUsdc);\n\n    uint256 epochsToFinalize = Epochs.previous() - _lastFinalizedEpoch;\n    if (epochsToFinalize == 0) {\n      // Case 4: Epoch is the current epoch and there are none pending finalization\n      // Epoch is implicitly current: it's not the future and all previous are finalized\n      return rewardsForEpoch[epoch] + pendingDistribution;\n    }\n\n    uint256 checkpointEpoch = Epochs.fromSeconds(lastCheckpointAt);\n\n    uint256 checkpointEpochStart = Epochs.startOf(checkpointEpoch);\n    uint256 secondsAlreadyCheckpointed = 0;\n    if (lastCheckpointAt > checkpointEpochStart) {\n      secondsAlreadyCheckpointed = lastCheckpointAt - checkpointEpochStart;\n    }\n    uint256 durationToFinalize = epochsToFinalize *\n      Epochs.EPOCH_SECONDS -\n      secondsAlreadyCheckpointed;\n\n    uint256 currentEpochElapsedTime = block.timestamp - Epochs.currentEpochStartTimestamp();\n    if (epoch == Epochs.current()) {\n      uint256 currentEpochPendingRewards = (pendingDistribution * currentEpochElapsedTime) /\n        (durationToFinalize + currentEpochElapsedTime);\n\n      // Case 5: Epoch is the current epoch but there are some pending finalization\n      return rewardsForEpoch[epoch] + currentEpochPendingRewards;\n    }\n\n    // Case 6: Epoch is pending finalization\n    // If we're in the checkpoint epoch, account for seconds already checkpointed\n    uint256 unfinalizedEpochSeconds = Epochs.EPOCH_SECONDS;\n    if (epoch == checkpointEpoch) {\n      unfinalizedEpochSeconds = Epochs.EPOCH_SECONDS - secondsAlreadyCheckpointed;\n    }\n\n    uint256 epochPendingRewards = (pendingDistribution * unfinalizedEpochSeconds) /\n      (durationToFinalize + currentEpochElapsedTime);\n\n    return rewardsForEpoch[epoch] + epochPendingRewards;\n  }\n\n  /// @inheritdoc IMembershipCollector\n  function distributeFiduTo(\n    address addr,\n    uint256 amount\n  ) external onlyOperator(Routing.Keys.MembershipDirector) {\n    context.fidu().safeTransfer(addr, amount);\n  }\n\n  function allocateToElapsedEpochs(uint256 fiduAmount) internal {\n    uint256 rewardsRemaining = fiduAmount;\n\n    // Calculate epochs to finalize ([current() - 1] - lastFinalizedEpoch);\n    uint256 currentEpoch = Epochs.current();\n    uint256 priorEpoch = currentEpoch - 1;\n\n    // If running before the first reward epoch, allocate rewards to that epoch\n    if (currentEpoch < firstRewardEpoch) {\n      rewardsForEpoch[firstRewardEpoch] += rewardsRemaining;\n\n      if (lastCheckpointAt == 0) {\n        // Consider all earlier epochs finalized\n        lastCheckpointAt = Epochs.startOf(firstRewardEpoch);\n        emit EpochFinalized({epoch: firstRewardEpoch - 1, totalRewards: 0});\n      }\n\n      return;\n    }\n\n    // If running this function for the first time, distribute everything to the current\n    // epoch, and consider all prior epochs finalized.\n    if (lastCheckpointAt == 0) {\n      lastCheckpointAt = Epochs.startOf(currentEpoch);\n    }\n\n    uint256 _lastFinalizedEpoch = lastFinalizedEpoch();\n    uint256 epochsToFinalize = priorEpoch - _lastFinalizedEpoch;\n\n    // Distribute rewards to epochsToFinalize according to proportion of total elapsed time\n    uint256 totalElapsedTime = block.timestamp - lastCheckpointAt;\n\n    uint256 finalizedEpochRewards = 0;\n\n    if (epochsToFinalize > 0) {\n      for (uint256 i = 1; i <= epochsToFinalize; i++) {\n        uint256 epoch = _lastFinalizedEpoch + i;\n\n        uint256 epochStart = Epochs.startOf(epoch);\n        uint256 unfinalizedEpochSeconds = Epochs.EPOCH_SECONDS;\n        // If the epoch was checkpointed partway through, use the elapsed time since the last checkpoint\n        if (epochStart < lastCheckpointAt) {\n          uint256 secondsAlreadyCheckpointed = lastCheckpointAt - epochStart;\n          unfinalizedEpochSeconds = Epochs.EPOCH_SECONDS - secondsAlreadyCheckpointed;\n        }\n\n        uint256 epochRewards = (fiduAmount * unfinalizedEpochSeconds) / totalElapsedTime;\n\n        rewardsForEpoch[epoch] += epochRewards;\n        finalizedEpochRewards += epochRewards;\n\n        emit EpochFinalized({epoch: epoch, totalRewards: rewardsForEpoch[epoch]});\n      }\n\n      rewardsRemaining -= finalizedEpochRewards;\n    }\n\n    // Distribute remainder of rewards to current epoch\n    rewardsForEpoch[currentEpoch] += rewardsRemaining;\n\n    // Checkpoint\n    lastCheckpointAt = block.timestamp;\n  }\n\n  /// @notice The last epoch whose rewards should be considered finalized and ready to be claimed\n  function lastFinalizedEpoch() public view returns (uint256) {\n    if (lastCheckpointAt < Epochs.EPOCH_SECONDS) return 0;\n    return Epochs.fromSeconds(lastCheckpointAt) - 1;\n  }\n}\n"
    },
    "contracts/protocol/core/membership/MembershipFixedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable var-name-mixedcase\n\npragma solidity ^0.8.16;\n\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\n\nimport {FixedMath0x} from \"./FixedMath0x.sol\";\n\nusing SafeCast for uint256;\n\nlibrary MembershipFixedMath {\n  error InvalidFraction(uint256 n, uint256 d);\n\n  /**\n   * @notice Convert some uint256 fraction `n` numerator / `d` denominator to a fixed-point number `f`.\n   * @param n numerator\n   * @param d denominator\n   * @return fixed-point number\n   */\n  function toFixed(uint256 n, uint256 d) internal pure returns (int256) {\n    if (d.toInt256() < n.toInt256()) revert InvalidFraction(n, d);\n\n    return (n.toInt256() * FixedMath0x.FIXED_1) / int256(d.toInt256());\n  }\n\n  /**\n   * @notice Divide some unsigned int `u` by a fixed point number `f`\n   * @param u unsigned dividend\n   * @param f fixed point divisor, in FIXED_1 units\n   * @return unsigned int quotient\n   */\n  function uintDiv(uint256 u, int256 f) internal pure returns (uint256) {\n    // multiply `u` by FIXED_1 to cancel out the built-in FIXED_1 in f\n    return uint256((u.toInt256() * FixedMath0x.FIXED_1) / f);\n  }\n\n  /**\n   * @notice Multiply some unsigned int `u` by a fixed point number `f`\n   * @param u unsigned multiplicand\n   * @param f fixed point multiplier, in FIXED_1 units\n   * @return unsigned int product\n   */\n  function uintMul(uint256 u, int256 f) internal pure returns (uint256) {\n    // divide the product by FIXED_1 to cancel out the built-in FIXED_1 in f\n    return uint256((u.toInt256() * f) / FixedMath0x.FIXED_1);\n  }\n\n  /// @notice see FixedMath0x\n  function ln(int256 x) internal pure returns (int256 r) {\n    return FixedMath0x.ln(x);\n  }\n\n  /// @notice see FixedMath0x\n  function exp(int256 x) internal pure returns (int256 r) {\n    return FixedMath0x.exp(x);\n  }\n}\n"
    },
    "contracts/protocol/core/membership/MembershipLedger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {IMembershipLedger} from \"../../../interfaces/IMembershipLedger.sol\";\n\nimport {Context} from \"../../../cake/Context.sol\";\nimport {Base} from \"../../../cake/Base.sol\";\nimport \"../../../cake/Routing.sol\" as Routing;\n\nimport {Epochs} from \"./Epochs.sol\";\n\nusing Routing.Context for Context;\n\ncontract MembershipLedger is IMembershipLedger, Base, Initializable {\n  error InvalidAlphaGTE1();\n  error InvalidAlphaUndefined();\n  error InvalidAlphaNumerator();\n  error InvalidAlphaDenominator();\n\n  struct Fraction {\n    uint128 numerator;\n    uint128 denominator;\n  }\n\n  /// rewards allocated to and not yet claimed by an address\n  mapping(address => uint256) private allocatedRewards;\n\n  /// Alpha param for the cobb douglas function\n  Fraction public alpha;\n\n  /// @notice Construct the contract\n  constructor(Context _context) Base(_context) {}\n\n  function initialize() public initializer {\n    alpha = Fraction(1, 2);\n  }\n\n  /// @inheritdoc IMembershipLedger\n  function resetRewards(address addr) external onlyOperator(Routing.Keys.MembershipDirector) {\n    allocatedRewards[addr] = 0;\n  }\n\n  /// @inheritdoc IMembershipLedger\n  function allocateRewardsTo(\n    address addr,\n    uint256 amount\n  ) external onlyOperator(Routing.Keys.MembershipDirector) returns (uint256 rewards) {\n    allocatedRewards[addr] += amount;\n\n    return allocatedRewards[addr];\n  }\n\n  /// @inheritdoc IMembershipLedger\n  function getPendingRewardsFor(address addr) external view returns (uint256 rewards) {\n    return allocatedRewards[addr];\n  }\n\n  /// @notice Set the alpha parameter used in the membership score formula. Alpha is defined as a fraction in\n  ///  the range (0, 1) and constrained to (0,20) / (0,20], so a minimum of 1/20 and a maximum of 19/20.\n  /// @param numerator the numerator of the fraction, must be in the range (0, 20)\n  /// @param denominator the denominator of the fraction, must be in the range (0, 20] and greater than the numerator\n  function setAlpha(uint128 numerator, uint128 denominator) external onlyAdmin {\n    // Numerator in range (0, 20)\n    if (numerator >= 20 || numerator == 0) revert InvalidAlphaNumerator();\n\n    // Denominator in range (0, 20]\n    if (denominator > 20 || denominator == 0) revert InvalidAlphaDenominator();\n\n    // Total fraction less than 1\n    if (numerator >= denominator) revert InvalidAlphaGTE1();\n\n    alpha = Fraction(numerator, denominator);\n  }\n}\n"
    },
    "contracts/protocol/core/membership/MembershipScores.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {SafeCastUpgradeable as SafeCast} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport \"./MembershipFixedMath.sol\";\n\nusing SafeCast for uint256;\n\nlibrary MembershipScores {\n  uint256 internal constant GFI_MANTISSA = 1e18;\n  uint256 internal constant USDC_MANTISSA = 1e6;\n  uint256 internal constant USDC_TO_GFI_MANTISSA = GFI_MANTISSA / USDC_MANTISSA;\n\n  /**\n   * @notice Calculate a membership score given some amount of `gfi` and `capital`, along\n   *  with some  = `alphaNumerator` / `alphaDenominator`.\n   * @param gfi amount of gfi (GFI, 1e18 decimal places)\n   * @param capital amount of capital (USDC, 1e6 decimal places)\n   * @param alphaNumerator alpha param numerator\n   * @param alphaDenominator alpha param denominator\n   * @return membership score with 1e18 decimal places\n   *\n   * @dev  must be in the range [0, 1]\n   */\n  function calculateScore(\n    uint256 gfi,\n    uint256 capital,\n    uint256 alphaNumerator,\n    uint256 alphaDenominator\n  ) internal pure returns (uint256) {\n    // Convert capital to the same base units as GFI\n    capital = capital * USDC_TO_GFI_MANTISSA;\n\n    // Score function is:\n    // gfi^ * capital^(1-)\n    //    = capital * capital^(-) * gfi^\n    //    = capital * (gfi / capital)^\n    //    = capital * (e ^ (ln(gfi / capital))) ^ \n    //    = capital * e ^ ( * ln(gfi / capital))     (1)\n    // or\n    //    = capital / ( 1 / e ^ ( * ln(gfi / capital)))\n    //    = capital / (e ^ ( * ln(gfi / capital)) ^ -1)\n    //    = capital / e ^ ( * -1 * ln(gfi / capital))\n    //    = capital / e ^ ( * ln(capital / gfi))     (2)\n    //\n    // To avoid overflows, use (1) when gfi < capital and\n    // use (2) when capital < gfi\n\n    assert(alphaNumerator <= alphaDenominator);\n\n    // If any side is 0, exit early\n    if (gfi == 0 || capital == 0) return 0;\n\n    // If both sides are equal, we have:\n    // gfi^ * capital^(1-)\n    //    = gfi^ * gfi^(1-)\n    //    = gfi^( + 1 - )     = gfi\n    if (gfi == capital) return gfi;\n\n    bool lessGFIThanCapital = gfi < capital;\n\n    // (gfi / capital) or (capital / gfi), always in range (0, 1)\n    int256 ratio = lessGFIThanCapital\n      ? MembershipFixedMath.toFixed(gfi, capital)\n      : MembershipFixedMath.toFixed(capital, gfi);\n\n    // e ^ ( ln(ratio) *  )\n    int256 exponentiation = MembershipFixedMath.exp(\n      (MembershipFixedMath.ln(ratio) * alphaNumerator.toInt256()) / alphaDenominator.toInt256()\n    );\n\n    if (lessGFIThanCapital) {\n      // capital * e ^ ( * ln(gfi / capital))\n      return MembershipFixedMath.uintMul(capital, exponentiation);\n    }\n\n    // capital / e ^ ( * ln(capital / gfi))\n    return MembershipFixedMath.uintDiv(capital, exponentiation);\n  }\n}\n"
    },
    "contracts/protocol/core/membership/MembershipVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable func-name-mixedcase\n\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\nimport {IMembershipVault, Position} from \"../../../interfaces/IMembershipVault.sol\";\n\nimport {Context} from \"../../../cake/Context.sol\";\nimport {Base} from \"../../../cake/Base.sol\";\nimport \"../../../cake/Routing.sol\" as Routing;\n\nimport {ERC721NonTransferable} from \"../ERC721NonTransferable.sol\";\nimport {Epochs} from \"./Epochs.sol\";\n\nimport {ERCInterfaces} from \"../ERCInterfaces.sol\";\n\nusing Routing.Context for Context;\nusing StringsUpgradeable for uint256;\n\n/**\n * @title MembershipVault\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\n *  are not accounted for until the next epoch for MEV protection.\n * @author Goldfinch\n */\ncontract MembershipVault is\n  IMembershipVault,\n  Base,\n  ERC721NonTransferable,\n  IERC721EnumerableUpgradeable,\n  IERC721MetadataUpgradeable,\n  Initializable\n{\n  /// Thrown when depositing from address(0)\n  error ZeroAddressInvalid();\n  /// Thrown when trying to access tokens from an address with no tokens\n  error NoTokensOwned();\n  /// Thrown when trying to access more than one token for an address\n  error OneTokenPerAddress();\n  /// Thrown when querying token supply with an index greater than the supply\n  error IndexGreaterThanTokenSupply();\n  /// Thrown when checking totals in future epochs\n  error NoTotalsInFutureEpochs();\n  /// Thrown when adjusting holdings in an unsupported way\n  error InvalidHoldingsAdjustment(uint256 eligibleAmount, uint256 nextEpochAmount);\n  /// Thrown when requesting a nonexistant token\n  error NonexistantToken(uint256 tokenId);\n\n  /**\n   * @notice The vault has been checkpointed\n   * @param total how much is stored in the vault at the current block.timestamp\n   */\n  event Checkpoint(uint256 total);\n\n  /// @notice Totals by epoch. totalAmounts is always tracking past epochs, the current\n  ///   epoch, and the next epoch. There are a few cases:\n  ///   1. Checkpointing\n  ///      Noop for the same epoch. Checkpointing occurs before any mutative action\n  ///      so for new epochs, the last-set epoch value (totalAmounts[previousEpoch + 1])\n  ///      is copied to each epoch up to the current epoch + 1\n  ///   2. Increasing\n  ///      Checkpointing already occurred, so current epoch and next epoch\n  ///      are properly set up. Increasing just updates the next epoch value\n  ///   3. Decreasing\n  ///      Checkpointing already occurred like above. Decreasing updates the eligible\n  ///      and next epoch values\n  mapping(uint256 => uint256) private totalAmounts;\n\n  /// @notice last epoch the vault was checkpointed\n  uint256 private checkpointEpoch;\n\n  /// @notice all positions held by the vault\n  mapping(uint256 => Position) private positions;\n\n  /// @notice owners and their position\n  mapping(address => uint256) private owners;\n\n  /// @notice counter tracking most current membership id\n  uint256 private membershipIdsTracker;\n\n  /// @notice base uri for the nft\n  string public baseURI;\n\n  //solhint-disable-next-line no-empty-blocks\n  constructor(Context _context) Base(_context) {}\n\n  function initialize() public initializer {\n    checkpointEpoch = Epochs.current();\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // ERC 721 + Enumerable\n\n  function totalSupply() public view returns (uint256) {\n    return membershipIdsTracker;\n  }\n\n  function ownerOf(uint256 membershipId) external view returns (address owner) {\n    return positions[membershipId].owner;\n  }\n\n  function balanceOf(address owner) external view returns (uint256) {\n    return owners[owner] > 0 ? 1 : 0;\n  }\n\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\n    uint256 membershipId = owners[owner];\n    if (membershipId == 0) revert NoTokensOwned();\n    if (index > 0) revert OneTokenPerAddress();\n\n    return membershipId;\n  }\n\n  function tokenByIndex(uint256 index) external view returns (uint256) {\n    if (index >= totalSupply()) revert IndexGreaterThanTokenSupply();\n\n    return index + 1;\n  }\n\n  function supportsInterface(bytes4 id) external pure override returns (bool) {\n    return (id == ERCInterfaces.ERC721 ||\n      id == ERCInterfaces.ERC721_ENUMERABLE ||\n      id == ERCInterfaces.ERC165);\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // ERC721 Metadata\n\n  /// @inheritdoc IERC721MetadataUpgradeable\n  function name() external pure returns (string memory) {\n    return \"Goldfinch Membership\";\n  }\n\n  /// @inheritdoc IERC721MetadataUpgradeable\n  function symbol() external pure returns (string memory) {\n    return \"GFMEMBER\";\n  }\n\n  /// @inheritdoc IERC721MetadataUpgradeable\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    if (tokenId == 0) revert NonexistantToken(tokenId);\n    if (tokenId > membershipIdsTracker) revert NonexistantToken(tokenId);\n\n    return string(abi.encodePacked(baseURI, tokenId.toString()));\n  }\n\n  /// @notice Set the base uri for the contract\n  function setBaseURI(string calldata uri) external onlyAdmin {\n    baseURI = uri;\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // IMembershipVault\n\n  /// @inheritdoc IMembershipVault\n  function currentValueOwnedBy(address owner) external view override returns (uint256) {\n    Position memory position = positions[owners[owner]];\n    if (Epochs.current() > position.checkpointEpoch) {\n      return position.nextEpochAmount;\n    }\n\n    return position.eligibleAmount;\n  }\n\n  /// @inheritdoc IMembershipVault\n  function currentTotal() external view override returns (uint256) {\n    return totalAtEpoch(Epochs.current());\n  }\n\n  /// @inheritdoc IMembershipVault\n  function totalAtEpoch(uint256 epoch) public view returns (uint256) {\n    if (epoch > Epochs.next()) revert NoTotalsInFutureEpochs();\n\n    if (epoch > checkpointEpoch) {\n      // If querying for an epoch past the checkpoint, always use the next amount. This is the amount\n      // that will become eligible for every epoch after `checkpointEpoch`.\n\n      return totalAmounts[checkpointEpoch + 1];\n    }\n\n    return totalAmounts[epoch];\n  }\n\n  /// @inheritdoc IMembershipVault\n  function positionOwnedBy(address owner) external view returns (Position memory) {\n    return positions[owners[owner]];\n  }\n\n  // @inheritdoc IMembershipVault\n  function adjustHoldings(\n    address owner,\n    uint256 eligibleAmount,\n    uint256 nextEpochAmount\n  ) external onlyOperator(Routing.Keys.MembershipDirector) returns (uint256) {\n    if (nextEpochAmount < eligibleAmount)\n      revert InvalidHoldingsAdjustment(eligibleAmount, nextEpochAmount);\n\n    uint256 membershipId = _fetchOrCreateMembership(owner);\n\n    _checkpoint(owner);\n\n    Position memory position = positions[membershipId];\n\n    positions[membershipId].eligibleAmount = eligibleAmount;\n    positions[membershipId].nextEpochAmount = nextEpochAmount;\n\n    totalAmounts[Epochs.current()] =\n      (totalAmounts[Epochs.current()] - position.eligibleAmount) +\n      eligibleAmount;\n    totalAmounts[Epochs.next()] =\n      (totalAmounts[Epochs.next()] - position.nextEpochAmount) +\n      nextEpochAmount;\n\n    emit AdjustedHoldings({\n      owner: owner,\n      eligibleAmount: eligibleAmount,\n      nextEpochAmount: nextEpochAmount\n    });\n    emit VaultTotalUpdate({\n      eligibleAmount: totalAmounts[Epochs.current()],\n      nextEpochAmount: totalAmounts[Epochs.next()]\n    });\n\n    return membershipId;\n  }\n\n  // @inheritdoc IMembershipVault\n  function checkpoint(address owner) external onlyOperator(Routing.Keys.MembershipDirector) {\n    return _checkpoint(owner);\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // Private\n\n  function _fetchOrCreateMembership(address owner) private returns (uint256) {\n    if (owner == address(0)) revert ZeroAddressInvalid();\n\n    uint256 membershipId = owners[owner];\n    if (membershipId > 0) return membershipId;\n\n    membershipIdsTracker++;\n    membershipId = membershipIdsTracker;\n\n    positions[membershipId].owner = owner;\n    positions[membershipId].createdTimestamp = block.timestamp;\n    positions[membershipId].checkpointEpoch = Epochs.current();\n\n    owners[owner] = membershipId;\n\n    emit Transfer({from: address(0), to: owner, tokenId: membershipId});\n\n    return membershipId;\n  }\n\n  function _checkpoint(address owner) private {\n    uint256 currentEpoch = Epochs.current();\n\n    if (currentEpoch > checkpointEpoch) {\n      // Promote the last checkpoint's nextAmount to all subsequent epochs up to currentEpoch + 1. This\n      // guarantees that total[current] and total[next] are always properly set before any operations\n      // are performed.\n      uint256 lastCheckpointNextAmount = totalAmounts[checkpointEpoch + 1];\n      for (uint256 epoch = checkpointEpoch + 2; epoch <= currentEpoch + 1; epoch++) {\n        totalAmounts[epoch] = lastCheckpointNextAmount;\n      }\n\n      checkpointEpoch = Epochs.current();\n    }\n\n    uint256 membershipId = owners[owner];\n    if (membershipId > 0) {\n      // positionId of 0 means that no position exists. This occurs if checkpoint is called\n      // before a position is created.\n\n      Position memory previousPosition = positions[membershipId];\n\n      // Promote `nextEpochAmount` to `eligibleAmount` if epochs have progressed\n      if (currentEpoch > previousPosition.checkpointEpoch) {\n        positions[membershipId].eligibleAmount = previousPosition.nextEpochAmount;\n        positions[membershipId].checkpointEpoch = Epochs.current();\n      }\n    }\n\n    emit Checkpoint(totalAmounts[Epochs.current()]);\n  }\n}\n"
    },
    "contracts/protocol/core/membership/UserEpochTotals.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.16;\n\nimport {Epochs} from \"./Epochs.sol\";\n\n/// @dev Epoch Awareness\n/// The Membership system relies on an epoch structure to incentivize economic behavior. Deposits\n/// are tracked by epoch and only count toward yield enhancements if they have been present for\n/// an entire epoch. This means positions have a specific lifetime:\n/// 1. Deposit Epoch - Positions are in the membership system but do not count for rewards as they\n///      were not in since the beginning of the epoch. Deposits are externally triggered.\n/// 2. Eligible Epoch - Positions are in the membership system and count for rewards as they have been\n///      present the entire epoch.\n/// 3. Withdrawal Epoch - Positions are no longer in the membership system and forfeit their rewards\n///      for the withdrawal epoch. Rewards are forfeited as the position was not present for the\n///      entire epoch when withdrawn. Withdrawals are externally triggered.\n///\n/// All of these deposits' value is summed together to calculate the yield enhancement. A naive\n/// approach is, for every summation query, iterate over all deposits and check if they were deposited\n/// in the current epoch (so case (1)) or in a previous epoch (so case (2)). This has a high gas\n/// cost, so we use another approach: UserEpochTotal.\n///\n/// UserEpochTotal is the total of the user's deposits as of its lastEpochUpdate- the last epoch that\n/// the total was updated in. For that epoch, it tracks:\n/// 1. Eligible Amount - The sum of deposits that are in their Eligible Epoch for the current epoch\n/// 2. Total Amount - The sum of deposits that will be in their Eligible Epoch for the next epoch\n///\n/// It is not necessary to track previous epochs as deposits in those will already be eligible, or they\n/// will have been withdrawn and already affected the eligible amount.\n///\n/// It is also unnecessary to track future epochs beyond the next one. Any deposit in the current epoch\n/// will become eligible in the next epoch. It is not possible to have a deposit (or withdrawal) take\n/// effect any further in the future.\n\nstruct UserEpochTotal {\n  /// Total amount that will be eligible for membership, after `checkpointedAt` epoch\n  uint256 totalAmount;\n  /// Amount eligible for membership, as of `checkpointedAt` epoch\n  uint256 eligibleAmount;\n  /// Last epoch the total was checkpointed at\n  uint256 checkpointedAt;\n}\n\nlibrary UserEpochTotals {\n  error InvalidDepositEpoch(uint256 epoch);\n\n  /// @notice Record an increase of `amount` in the `total`. This is counted toward the\n  ///  nextAmount as deposits must be present for an entire epoch to be valid.\n  /// @param total storage pointer to the UserEpochTotal\n  /// @param amount amount to increase the total by\n  function recordIncrease(UserEpochTotal storage total, uint256 amount) internal {\n    _checkpoint(total);\n\n    total.totalAmount += amount;\n  }\n\n  /// @notice Record an increase of `amount` instantly based on the time of the deposit.\n  ///  This is counted either:\n  ///  1. To just the totalAmount if the deposit was this epoch\n  ///  2. To both the totalAmount and eligibleAmount if the deposit was before this epoch\n  /// @param total storage pointer to the UserEpochTotal\n  /// @param amount amount to increase the total by\n  function recordInstantIncrease(\n    UserEpochTotal storage total,\n    uint256 amount,\n    uint256 depositTimestamp\n  ) internal {\n    uint256 depositEpoch = Epochs.fromSeconds(depositTimestamp);\n    if (depositEpoch > Epochs.current()) revert InvalidDepositEpoch(depositEpoch);\n\n    _checkpoint(total);\n\n    if (depositEpoch < Epochs.current()) {\n      // If this was deposited earlier, then it also counts towards eligible\n      total.eligibleAmount += amount;\n    }\n\n    total.totalAmount += amount;\n  }\n\n  /// @notice Record a decrease of `amount` in the `total`. Depending on the `depositTimestamp`\n  ///  this will withdraw from the total's currentAmount (if it's withdrawn from an already valid deposit)\n  ///  or from the total's nextAmount (if it's withdrawn from a deposit this epoch).\n  /// @param total storage pointer to the UserEpochTotal\n  /// @param amount amount to decrease the total by\n  /// @param depositTimestamp timestamp of the deposit associated with `amount`\n  function recordDecrease(\n    UserEpochTotal storage total,\n    uint256 amount,\n    uint256 depositTimestamp\n  ) internal {\n    uint256 depositEpoch = Epochs.fromSeconds(depositTimestamp);\n    if (depositEpoch > Epochs.current()) revert InvalidDepositEpoch(depositEpoch);\n\n    _checkpoint(total);\n\n    total.totalAmount -= amount;\n\n    if (depositEpoch < Epochs.current()) {\n      // If this was deposited earlier, then it would have been promoted in _checkpoint and must be removed.\n      total.eligibleAmount -= amount;\n    }\n  }\n\n  /// @notice Get the up-to-date current and next amount for the `_total`. UserEpochTotals\n  ///  may have a lastEpochUpdate of long ago. This returns the current and next amounts as if it had\n  ///  been checkpointed just now.\n  /// @param _total storage pointer to the UserEpochTotal\n  /// @return current the currentAmount of the UserEpochTotal\n  /// @return next the nextAmount of the UserEpochTotal\n  function getTotals(\n    UserEpochTotal storage _total\n  ) internal view returns (uint256 current, uint256 next) {\n    UserEpochTotal memory total = _total;\n    if (Epochs.current() == total.checkpointedAt) {\n      return (total.eligibleAmount, total.totalAmount);\n    }\n\n    return (total.totalAmount, total.totalAmount);\n  }\n\n  //////////////////////////////////////////////////////////////////\n  // Private\n\n  function _checkpoint(UserEpochTotal storage total) private {\n    // Only promote the total amount if we've moved to the next epoch\n    // after the last checkpoint.\n    if (Epochs.current() <= total.checkpointedAt) return;\n\n    total.eligibleAmount = total.totalAmount;\n\n    total.checkpointedAt = Epochs.current();\n  }\n}\n"
    },
    "contracts/protocol/core/PauserPausable08x.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\n\n/**\n * @title PauserPausable\n * @notice Inheriting from OpenZeppelin's Pausable contract, this does small\n *  augmentations to make it work with a PAUSER_ROLE, leveraging the AccessControl contract.\n *  It is meant to be inherited.\n * @author Goldfinch\n */\n\ncontract PauserPausable is AccessControlUpgradeable, PausableUpgradeable {\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __PauserPausable__init() public initializer {\n    __Pausable_init_unchained();\n  }\n\n  /**\n   * @dev Pauses all functions guarded by Pause\n   *\n   * See {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the PAUSER_ROLE.\n   */\n\n  function pause() public onlyPauserRole {\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses the contract\n   *\n   * See {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the Pauser role\n   */\n  function unpause() public onlyPauserRole {\n    _unpause();\n  }\n\n  modifier onlyPauserRole() {\n    /// @dev NA: not authorized\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"NA\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/schedule/PaymentSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\npragma experimental ABIEncoderV2;\n\nimport {ISchedule} from \"../../../interfaces/ISchedule.sol\";\n// import {console2 as console} from \"forge-std/console2.sol\";\n\n/// @notice Convenience struct for passing startTime to all Schedule methods\nstruct PaymentSchedule {\n  ISchedule schedule;\n  uint64 startTime;\n}\n\nusing PaymentScheduleLogic for PaymentSchedule global;\n\nlibrary PaymentScheduleLogic {\n  using PaymentScheduleLogic for PaymentSchedule;\n\n  function startAt(PaymentSchedule storage s, uint256 timestamp) internal {\n    assert(s.startTime == 0);\n    s.startTime = uint64(timestamp);\n  }\n\n  function previousInterestDueTimeAt(\n    PaymentSchedule storage s,\n    uint256 timestamp\n  ) internal view isActiveMod(s) returns (uint256) {\n    return s.schedule.previousInterestDueTimeAt(s.startTime, timestamp);\n  }\n\n  function nextInterestDueTimeAt(\n    PaymentSchedule storage s,\n    uint256 timestamp\n  ) internal view isActiveMod(s) returns (uint256) {\n    return s.schedule.nextInterestDueTimeAt(s.startTime, timestamp);\n  }\n\n  function nextPrincipalDueTimeAt(\n    PaymentSchedule storage s,\n    uint256 timestamp\n  ) internal view isActiveMod(s) returns (uint256) {\n    return s.schedule.nextPrincipalDueTimeAt(s.startTime, timestamp);\n  }\n\n  function principalPeriodAt(\n    PaymentSchedule storage s,\n    uint256 timestamp\n  ) internal view isActiveMod(s) returns (uint256) {\n    return s.schedule.principalPeriodAt(s.startTime, timestamp);\n  }\n\n  function currentPrincipalPeriod(PaymentSchedule storage s) internal view returns (uint256) {\n    return s.principalPeriodAt(block.timestamp);\n  }\n\n  function currentPeriod(PaymentSchedule storage s) internal view returns (uint256) {\n    return s.periodAt(block.timestamp);\n  }\n\n  function periodEndTime(\n    PaymentSchedule storage s,\n    uint256 period\n  ) internal view isActiveMod(s) returns (uint256) {\n    return s.schedule.periodEndTime(s.startTime, period);\n  }\n\n  function periodAt(\n    PaymentSchedule storage s,\n    uint timestamp\n  ) internal view isActiveMod(s) returns (uint256) {\n    return s.schedule.periodAt(s.startTime, timestamp);\n  }\n\n  function isActive(PaymentSchedule storage s) internal view returns (bool) {\n    return s.startTime != 0;\n  }\n\n  function termEndTime(PaymentSchedule storage s) internal view returns (uint256) {\n    return s.isActive() ? s.schedule.termEndTime(s.startTime) : 0;\n  }\n\n  function termStartTime(PaymentSchedule storage s) internal view returns (uint256) {\n    return s.isActive() ? s.schedule.termStartTime(s.startTime) : 0;\n  }\n\n  function periodsPerPrincipalPeriod(PaymentSchedule storage s) internal view returns (uint256) {\n    return s.schedule.periodsPerPrincipalPeriod();\n  }\n\n  function nextDueTimeAt(\n    PaymentSchedule storage s,\n    uint256 timestamp\n  ) internal view returns (uint256) {\n    return s.isActive() ? s.schedule.nextDueTimeAt(s.startTime, timestamp) : 0;\n  }\n\n  function withinPrincipalGracePeriodAt(\n    PaymentSchedule storage s,\n    uint256 timestamp\n  ) internal view returns (bool) {\n    return !s.isActive() || s.schedule.withinPrincipalGracePeriodAt(s.startTime, timestamp);\n  }\n\n  modifier isActiveMod(PaymentSchedule storage s) {\n    // @dev: NA: not active\n    require(s.isActive(), \"NA\");\n    _;\n  }\n}\n"
    },
    "contracts/test/core/IProtocolHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.12;\npragma experimental ABIEncoderV2;\n\nimport {IGoldfinchConfig} from \"../../interfaces/IGoldfinchConfig.sol\";\nimport {IGoldfinchFactory} from \"../../interfaces/IGoldfinchFactory.sol\";\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\nimport {IStakingRewards} from \"../../interfaces/IStakingRewards.sol\";\n\ninterface IProtocolHelper {\n  function gfConfig() external returns (IGoldfinchConfig);\n\n  function fidu() external returns (IERC20);\n\n  function gfi() external returns (IERC20);\n\n  function gfFactory() external returns (IGoldfinchFactory);\n\n  function stakingRewards() external returns (IStakingRewards);\n\n  function usdc() external returns (IERC20);\n}\n"
    },
    "openzeppelin-contracts-0-8-x/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "openzeppelin-contracts-0-8-x/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "openzeppelin-contracts-0-8-x/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-contracts-0-8-x/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}