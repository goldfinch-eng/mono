{
  "language": "Solidity",
  "sources": {
    "contracts/external/FixedPoint.sol": {
      "content": "// solhint-disable\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol\";\n\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For unsigned values:\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n    struct Unsigned {\n        uint256 rawValue;\n    }\n\n    /**\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\n     * @param a uint to convert into a FixedPoint.\n     * @return the converted FixedPoint.\n     */\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if equal, or False.\n     */\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return add(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return sub(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n     * @param a a uint256.\n     * @param b a FixedPoint.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return sub(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as a uint256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.\n     * @param b a uint256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n        if (mod != 0) {\n            return Unsigned(mulFloor.add(1));\n        } else {\n            return Unsigned(mulFloor);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.\n     * @param b a FixedPoint.\n     * @return the product of `a` and `b`.\n     */\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Unsigned(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as a uint256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        return Unsigned(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a uint256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        return div(fromUnscaledUint(a), b);\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n        uint256 divFloor = aScaled.div(b.rawValue);\n        uint256 mod = aScaled.mod(b.rawValue);\n        if (mod != 0) {\n            return Unsigned(divFloor.add(1));\n        } else {\n            return Unsigned(divFloor);\n        }\n    }\n\n    /**\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n        // This creates the possibility of overflow if b is very large.\n        return divCeil(a, fromUnscaledUint(b));\n    }\n\n    /**\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint numerator.\n     * @param b a uint256 denominator.\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n        output = fromUnscaledUint(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\n    // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n    // For signed values:\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n    struct Signed {\n        int256 rawValue;\n    }\n\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n        require(a.rawValue >= 0, \"Negative value provided\");\n        return Unsigned(uint256(a.rawValue));\n    }\n\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n        require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n        return Signed(int256(a.rawValue));\n    }\n\n    /**\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\n     * @param a int to convert into a FixedPoint.Signed.\n     * @return the converted FixedPoint.Signed.\n     */\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n        return Signed(a.mul(SFP_SCALING_FACTOR));\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a int256.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue == fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if equal, or False.\n     */\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue == b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue > fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a > b`, or False.\n     */\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue > b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is greater than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a >= b`, or False.\n     */\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue < fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a < b`, or False.\n     */\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue < b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n        return a.rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\n    }\n\n    /**\n     * @notice Whether `a` is less than or equal to `b`.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return True if `a <= b`, or False.\n     */\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\n    }\n\n    /**\n     * @notice The minimum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the minimum of `a` and `b`.\n     */\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue < b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice The maximum of `a` and `b`.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the maximum of `a` and `b`.\n     */\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return a.rawValue > b.rawValue ? a : b;\n    }\n\n    /**\n     * @notice Adds two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.add(b.rawValue));\n    }\n\n    /**\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the sum of `a` and `b`.\n     */\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return add(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts two `Signed`s, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.sub(b.rawValue));\n    }\n\n    /**\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return sub(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n     * @param a an int256.\n     * @param b a FixedPoint.Signed.\n     * @return the difference of `a` and `b`.\n     */\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return sub(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n        // stored internally as an int256 ~10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n        // would round to 3, but this computation produces the result 2.\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n     * @dev This will \"floor\" the product.\n     * @param a a FixedPoint.Signed.\n     * @param b an int256.\n     * @return the product of `a` and `b`.\n     */\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(mulTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(mulTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n     * @param a a FixedPoint.Signed.\n     * @param b a FixedPoint.Signed.\n     * @return the product of `a` and `b`.\n     */\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\n        return Signed(a.rawValue.mul(b));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        // There are two caveats with this computation:\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n        // 10^41 is stored internally as an int256 10^59.\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        return Signed(a.rawValue.div(b));\n    }\n\n    /**\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n     * @dev This will \"floor\" the quotient.\n     * @param a an int256 numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n        return div(fromUnscaledInt(a), b);\n    }\n\n    /**\n     * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b a FixedPoint denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n        int256 divTowardsZero = aScaled.div(b.rawValue);\n        // Manual mod because SignedSafeMath doesn't support it.\n        int256 mod = aScaled % b.rawValue;\n        if (mod != 0) {\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n            return Signed(divTowardsZero.add(valueToAdd));\n        } else {\n            return Signed(divTowardsZero);\n        }\n    }\n\n    /**\n     * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n     * @param a a FixedPoint numerator.\n     * @param b an int256 denominator.\n     * @return the quotient of `a` divided by `b`.\n     */\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n        // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n        // This creates the possibility of overflow if b is very large.\n        return divAwayFromZero(a, fromUnscaledInt(b));\n    }\n\n    /**\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n     * @dev This will \"floor\" the result.\n     * @param a a FixedPoint.Signed.\n     * @param b a uint256 (negative exponents are not allowed).\n     * @return output is `a` to the power of `b`.\n     */\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n        output = fromUnscaledInt(1);\n        for (uint256 i = 0; i < b; i = i.add(1)) {\n            output = mul(output, a);\n        }\n    }\n}"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/SignedSafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/protocol/core/Accountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./CreditLine.sol\";\nimport \"../../external/FixedPoint.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @title The Accountant\n * @notice Library for handling key financial calculations, such as interest and principal accrual.\n * @author Goldfinch\n */\n\nlibrary Accountant {\n  using SafeMath for uint256;\n  using FixedPoint for FixedPoint.Signed;\n  using FixedPoint for FixedPoint.Unsigned;\n  using FixedPoint for int256;\n  using FixedPoint for uint256;\n\n  // Scaling factor used by FixedPoint.sol. We need this to convert the fixed point raw values back to unscaled\n  uint256 public constant FP_SCALING_FACTOR = 10**18;\n  uint256 public constant INTEREST_DECIMALS = 1e8;\n  uint256 public constant BLOCKS_PER_DAY = 5760;\n  uint256 public constant BLOCKS_PER_YEAR = (BLOCKS_PER_DAY * 365);\n\n  struct PaymentAllocation {\n    uint256 interestPayment;\n    uint256 principalPayment;\n    uint256 additionalBalancePayment;\n  }\n\n  function calculateInterestAndPrincipalAccrued(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 lateFeeGracePeriod\n  ) public view returns (uint256, uint256) {\n    uint256 balance = cl.balance(); // gas optimization\n    uint256 interestAccrued = calculateInterestAccrued(cl, balance, blockNumber, lateFeeGracePeriod);\n    uint256 principalAccrued = calculatePrincipalAccrued(cl, balance, blockNumber);\n    return (interestAccrued, principalAccrued);\n  }\n\n  function calculatePrincipalAccrued(\n    CreditLine cl,\n    uint256 balance,\n    uint256 blockNumber\n  ) public view returns (uint256) {\n    if (blockNumber >= cl.termEndBlock()) {\n      return balance;\n    } else {\n      return 0;\n    }\n  }\n\n  function calculateWritedownFor(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 gracePeriodInDays,\n    uint256 maxDaysLate\n  ) public view returns (uint256, uint256) {\n    FixedPoint.Unsigned memory amountOwedPerDay = calculateAmountOwedForOneDay(cl);\n    if (amountOwedPerDay.isEqual(0)) {\n      return (0, 0);\n    }\n    FixedPoint.Unsigned memory fpGracePeriod = FixedPoint.fromUnscaledUint(gracePeriodInDays);\n    FixedPoint.Unsigned memory daysLate;\n\n    // Excel math: =min(1,max(0,periods_late_in_days-graceperiod_in_days)/MAX_ALLOWED_DAYS_LATE) grace_period = 30,\n    // Before the term end block, we use the interestOwed to calculate the periods late. However, after the loan term\n    // has ended, since the interest is a much smaller fraction of the principal, we cannot reliably use interest to\n    // calculate the periods later.\n    uint256 totalOwed = cl.interestOwed().add(cl.principalOwed());\n    daysLate = FixedPoint.fromUnscaledUint(totalOwed).div(amountOwedPerDay);\n    if (blockNumber > cl.termEndBlock()) {\n      uint256 blocksLate = blockNumber.sub(cl.termEndBlock());\n      daysLate = daysLate.add(FixedPoint.fromUnscaledUint(blocksLate).div(BLOCKS_PER_DAY));\n    }\n\n    FixedPoint.Unsigned memory maxLate = FixedPoint.fromUnscaledUint(maxDaysLate);\n    FixedPoint.Unsigned memory writedownPercent;\n    if (daysLate.isLessThanOrEqual(fpGracePeriod)) {\n      // Within the grace period, we don't have to write down, so assume 0%\n      writedownPercent = FixedPoint.fromUnscaledUint(0);\n    } else {\n      writedownPercent = FixedPoint.min(FixedPoint.fromUnscaledUint(1), (daysLate.sub(fpGracePeriod)).div(maxLate));\n    }\n\n    FixedPoint.Unsigned memory writedownAmount = writedownPercent.mul(cl.balance()).div(FP_SCALING_FACTOR);\n    // This will return a number between 0-100 representing the write down percent with no decimals\n    uint256 unscaledWritedownPercent = writedownPercent.mul(100).div(FP_SCALING_FACTOR).rawValue;\n    return (unscaledWritedownPercent, writedownAmount.rawValue);\n  }\n\n  function calculateAmountOwedForOneDay(CreditLine cl) public view returns (FixedPoint.Unsigned memory) {\n    // Determine theoretical interestOwed for one full day\n    uint256 totalInterestPerYear = cl.balance().mul(cl.interestApr()).div(INTEREST_DECIMALS);\n    FixedPoint.Unsigned memory interestOwed = FixedPoint.fromUnscaledUint(totalInterestPerYear).div(365);\n\n    return interestOwed;\n  }\n\n  function calculateInterestAccrued(\n    CreditLine cl,\n    uint256 balance,\n    uint256 blockNumber,\n    uint256 lateFeeGracePeriodInDays\n  ) public view returns (uint256) {\n    // We use Math.min here to prevent integer overflow (ie. go negative) when calculating\n    // numBlocksElapsed. Typically this shouldn't be possible, because\n    // the interestAccruedAsOfBlock couldn't be *after* the current blockNumber. However, when assessing\n    // we allow this function to be called with a past block number, which raises the possibility\n    // of overflow.\n    // This use of min should not generate incorrect interest calculations, since\n    // this functions purpose is just to normalize balances, and  will be called any time\n    // a balance affecting action takes place (eg. drawdown, repayment, assessment)\n    uint256 interestAccruedAsOfBlock = Math.min(blockNumber, cl.interestAccruedAsOfBlock());\n    uint256 numBlocksElapsed = blockNumber.sub(interestAccruedAsOfBlock);\n    uint256 totalInterestPerYear = balance.mul(cl.interestApr()).div(INTEREST_DECIMALS);\n    uint256 interestOwed = totalInterestPerYear.mul(numBlocksElapsed).div(BLOCKS_PER_YEAR);\n\n    if (lateFeeApplicable(cl, blockNumber, lateFeeGracePeriodInDays)) {\n      uint256 lateFeeInterestPerYear = balance.mul(cl.lateFeeApr()).div(INTEREST_DECIMALS);\n      uint256 additionalLateFeeInterest = lateFeeInterestPerYear.mul(numBlocksElapsed).div(BLOCKS_PER_YEAR);\n      interestOwed = interestOwed.add(additionalLateFeeInterest);\n    }\n\n    return interestOwed;\n  }\n\n  function lateFeeApplicable(\n    CreditLine cl,\n    uint256 blockNumber,\n    uint256 gracePeriodInDays\n  ) public view returns (bool) {\n    uint256 blocksLate = blockNumber.sub(cl.lastFullPaymentBlock());\n    return cl.lateFeeApr() > 0 && blocksLate > gracePeriodInDays.mul(BLOCKS_PER_DAY);\n  }\n\n  function allocatePayment(\n    uint256 paymentAmount,\n    uint256 balance,\n    uint256 interestOwed,\n    uint256 principalOwed\n  ) public pure returns (PaymentAllocation memory) {\n    uint256 paymentRemaining = paymentAmount;\n    uint256 interestPayment = Math.min(interestOwed, paymentRemaining);\n    paymentRemaining = paymentRemaining.sub(interestPayment);\n\n    uint256 principalPayment = Math.min(principalOwed, paymentRemaining);\n    paymentRemaining = paymentRemaining.sub(principalPayment);\n\n    uint256 balanceRemaining = balance.sub(principalPayment);\n    uint256 additionalBalancePayment = Math.min(paymentRemaining, balanceRemaining);\n\n    return\n      PaymentAllocation({\n        interestPayment: interestPayment,\n        principalPayment: principalPayment,\n        additionalBalancePayment: additionalBalancePayment\n      });\n  }\n}\n"
    },
    "contracts/protocol/core/CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./GoldfinchConfig.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\n\n/**\n * @title CreditLine\n * @notice A \"dumb\" state container that represents the agreement between an Underwriter and\n *  the borrower. Includes the terms of the loan, as well as the current accounting state, such as interest owed.\n *  This contract purposefully has essentially no business logic. Really just setters and getters.\n * @author Goldfinch\n */\n\n// solhint-disable-next-line max-states-count\ncontract CreditLine is BaseUpgradeablePausable {\n  // Credit line terms\n  address public borrower;\n  address public underwriter;\n  uint256 public limit;\n  uint256 public interestApr;\n  uint256 public paymentPeriodInDays;\n  uint256 public termInDays;\n  uint256 public lateFeeApr;\n\n  // Accounting variables\n  uint256 public balance;\n  uint256 public interestOwed;\n  uint256 public principalOwed;\n  uint256 public termEndBlock;\n  uint256 public nextDueBlock;\n  uint256 public interestAccruedAsOfBlock;\n  uint256 public writedownAmount;\n  uint256 public lastFullPaymentBlock;\n\n  function initialize(\n    address owner,\n    address _borrower,\n    address _underwriter,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public initializer {\n    require(owner != address(0) && _borrower != address(0) && _underwriter != address(0), \"Zero address passed in\");\n    __BaseUpgradeablePausable__init(owner);\n    borrower = _borrower;\n    underwriter = _underwriter;\n    limit = _limit;\n    interestApr = _interestApr;\n    paymentPeriodInDays = _paymentPeriodInDays;\n    termInDays = _termInDays;\n    lateFeeApr = _lateFeeApr;\n    interestAccruedAsOfBlock = block.number;\n  }\n\n  function setTermEndBlock(uint256 newTermEndBlock) external onlyAdmin {\n    termEndBlock = newTermEndBlock;\n  }\n\n  function setNextDueBlock(uint256 newNextDueBlock) external onlyAdmin {\n    nextDueBlock = newNextDueBlock;\n  }\n\n  function setBalance(uint256 newBalance) external onlyAdmin {\n    balance = newBalance;\n  }\n\n  function setInterestOwed(uint256 newInterestOwed) external onlyAdmin {\n    interestOwed = newInterestOwed;\n  }\n\n  function setPrincipalOwed(uint256 newPrincipalOwed) external onlyAdmin {\n    principalOwed = newPrincipalOwed;\n  }\n\n  function setInterestAccruedAsOfBlock(uint256 newInterestAccruedAsOfBlock) external onlyAdmin {\n    interestAccruedAsOfBlock = newInterestAccruedAsOfBlock;\n  }\n\n  function setWritedownAmount(uint256 newWritedownAmount) external onlyAdmin {\n    writedownAmount = newWritedownAmount;\n  }\n\n  function setLastFullPaymentBlock(uint256 newLastFullPaymentBlock) external onlyAdmin {\n    lastFullPaymentBlock = newLastFullPaymentBlock;\n  }\n\n  function setLateFeeApr(uint256 newLateFeeApr) external onlyAdmin {\n    lateFeeApr = newLateFeeApr;\n  }\n\n  function setLimit(uint256 newAmount) external onlyAdminOrUnderwriter {\n    limit = newAmount;\n  }\n\n  function authorizePool(address configAddress) external onlyAdmin {\n    GoldfinchConfig config = GoldfinchConfig(configAddress);\n    address poolAddress = config.getAddress(uint256(ConfigOptions.Addresses.Pool));\n    address usdcAddress = config.getAddress(uint256(ConfigOptions.Addresses.USDC));\n    // Approve the pool for an infinite amount\n    bool success = IERC20withDec(usdcAddress).approve(poolAddress, uint256(-1));\n    require(success, \"Failed to approve USDC\");\n  }\n\n  modifier onlyAdminOrUnderwriter() {\n    require(isAdmin() || _msgSender() == underwriter, \"Restricted to owner or underwriter\");\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/protocol/core/GoldfinchConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigOptions.sol\";\n\n/**\n * @title GoldfinchConfig\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. For example, the TransactionLimit, or the PoolAddress. These config vars\n *  are enumerated in the `ConfigOptions` library, and can only be changed by admins of the protocol.\n * @author Goldfinch\n */\n\ncontract GoldfinchConfig is BaseUpgradeablePausable {\n  mapping(uint256 => address) public addresses;\n  mapping(uint256 => uint256) public numbers;\n\n  event AddressUpdated(address owner, uint256 index, address oldValue, address newValue);\n  event NumberUpdated(address owner, uint256 index, uint256 oldValue, uint256 newValue);\n\n  function initialize(address owner) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n  }\n\n  function setAddress(uint256 addressIndex, address newAddress) public onlyAdmin {\n    require(addresses[addressIndex] == address(0), \"Address has already been initialized\");\n\n    emit AddressUpdated(msg.sender, addressIndex, addresses[addressIndex], newAddress);\n    addresses[addressIndex] = newAddress;\n  }\n\n  function setNumber(uint256 index, uint256 newNumber) public onlyAdmin {\n    emit NumberUpdated(msg.sender, index, numbers[index], newNumber);\n    numbers[index] = newNumber;\n  }\n\n  function setTreasuryReserve(address newTreasuryReserve) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.TreasuryReserve);\n    emit AddressUpdated(msg.sender, key, addresses[key], newTreasuryReserve);\n    addresses[key] = newTreasuryReserve;\n  }\n\n  /*\n    Using custom getters incase we want to change underlying implementation later,\n    or add checks or validations later on.\n  */\n  function getAddress(uint256 addressKey) public view returns (address) {\n    return addresses[addressKey];\n  }\n\n  function getNumber(uint256 number) public view returns (uint256) {\n    return numbers[number];\n  }\n}\n"
    },
    "contracts/protocol/core/BaseUpgradeablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\nimport \"./PauserPausable.sol\";\n\n/**\n * @title BaseUpgradeablePausable contract\n * @notice This is our Base contract that most other contracts inherit from. It includes many standard\n *  useful abilities like ugpradeability, pausability, access control, and re-entrancy guards.\n * @author Goldfinch\n */\n\ncontract BaseUpgradeablePausable is\n  Initializable,\n  AccessControlUpgradeSafe,\n  PauserPausable,\n  ReentrancyGuardUpgradeSafe\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  using SafeMath for uint256;\n  // Pre-reserving a few slots in the base contract in case we need to add things in the future.\n  // This does not actually take up gas cost or storage cost, but it does reserve the storage slots.\n  // See OpenZeppelin's use of this pattern here:\n  // https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/GSN/Context.sol#L37\n  uint256[50] private __gap1;\n  uint256[50] private __gap2;\n  uint256[50] private __gap3;\n  uint256[50] private __gap4;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __BaseUpgradeablePausable__init(address owner) public initializer {\n    require(owner != address(0), \"Owner cannot be the zero address\");\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/interfaces/IERC20withDec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\n/*\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\n*/\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20withDec is IERC20 {\n  /**\n   * @dev Returns the number of decimals used for the token\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/protocol/core/ConfigOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @title ConfigOptions\n * @notice A central place for enumerating the configurable options of our GoldfinchConfig contract\n * @author Goldfinch\n */\n\nlibrary ConfigOptions {\n  // NEVER EVER CHANGE THE ORDER OF THESE!\n  // You can rename or append. But NEVER change the order.\n  enum Numbers {\n    TransactionLimit,\n    TotalFundsLimit,\n    MaxUnderwriterLimit,\n    ReserveDenominator,\n    WithdrawFeeDenominator,\n    LatenessGracePeriodInDays,\n    LatenessMaxDays\n  }\n  enum Addresses {\n    Pool,\n    CreditLineImplementation,\n    CreditLineFactory,\n    CreditDesk,\n    Fidu,\n    USDC,\n    TreasuryReserve,\n    ProtocolAdmin,\n    OneInch,\n    TrustedForwarder,\n    CUSDCContract,\n    GoldfinchConfig\n  }\n\n  function getNumberName(uint256 number) public pure returns (string memory) {\n    Numbers numberName = Numbers(number);\n    if (Numbers.TransactionLimit == numberName) {\n      return \"TransactionLimit\";\n    }\n    if (Numbers.TotalFundsLimit == numberName) {\n      return \"TotalFundsLimit\";\n    }\n    if (Numbers.MaxUnderwriterLimit == numberName) {\n      return \"MaxUnderwriterLimit\";\n    }\n    if (Numbers.ReserveDenominator == numberName) {\n      return \"ReserveDenominator\";\n    }\n    if (Numbers.WithdrawFeeDenominator == numberName) {\n      return \"WithdrawFeeDenominator\";\n    }\n    if (Numbers.LatenessGracePeriodInDays == numberName) {\n      return \"LatenessGracePeriodInDays\";\n    }\n    if (Numbers.LatenessMaxDays == numberName) {\n      return \"LatenessMaxDays\";\n    }\n    revert(\"Unknown value passed to getNumberName\");\n  }\n\n  function getAddressName(uint256 addressKey) public pure returns (string memory) {\n    Addresses addressName = Addresses(addressKey);\n    if (Addresses.Pool == addressName) {\n      return \"Pool\";\n    }\n    if (Addresses.CreditLineImplementation == addressName) {\n      return \"CreditLineImplementation\";\n    }\n    if (Addresses.CreditLineFactory == addressName) {\n      return \"CreditLineFactory\";\n    }\n    if (Addresses.CreditDesk == addressName) {\n      return \"CreditDesk\";\n    }\n    if (Addresses.Fidu == addressName) {\n      return \"Fidu\";\n    }\n    if (Addresses.USDC == addressName) {\n      return \"USDC\";\n    }\n    if (Addresses.TreasuryReserve == addressName) {\n      return \"TreasuryReserve\";\n    }\n    if (Addresses.ProtocolAdmin == addressName) {\n      return \"ProtocolAdmin\";\n    }\n    if (Addresses.OneInch == addressName) {\n      return \"OneInch\";\n    }\n    if (Addresses.TrustedForwarder == addressName) {\n      return \"TrustedForwarder\";\n    }\n    if (Addresses.CUSDCContract == addressName) {\n      return \"CUSDCContract\";\n    }\n    revert(\"Unknown value passed to getAddressName\");\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, _msgSender()));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n */\nabstract contract AccessControlUpgradeSafe is Initializable, ContextUpgradeSafe {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n\n\n    }\n\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuardUpgradeSafe is Initializable {\n    bool private _notEntered;\n\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n\n    }\n\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/protocol/core/PauserPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/access/AccessControl.sol\";\n\n/**\n * @title PauserPausable\n * @notice Inheriting from OpenZeppelin's Pausable contract, this does small\n *  augmentations to make it work with a PAUSER_ROLE, leveraging the AccessControl contract.\n *  It is meant to be inherited.\n * @author Goldfinch\n */\n\ncontract PauserPausable is AccessControlUpgradeSafe, PausableUpgradeSafe {\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __PauserPausable__init() public initializer {\n    __Pausable_init_unchained();\n  }\n\n  /**\n   * @dev Pauses all functions guarded by Pause\n   *\n   * See {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the PAUSER_ROLE.\n   */\n\n  function pause() public onlyPauserRole {\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses the contract\n   *\n   * See {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the Pauser role\n   */\n  function unpause() public onlyPauserRole {\n    _unpause();\n  }\n\n  modifier onlyPauserRole() {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Must have pauser role to perform this action\");\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/EnumerableSet.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\nimport \"../Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract ContextUpgradeSafe is Initializable {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n\n\n    }\n\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/utils/Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract PausableUpgradeSafe is Initializable, ContextUpgradeSafe {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n\n\n        _paused = false;\n\n    }\n\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/test/TestAccountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../protocol/core/Accountant.sol\";\nimport \"../protocol/core/CreditLine.sol\";\n\ncontract TestAccountant {\n  function calculateInterestAndPrincipalAccrued(\n    address creditLineAddress,\n    uint256 blockNumber,\n    uint256 lateFeeGracePeriod\n  ) public view returns (uint256, uint256) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    return Accountant.calculateInterestAndPrincipalAccrued(cl, blockNumber, lateFeeGracePeriod);\n  }\n\n  function calculateWritedownFor(\n    address creditLineAddress,\n    uint256 blockNumber,\n    uint256 gracePeriod,\n    uint256 maxLatePeriods\n  ) public view returns (uint256, uint256) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    return Accountant.calculateWritedownFor(cl, blockNumber, gracePeriod, maxLatePeriods);\n  }\n\n  function calculateAmountOwedForOneDay(address creditLineAddress) public view returns (FixedPoint.Unsigned memory) {\n    CreditLine cl = CreditLine(creditLineAddress);\n    return Accountant.calculateAmountOwedForOneDay(cl);\n  }\n}\n"
    },
    "contracts/test/FakeV2CreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/Math.sol\";\nimport \"../protocol/core/BaseUpgradeablePausable.sol\";\nimport \"../protocol/core/Pool.sol\";\nimport \"../protocol/core/Accountant.sol\";\nimport \"../protocol/core/CreditLine.sol\";\nimport \"../protocol/core/GoldfinchConfig.sol\";\n\ncontract FakeV2CreditDesk is BaseUpgradeablePausable {\n  uint256 public totalWritedowns;\n  uint256 public totalLoansOutstanding;\n  // Approximate number of blocks\n  uint256 public constant BLOCKS_PER_DAY = 5760;\n  GoldfinchConfig public config;\n\n  struct Underwriter {\n    uint256 governanceLimit;\n    address[] creditLines;\n  }\n\n  struct Borrower {\n    address[] creditLines;\n  }\n\n  event PaymentMade(\n    address indexed payer,\n    address indexed creditLine,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount\n  );\n  event PrepaymentMade(address indexed payer, address indexed creditLine, uint256 prepaymentAmount);\n  event DrawdownMade(address indexed borrower, address indexed creditLine, uint256 drawdownAmount);\n  event CreditLineCreated(address indexed borrower, address indexed creditLine);\n  event PoolAddressUpdated(address indexed oldAddress, address indexed newAddress);\n  event GovernanceUpdatedUnderwriterLimit(address indexed underwriter, uint256 newLimit);\n  event LimitChanged(address indexed owner, string limitType, uint256 amount);\n\n  mapping(address => Underwriter) public underwriters;\n  mapping(address => Borrower) private borrowers;\n\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    owner;\n    _config;\n    return;\n  }\n\n  function someBrandNewFunction() public pure returns (uint256) {\n    return 5;\n  }\n\n  function getUnderwriterCreditLines(address underwriterAddress) public view returns (address[] memory) {\n    return underwriters[underwriterAddress].creditLines;\n  }\n}\n"
    },
    "contracts/protocol/core/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Goldfinch's Pool contract\n * @notice Main entry point for LP's (a.k.a. capital providers)\n *  Handles key logic for depositing and withdrawing funds from the Pool\n * @author Goldfinch\n */\n\ncontract Pool is BaseUpgradeablePausable, IPool {\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  uint256 public compoundBalance;\n\n  event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n  event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n  event TransferMade(address indexed from, address indexed to, uint256 amount);\n  event InterestCollected(address indexed payer, uint256 poolAmount, uint256 reserveAmount);\n  event PrincipalCollected(address indexed payer, uint256 amount);\n  event ReserveFundsCollected(address indexed user, uint256 amount);\n  event PrincipalWrittendown(address indexed creditline, int256 amount);\n\n  /**\n   * @notice Run only once, on initialization\n   * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n   * @param _config The address of the GoldfinchConfig contract\n   */\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n\n    config = _config;\n    sharePrice = fiduMantissa();\n    IERC20withDec usdc = config.getUSDC();\n    // Sanity check the address\n    usdc.totalSupply();\n\n    // Unlock self for infinite amount\n    bool success = usdc.approve(address(this), uint256(-1));\n    require(success, \"Failed to approve USDC\");\n  }\n\n  /**\n   * @notice Deposits `amount` USDC from msg.sender into the Pool, and returns you the equivalent value of FIDU tokens\n   * @param amount The amount of USDC to deposit\n   */\n  function deposit(uint256 amount) external override whenNotPaused withinTransactionLimit(amount) nonReentrant {\n    require(amount > 0, \"Must deposit more than zero\");\n    // Check if the amount of new shares to be added is within limits\n    uint256 depositShares = getNumShares(amount);\n    uint256 potentialNewTotalShares = totalShares().add(depositShares);\n    require(poolWithinLimit(potentialNewTotalShares), \"Deposit would put the Pool over the total limit.\");\n    emit DepositMade(msg.sender, amount, depositShares);\n    bool success = doUSDCTransfer(msg.sender, address(this), amount);\n    require(success, \"Failed to transfer for deposit\");\n\n    config.getFidu().mintTo(msg.sender, depositShares);\n  }\n\n  /**\n   * @notice Withdraws USDC from the Pool to msg.sender, and burns the equivalent value of FIDU tokens\n   * @param usdcAmount The amount of USDC to withdraw\n   */\n  function withdraw(uint256 usdcAmount) external override whenNotPaused nonReentrant {\n    require(usdcAmount > 0, \"Must withdraw more than zero\");\n    uint256 withdrawShares = getNumShares(usdcAmount);\n    _withdraw(usdcAmount, withdrawShares);\n  }\n\n  /**\n   * @notice Withdraws USDC (denominated in FIDU terms) from the Pool to msg.sender\n   * @param fiduAmount The amount of USDC to withdraw in terms of fidu shares\n   */\n  function withdrawInFidu(uint256 fiduAmount) external override whenNotPaused nonReentrant {\n    require(fiduAmount > 0, \"Must withdraw more than zero\");\n    uint256 usdcAmount = getUSDCAmountFromShares(fiduAmount);\n    uint256 withdrawShares = fiduAmount;\n    _withdraw(usdcAmount, withdrawShares);\n  }\n\n  /**\n   * @notice Collects `interest` USDC in interest and `principal` in principal from `from` and sends it to the Pool.\n   *  This also increases the share price accordingly. A portion is sent to the Goldfinch Reserve address\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param interest the interest amount of USDC to move to the Pool\n   * @param principal the principal amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) public override onlyCreditDesk whenNotPaused {\n    _collectInterestAndPrincipal(from, interest, principal);\n  }\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta)\n    external\n    override\n    onlyCreditDesk\n    whenNotPaused\n  {\n    if (writedownDelta > 0) {\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta));\n      sharePrice = sharePrice.add(delta);\n    } else {\n      // If delta is negative, convert to positive uint, and sub from sharePrice\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta * -1));\n      sharePrice = sharePrice.sub(delta);\n    }\n    emit PrincipalWrittendown(creditlineAddress, writedownDelta);\n  }\n\n  /**\n   * @notice Moves `amount` USDC from `from`, to `to`.\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param to The address that the USDC should be moved to\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override onlyCreditDesk whenNotPaused returns (bool) {\n    bool result = doUSDCTransfer(from, to, amount);\n    require(result, \"USDC Transfer failed\");\n    emit TransferMade(from, to, amount);\n    return result;\n  }\n\n  /**\n   * @notice Moves `amount` USDC from the pool, to `to`. This is similar to transferFrom except we sweep any\n   * balance we have from compound first and recognize interest. Meant to be called only by the credit desk on drawdown\n   * @param to The address that the USDC should be moved to\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function drawdown(address to, uint256 amount) public override onlyCreditDesk whenNotPaused returns (bool) {\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n    return transferFrom(address(this), to, amount);\n  }\n\n  function assets() public view override returns (uint256) {\n    ICreditDesk creditDesk = config.getCreditDesk();\n    return\n      compoundBalance.add(config.getUSDC().balanceOf(address(this))).add(creditDesk.totalLoansOutstanding()).sub(\n        creditDesk.totalWritedowns()\n      );\n  }\n\n  /**\n   * @notice Moves any USDC still in the Pool to Compound, and tracks the amount internally.\n   * This is done to earn interest on latent funds until we have other borrowers who can use it.\n   *\n   * Requirements:\n   *  - The caller must be an admin.\n   */\n  function sweepToCompound() public override onlyAdmin whenNotPaused {\n    IERC20 usdc = config.getUSDC();\n    uint256 usdcBalance = usdc.balanceOf(address(this));\n\n    ICUSDCContract cUSDC = config.getCUSDCContract();\n    // Approve compound to the exact amount\n    bool success = usdc.approve(address(cUSDC), usdcBalance);\n    require(success, \"Failed to approve USDC for compound\");\n\n    sweepToCompound(cUSDC, usdcBalance);\n\n    // Remove compound approval to be extra safe\n    success = config.getUSDC().approve(address(cUSDC), 0);\n    require(success, \"Failed to approve USDC for compound\");\n  }\n\n  /**\n   * @notice Moves any USDC from Compound back to the Pool, and recognizes interest earned.\n   * This is done automatically on drawdown or withdraw, but can be called manually if necessary.\n   *\n   * Requirements:\n   *  - The caller must be an admin.\n   */\n  function sweepFromCompound() public override onlyAdmin whenNotPaused {\n    _sweepFromCompound();\n  }\n\n  /* Internal Functions */\n\n  function _withdraw(uint256 usdcAmount, uint256 withdrawShares) internal withinTransactionLimit(usdcAmount) {\n    IFidu fidu = config.getFidu();\n    // Determine current shares the address has and the shares requested to withdraw\n    uint256 currentShares = fidu.balanceOf(msg.sender);\n    // Ensure the address has enough value in the pool\n    require(withdrawShares <= currentShares, \"Amount requested is greater than what this address owns\");\n\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n\n    uint256 reserveAmount = usdcAmount.div(config.getWithdrawFeeDenominator());\n    uint256 userAmount = usdcAmount.sub(reserveAmount);\n\n    emit WithdrawalMade(msg.sender, userAmount, reserveAmount);\n    // Send the amounts\n    bool success = doUSDCTransfer(address(this), msg.sender, userAmount);\n    require(success, \"Failed to transfer for withdraw\");\n    sendToReserve(address(this), reserveAmount, msg.sender);\n\n    // Burn the shares\n    fidu.burnFrom(msg.sender, withdrawShares);\n  }\n\n  function sweepToCompound(ICUSDCContract cUSDC, uint256 usdcAmount) internal {\n    // Our current design requires we re-normalize by withdrawing everything and recognizing interest gains\n    // before we can add additional capital to Compound\n    require(compoundBalance == 0, \"Cannot sweep when we already have a compound balance\");\n    require(usdcAmount != 0, \"Amount to sweep cannot be zero\");\n    uint256 error = cUSDC.mint(usdcAmount);\n    require(error == 0, \"Sweep to compound failed\");\n    compoundBalance = usdcAmount;\n  }\n\n  function sweepFromCompound(ICUSDCContract cUSDC, uint256 cUSDCAmount) internal {\n    uint256 cBalance = compoundBalance;\n    require(cBalance != 0, \"No funds on compound\");\n    require(cUSDCAmount != 0, \"Amount to sweep cannot be zero\");\n\n    IERC20 usdc = config.getUSDC();\n    uint256 preRedeemUSDCBalance = usdc.balanceOf(address(this));\n    uint256 cUSDCExchangeRate = cUSDC.exchangeRateCurrent();\n    uint256 redeemedUSDC = cUSDCToUSDC(cUSDCExchangeRate, cUSDCAmount);\n\n    uint256 error = cUSDC.redeem(cUSDCAmount);\n    uint256 postRedeemUSDCBalance = usdc.balanceOf(address(this));\n    require(error == 0, \"Sweep from compound failed\");\n    require(postRedeemUSDCBalance.sub(preRedeemUSDCBalance) == redeemedUSDC, \"Unexpected redeem amount\");\n\n    uint256 interestAccrued = redeemedUSDC.sub(cBalance);\n    _collectInterestAndPrincipal(address(this), interestAccrued, 0);\n    compoundBalance = 0;\n  }\n\n  function _collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) internal {\n    uint256 reserveAmount = interest.div(config.getReserveDenominator());\n    uint256 poolAmount = interest.sub(reserveAmount);\n    uint256 increment = usdcToSharePrice(poolAmount);\n    sharePrice = sharePrice.add(increment);\n\n    if (poolAmount > 0) {\n      emit InterestCollected(from, poolAmount, reserveAmount);\n    }\n    if (principal > 0) {\n      emit PrincipalCollected(from, principal);\n    }\n    if (reserveAmount > 0) {\n      sendToReserve(from, reserveAmount, from);\n    }\n    // Gas savings: No need to transfer to yourself, which happens in sweepFromCompound\n    if (from != address(this)) {\n      bool success = doUSDCTransfer(from, address(this), principal.add(poolAmount));\n      require(success, \"Failed to collect principal repayment\");\n    }\n  }\n\n  function _sweepFromCompound() internal {\n    ICUSDCContract cUSDC = config.getCUSDCContract();\n    sweepFromCompound(cUSDC, cUSDC.balanceOf(address(this)));\n  }\n\n  function updateGoldfinchConfig() external onlyAdmin {\n    config = GoldfinchConfig(config.configAddress());\n  }\n\n  function fiduMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(18);\n  }\n\n  function usdcMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(6);\n  }\n\n  function usdcToFidu(uint256 amount) internal pure returns (uint256) {\n    return amount.mul(fiduMantissa()).div(usdcMantissa());\n  }\n\n  function cUSDCToUSDC(uint256 exchangeRate, uint256 amount) internal pure returns (uint256) {\n    // See https://compound.finance/docs#protocol-math\n    // But note, the docs and reality do not agree. Docs imply that that exchange rate is\n    // scaled by 1e18, but tests and mainnet forking make it appear to be scaled by 1e16\n    // 1e16 is also what Sheraz at Certik said.\n    uint256 usdcDecimals = 6;\n    uint256 cUSDCDecimals = 8;\n    return\n      amount // Amount in cToken (1e8)\n        .mul(exchangeRate) // Amount in USDC (but scaled by 1e16, cause that's what exchange rate decimals are)\n        .div(10**(18 + usdcDecimals - cUSDCDecimals)) // Downscale to cToken decimals (1e8)\n        .div(10**2); // Downscale from cToken to USDC decimals (8 to 6)\n  }\n\n  function totalShares() internal view returns (uint256) {\n    return config.getFidu().totalSupply();\n  }\n\n  function usdcToSharePrice(uint256 usdcAmount) internal view returns (uint256) {\n    return usdcToFidu(usdcAmount).mul(fiduMantissa()).div(totalShares());\n  }\n\n  function poolWithinLimit(uint256 _totalShares) internal view returns (bool) {\n    return\n      _totalShares.mul(sharePrice).div(fiduMantissa()) <=\n      usdcToFidu(config.getNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit)));\n  }\n\n  function transactionWithinLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n  }\n\n  function getNumShares(uint256 amount) internal view returns (uint256) {\n    return usdcToFidu(amount).mul(fiduMantissa()).div(sharePrice);\n  }\n\n  function getUSDCAmountFromShares(uint256 fiduAmount) internal view returns (uint256) {\n    return fiduToUSDC(fiduAmount.mul(sharePrice).div(fiduMantissa()));\n  }\n\n  function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function sendToReserve(\n    address from,\n    uint256 amount,\n    address userForEvent\n  ) internal {\n    emit ReserveFundsCollected(userForEvent, amount);\n    bool success = doUSDCTransfer(from, config.reserveAddress(), amount);\n    require(success, \"Reserve transfer was not successful\");\n  }\n\n  function doUSDCTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n    require(to != address(0), \"Can't send to zero address\");\n    IERC20withDec usdc = config.getUSDC();\n    return usdc.transferFrom(from, to, amount);\n  }\n\n  modifier withinTransactionLimit(uint256 amount) {\n    require(transactionWithinLimit(amount), \"Amount is over the per-transaction limit\");\n    _;\n  }\n\n  modifier onlyCreditDesk() {\n    require(msg.sender == config.creditDeskAddress(), \"Only the credit desk is allowed to call this function\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./GoldfinchConfig.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IFidu.sol\";\nimport \"../../interfaces/ICreditDesk.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/ICUSDCContract.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the GoldfinchConfig contract\n * @author Goldfinch\n */\n\nlibrary ConfigHelper {\n  function getPool(GoldfinchConfig config) internal view returns (IPool) {\n    return IPool(poolAddress(config));\n  }\n\n  function getUSDC(GoldfinchConfig config) internal view returns (IERC20withDec) {\n    return IERC20withDec(usdcAddress(config));\n  }\n\n  function getCreditDesk(GoldfinchConfig config) internal view returns (ICreditDesk) {\n    return ICreditDesk(creditDeskAddress(config));\n  }\n\n  function getFidu(GoldfinchConfig config) internal view returns (IFidu) {\n    return IFidu(fiduAddress(config));\n  }\n\n  function getCUSDCContract(GoldfinchConfig config) internal view returns (ICUSDCContract) {\n    return ICUSDCContract(cusdcContractAddress(config));\n  }\n\n  function oneInchAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.OneInch));\n  }\n\n  function trustedForwarderAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TrustedForwarder));\n  }\n\n  function configAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.GoldfinchConfig));\n  }\n\n  function poolAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Pool));\n  }\n\n  function creditDeskAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CreditDesk));\n  }\n\n  function fiduAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Fidu));\n  }\n\n  function cusdcContractAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CUSDCContract));\n  }\n\n  function usdcAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.USDC));\n  }\n\n  function reserveAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TreasuryReserve));\n  }\n\n  function protocolAdminAddress(GoldfinchConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.ProtocolAdmin));\n  }\n\n  function getReserveDenominator(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.ReserveDenominator));\n  }\n\n  function getWithdrawFeeDenominator(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator));\n  }\n\n  function getLatenessGracePeriodInDays(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays));\n  }\n\n  function getLatenessMaxDays(GoldfinchConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessMaxDays));\n  }\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nabstract contract IPool {\n  uint256 public sharePrice;\n\n  function deposit(uint256 amount) external virtual;\n\n  function withdraw(uint256 usdcAmount) external virtual;\n\n  function withdrawInFidu(uint256 fiduAmount) external virtual;\n\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) public virtual;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool);\n\n  function drawdown(address to, uint256 amount) public virtual returns (bool);\n\n  function sweepToCompound() public virtual;\n\n  function sweepFromCompound() public virtual;\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta) external virtual;\n\n  function assets() public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20withDec.sol\";\n\ninterface IFidu is IERC20withDec {\n  function mintTo(address to, uint256 amount) external;\n\n  function burnFrom(address to, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/ICreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nabstract contract ICreditDesk {\n  uint256 public totalWritedowns;\n  uint256 public totalLoansOutstanding;\n\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit) external virtual;\n\n  function createCreditLine(\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public virtual returns (address);\n\n  function drawdown(address creditLineAddress, uint256 amount) external virtual;\n\n  function pay(address creditLineAddress, uint256 amount) external virtual;\n\n  function assessCreditLine(address creditLineAddress) external virtual;\n\n  function applyPayment(address creditLineAddress, uint256 amount) external virtual;\n\n  function getNextPaymentAmount(address creditLineAddress, uint256 asOfBLock) external view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICUSDCContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\npragma solidity 0.6.12;\n\nimport \"./IERC20withDec.sol\";\n\ninterface ICUSDCContract is IERC20withDec {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n}\n"
    },
    "contracts/test/TestTheConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/core/GoldfinchConfig.sol\";\n\ncontract TestTheConfig {\n  address public poolAddress = 0xBAc2781706D0aA32Fb5928c9a5191A13959Dc4AE;\n  address public clImplAddress = 0xc783df8a850f42e7F7e57013759C285caa701eB6;\n  address public clFactoryAddress = 0x0afFE1972479c386A2Ab21a27a7f835361B6C0e9;\n  address public fiduAddress = 0xf3c9B38c155410456b5A98fD8bBf5E35B87F6d96;\n  address public creditDeskAddress = 0xeAD9C93b79Ae7C1591b1FB5323BD777E86e150d4;\n  address public treasuryReserveAddress = 0xECd9C93B79AE7C1591b1fB5323BD777e86E150d5;\n  address public trustedForwarderAddress = 0x956868751Cc565507B3B58E53a6f9f41B56bed74;\n  address public cUSDCAddress = 0x5B281A6DdA0B271e91ae35DE655Ad301C976edb1;\n  address public goldfinchConfigAddress = address(8);\n\n  function testTheEnums(address configAddress) public {\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.TransactionLimit), 1);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit), 2);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.MaxUnderwriterLimit), 3);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.ReserveDenominator), 4);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator), 5);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays), 6);\n    GoldfinchConfig(configAddress).setNumber(uint256(ConfigOptions.Numbers.LatenessMaxDays), 7);\n\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.Fidu), fiduAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.Pool), poolAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.CreditDesk), creditDeskAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.CreditLineFactory), clFactoryAddress);\n    GoldfinchConfig(configAddress).setAddress(\n      uint256(ConfigOptions.Addresses.TrustedForwarder),\n      trustedForwarderAddress\n    );\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.CUSDCContract), cUSDCAddress);\n    GoldfinchConfig(configAddress).setAddress(uint256(ConfigOptions.Addresses.GoldfinchConfig), goldfinchConfigAddress);\n\n    GoldfinchConfig(configAddress).setTreasuryReserve(treasuryReserveAddress);\n  }\n}\n"
    },
    "contracts/test/TestGoldfinchConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/core/GoldfinchConfig.sol\";\n\ncontract TestGoldfinchConfig is GoldfinchConfig {\n  function setAddressForTest(uint256 addressKey, address newAddress) public {\n    addresses[addressKey] = newAddress;\n  }\n}\n"
    },
    "contracts/protocol/core/CreditLineFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./GoldfinchConfig.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"../periphery/Borrower.sol\";\nimport \"./CreditLine.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title CreditLineFactory\n * @notice Contract that allows us to create other contracts, such as CreditLines and BorrowerContracts\n * @author Goldfinch\n */\n\ncontract CreditLineFactory is BaseUpgradeablePausable {\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  event BorrowerCreated(address indexed borrower, address indexed owner);\n\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  function createCreditLine() external returns (address) {\n    CreditLine newCreditLine = new CreditLine();\n    return address(newCreditLine);\n  }\n\n  /**\n   * @notice Allows anyone to create a Borrower contract instance\n   * @param owner The address that will own the new Borrower instance\n   */\n  function createBorrower(address owner) external returns (address) {\n    Borrower borrower = new Borrower();\n    borrower.initialize(owner, config);\n    emit BorrowerCreated(address(borrower), owner);\n    return address(borrower);\n  }\n\n  function updateGoldfinchConfig() external onlyAdmin {\n    config = GoldfinchConfig(config.configAddress());\n  }\n}\n"
    },
    "contracts/protocol/periphery/Borrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../core/BaseUpgradeablePausable.sol\";\nimport \"../core/ConfigHelper.sol\";\nimport \"../core/CreditLine.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"@opengsn/gsn/contracts/BaseRelayRecipient.sol\";\nimport \"@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\";\n\n/**\n * @title Goldfinch's Borrower contract\n * @notice These contracts represent the a convenient way for a borrower to interact with Goldfinch\n *  They are 100% optional. However, they let us add many sophisticated and convient features for borrowers\n *  while still keeping our core protocol small and secure. We therefore expect most borrowers will use them.\n *  This contract is the \"official\" borrower contract that will be maintained by Goldfinch governance. However,\n *  in theory, anyone can fork or create their own version, or not use any contract at all. The core functionality\n *  is completely agnostic to whether it is interacting with a contract or an externally owned account (EOA).\n * @author Goldfinch\n */\n\ncontract Borrower is BaseUpgradeablePausable, BaseRelayRecipient {\n  using SafeMath for uint256;\n\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  address private constant USDT_ADDRESS = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  address private constant BUSD_ADDRESS = address(0x4Fabb145d64652a948d72533023f6E7A623C7C53);\n\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    require(owner != address(0), \"Owner cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n\n    trustedForwarder = config.trustedForwarderAddress();\n\n    // Handle default approvals. Pool, and OneInch for maximum amounts\n    address oneInch = config.oneInchAddress();\n    IERC20withDec usdc = config.getUSDC();\n    usdc.approve(config.poolAddress(), uint256(-1));\n    usdc.approve(oneInch, uint256(-1));\n    bytes memory data = abi.encodeWithSignature(\"approve(address,uint256)\", oneInch, uint256(-1));\n    invoke(USDT_ADDRESS, data);\n    invoke(BUSD_ADDRESS, data);\n  }\n\n  /**\n   * @notice Allows a borrower to drawdown on their creditline through the CreditDesk.\n   * @param creditLineAddress The creditline from which they would like to drawdown\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to drawdown\n   * @param addressToSendTo The address where they would like the funds sent. If the zero address is passed,\n   *  it will be defaulted to the contracts address (msg.sender). This is a convenience feature for when they would\n   *  like the funds sent to an exchange or alternate wallet, different from the authentication address\n   */\n  function drawdown(\n    address creditLineAddress,\n    uint256 amount,\n    address addressToSendTo\n  ) external onlyAdmin {\n    config.getCreditDesk().drawdown(creditLineAddress, amount);\n\n    if (addressToSendTo == address(0) || addressToSendTo == address(this)) {\n      addressToSendTo = _msgSender();\n    }\n\n    transferERC20(config.usdcAddress(), addressToSendTo, amount);\n  }\n\n  function drawdownWithSwapOnOneInch(\n    address creditLineAddress,\n    uint256 amount,\n    address addressToSendTo,\n    address toToken,\n    uint256 minTargetAmount,\n    uint256[] calldata exchangeDistribution\n  ) public onlyAdmin {\n    // Drawdown to the Borrower contract\n    config.getCreditDesk().drawdown(creditLineAddress, amount);\n\n    // Do the swap\n    swapOnOneInch(config.usdcAddress(), toToken, amount, minTargetAmount, exchangeDistribution);\n\n    // Default to sending to the owner, and don't let funds stay in this contract\n    if (addressToSendTo == address(0) || addressToSendTo == address(this)) {\n      addressToSendTo = _msgSender();\n    }\n\n    // Fulfill the send to\n    bytes memory _data = abi.encodeWithSignature(\"balanceOf(address)\", address(this));\n    uint256 receivedAmount = toUint256(invoke(toToken, _data));\n    transferERC20(toToken, addressToSendTo, receivedAmount);\n  }\n\n  function transferERC20(\n    address token,\n    address to,\n    uint256 amount\n  ) public onlyAdmin {\n    bytes memory _data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n    invoke(token, _data);\n  }\n\n  /**\n   * @notice Allows a borrower to payback loans by calling the `pay` function directly on the CreditDesk\n   * @param creditLineAddress The credit line to be paid back\n   * @param amount The amount, in USDC atomic units, that the borrower wishes to pay\n   */\n  function pay(address creditLineAddress, uint256 amount) external onlyAdmin {\n    bool success = config.getUSDC().transferFrom(_msgSender(), address(this), amount);\n    require(success, \"Failed to transfer USDC\");\n    config.getCreditDesk().pay(creditLineAddress, amount);\n  }\n\n  function payMultiple(address[] calldata creditLines, uint256[] calldata amounts) external onlyAdmin {\n    require(creditLines.length == amounts.length, \"Creditlines and amounts must be the same length\");\n\n    uint256 totalAmount;\n    for (uint256 i = 0; i < amounts.length; i++) {\n      totalAmount = totalAmount.add(amounts[i]);\n    }\n\n    // Do a single transfer, which is cheaper\n    bool success = config.getUSDC().transferFrom(_msgSender(), address(this), totalAmount);\n    require(success, \"Failed to transfer USDC\");\n\n    ICreditDesk creditDesk = config.getCreditDesk();\n    for (uint256 i = 0; i < amounts.length; i++) {\n      creditDesk.pay(creditLines[i], amounts[i]);\n    }\n  }\n\n  function payInFull(address creditLineAddress, uint256 amount) external onlyAdmin {\n    bool success = config.getUSDC().transferFrom(_msgSender(), creditLineAddress, amount);\n    require(success, \"Failed to transfer USDC\");\n\n    config.getCreditDesk().applyPayment(creditLineAddress, amount);\n    require(CreditLine(creditLineAddress).balance() == 0, \"Failed to fully pay off creditline\");\n  }\n\n  function payWithSwapOnOneInch(\n    address creditLineAddress,\n    uint256 originAmount,\n    address fromToken,\n    uint256 minTargetAmount,\n    uint256[] memory exchangeDistribution\n  ) external onlyAdmin {\n    transferFrom(fromToken, _msgSender(), address(this), originAmount);\n    IERC20withDec usdc = config.getUSDC();\n    swapOnOneInch(fromToken, address(usdc), originAmount, minTargetAmount, exchangeDistribution);\n    uint256 usdcBalance = usdc.balanceOf(address(this));\n    config.getCreditDesk().pay(creditLineAddress, usdcBalance);\n  }\n\n  function payMultipleWithSwapOnOneInch(\n    address[] memory creditLines,\n    uint256[] memory minAmounts,\n    uint256 originAmount,\n    address fromToken,\n    uint256[] memory exchangeDistribution\n  ) external onlyAdmin {\n    require(creditLines.length == minAmounts.length, \"Creditlines and amounts must be the same length\");\n\n    uint256 totalMinAmount = 0;\n    for (uint256 i = 0; i < minAmounts.length; i++) {\n      totalMinAmount = totalMinAmount.add(minAmounts[i]);\n    }\n\n    transferFrom(fromToken, _msgSender(), address(this), originAmount);\n\n    IERC20withDec usdc = config.getUSDC();\n    swapOnOneInch(fromToken, address(usdc), originAmount, totalMinAmount, exchangeDistribution);\n\n    ICreditDesk creditDesk = config.getCreditDesk();\n    for (uint256 i = 0; i < minAmounts.length; i++) {\n      creditDesk.pay(creditLines[i], minAmounts[i]);\n    }\n\n    uint256 remainingUSDC = usdc.balanceOf(address(this));\n    if (remainingUSDC > 0) {\n      bool success = usdc.transfer(creditLines[0], remainingUSDC);\n      require(success, \"Failed to transfer USDC\");\n    }\n  }\n\n  function transferFrom(\n    address erc20,\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal {\n    bytes memory _data;\n    // Do a low-level invoke on this transfer, since Tether fails if we use the normal IERC20 interface\n    _data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", sender, recipient, amount);\n    invoke(address(erc20), _data);\n  }\n\n  function swapOnOneInch(\n    address fromToken,\n    address toToken,\n    uint256 originAmount,\n    uint256 minTargetAmount,\n    uint256[] memory exchangeDistribution\n  ) internal {\n    bytes memory _data = abi.encodeWithSignature(\n      \"swap(address,address,uint256,uint256,uint256[],uint256)\",\n      fromToken,\n      toToken,\n      originAmount,\n      minTargetAmount,\n      exchangeDistribution,\n      0\n    );\n    invoke(config.oneInchAddress(), _data);\n  }\n\n  /**\n   * @notice Performs a generic transaction.\n   * @param _target The address for the transaction.\n   * @param _data The data of the transaction.\n   * Mostly copied from Argent:\n   * https://github.com/argentlabs/argent-contracts/blob/develop/contracts/wallet/BaseWallet.sol#L111\n   */\n  function invoke(address _target, bytes memory _data) internal returns (bytes memory) {\n    // External contracts can be compiled with different Solidity versions\n    // which can cause \"revert without reason\" when called through,\n    // for example, a standard IERC20 ABI compiled on the latest version.\n    // This low-level call avoids that issue.\n\n    bool success;\n    bytes memory _res;\n    // solhint-disable-next-line avoid-low-level-calls\n    (success, _res) = _target.call(_data);\n    if (!success && _res.length > 0) {\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    } else if (!success) {\n      revert(\"VM: wallet invoke reverted\");\n    }\n    return _res;\n  }\n\n  function toUint256(bytes memory _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := mload(add(_bytes, 0x20))\n    }\n  }\n\n  // OpenZeppelin contracts come with support for GSN _msgSender() (which just defaults to msg.sender)\n  // Since there are two different versions of the function in the hierarchy, we need to instruct solidity to\n  // use the relay recipient version which can actually pull the real sender from the parameters.\n  // https://www.notion.so/My-contract-is-using-OpenZeppelin-How-do-I-add-GSN-support-2bee7e9d5f774a0cbb60d3a8de03e9fb\n  function _msgSender() internal view override(ContextUpgradeSafe, BaseRelayRecipient) returns (address payable) {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  function _msgData() internal view override(ContextUpgradeSafe, BaseRelayRecipient) returns (bytes memory ret) {\n    return BaseRelayRecipient._msgData();\n  }\n\n  function versionRecipient() external view override returns (string memory) {\n    return \"2.0.0\";\n  }\n}\n"
    },
    "@opengsn/gsn/contracts/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\n// solhint-disable no-inline-assembly\npragma solidity ^0.6.2;\n\nimport \"./interfaces/IRelayRecipient.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient is IRelayRecipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address public trustedForwarder;\n\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, return the original sender.\n     * otherwise, return `msg.sender`.\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal override virtual view returns (address payable ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal override virtual view returns (bytes memory ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // we copy the msg.data , except the last 20 bytes (and update the total length)\n            assembly {\n                let ptr := mload(0x40)\n                // copy only size-20 bytes\n                let size := sub(calldatasize(),20)\n                // structure RLP data as <offset> <length> <bytes>\n                mstore(ptr, 0x20)\n                mstore(add(ptr,32), size)\n                calldatacopy(add(ptr,64), 0, size)\n                return(ptr, add(size,64))\n            }\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "@opengsn/gsn/contracts/interfaces/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.6.2;\n\n/**\n * a contract must implement this interface in order to support relayed transaction.\n * It is better to inherit the BaseRelayRecipient as its implementation.\n */\nabstract contract IRelayRecipient {\n\n    /**\n     * return if the forwarder is trusted to forward relayed transactions to us.\n     * the forwarder is required to verify the sender's signature, and verify\n     * the call is not a replay.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\n     * of the msg.data.\n     * otherwise, return `msg.sender`\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal virtual view returns (address payable);\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal virtual view returns (bytes memory);\n\n    function versionRecipient() external virtual view returns (string memory);\n}\n"
    },
    "contracts/test/TestPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/core/Pool.sol\";\n\ncontract TestPool is Pool {\n  function _getNumShares(uint256 amount) public view returns (uint256) {\n    return getNumShares(amount);\n  }\n\n  function _usdcMantissa() public pure returns (uint256) {\n    return usdcMantissa();\n  }\n\n  function _fiduMantissa() public pure returns (uint256) {\n    return fiduMantissa();\n  }\n\n  function _usdcToFidu(uint256 amount) public pure returns (uint256) {\n    return usdcToFidu(amount);\n  }\n\n  function _setSharePrice(uint256 newSharePrice) public returns (uint256) {\n    sharePrice = newSharePrice;\n  }\n}\n"
    },
    "contracts/test/FakeV2CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../protocol/core/Pool.sol\";\nimport \"../protocol/core/BaseUpgradeablePausable.sol\";\n\ncontract FakeV2CreditLine is BaseUpgradeablePausable {\n  // Credit line terms\n  address public borrower;\n  address public underwriter;\n  uint256 public limit;\n  uint256 public interestApr;\n  uint256 public paymentPeriodInDays;\n  uint256 public termInDays;\n  uint256 public lateFeeApr;\n\n  // Accounting variables\n  uint256 public balance;\n  uint256 public interestOwed;\n  uint256 public principalOwed;\n  uint256 public termEndBlock;\n  uint256 public nextDueBlock;\n  uint256 public interestAccruedAsOfBlock;\n  uint256 public writedownAmount;\n  uint256 public lastFullPaymentBlock;\n\n  function initialize(\n    address owner,\n    address _borrower,\n    address _underwriter,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n    borrower = _borrower;\n    underwriter = _underwriter;\n    limit = _limit;\n    interestApr = _interestApr;\n    paymentPeriodInDays = _paymentPeriodInDays;\n    termInDays = _termInDays;\n    lateFeeApr = _lateFeeApr;\n    interestAccruedAsOfBlock = block.number;\n  }\n\n  function anotherNewFunction() external pure returns (uint256) {\n    return 42;\n  }\n\n  function authorizePool(address) external view onlyAdmin {\n    // no-op\n    return;\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20UpgradeSafe is Initializable, ContextUpgradeSafe, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n    }\n\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\n\n\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n\n    }\n\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n    uint256[44] private __gap;\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// contracts/GLDToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20UpgradeSafe {\n  constructor(uint256 initialSupply, uint8 decimals) public {\n    __ERC20_init(\"USDC\", \"USDC\");\n    _setupDecimals(decimals);\n    _mint(msg.sender, initialSupply);\n  }\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Pausable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\nimport \"../../utils/Pausable.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeSafe is Initializable, ERC20UpgradeSafe, PausableUpgradeSafe {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n\n\n    }\n\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\nimport \"../../Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeSafe is Initializable, ContextUpgradeSafe, ERC20UpgradeSafe {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n\n\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/presets/ERC20PresetMinterPauser.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../GSN/Context.sol\";\nimport \"../token/ERC20/ERC20.sol\";\nimport \"../token/ERC20/ERC20Burnable.sol\";\nimport \"../token/ERC20/ERC20Pausable.sol\";\nimport \"../Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to aother accounts\n */\ncontract ERC20PresetMinterPauserUpgradeSafe is Initializable, ContextUpgradeSafe, AccessControlUpgradeSafe, ERC20BurnableUpgradeSafe, ERC20PausableUpgradeSafe {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n\n    function initialize(string memory name, string memory symbol) public {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __AccessControl_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __ERC20Burnable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {\n\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n\n    }\n\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(ERC20UpgradeSafe, ERC20PausableUpgradeSafe) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/core/Fidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/presets/ERC20PresetMinterPauser.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Fidu\n * @notice Fidu (symbol: FIDU) is Goldfinch's liquidity token, representing shares\n *  in the Pool. When you deposit, we mint a corresponding amount of Fidu, and when you withdraw, we\n *  burn Fidu. The share price of the Pool implicitly represents the \"exchange rate\" between Fidu\n *  and USDC (or whatever currencies the Pool may allow withdraws in during the future)\n * @author Goldfinch\n */\n\ncontract Fidu is ERC20PresetMinterPauserUpgradeSafe {\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  // $1 threshold to handle potential rounding errors, from differing decimals on Fidu and USDC;\n  uint256 public constant ASSET_LIABILITY_MATCH_THRESHOLD = 1e6;\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  /*\n    We are using our own initializer function so we can set the owner by passing it in.\n    I would override the regular \"initializer\" function, but I can't because it's not marked\n    as \"virtual\" in the parent contract\n  */\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(\n    address owner,\n    string calldata name,\n    string calldata symbol,\n    GoldfinchConfig _config\n  ) external initializer {\n    __Context_init_unchained();\n    __AccessControl_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n\n    __ERC20Burnable_init_unchained();\n    __Pausable_init_unchained();\n    __ERC20Pausable_init_unchained();\n\n    config = _config;\n\n    _setupRole(MINTER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(MINTER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mintTo(address to, uint256 amount) public {\n    require(canMint(amount), \"Cannot mint: it would create an asset/liability mismatch\");\n    // This will lock the function down to only the minter\n    super.mint(to, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the MINTER_ROLE\n   */\n  function burnFrom(address from, uint256 amount) public override {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: Must have minter role to burn\");\n    require(canBurn(amount), \"Cannot burn: it would create an asset/liability mismatch\");\n    _burn(from, amount);\n  }\n\n  // Internal functions\n\n  // canMint assumes that the USDC that backs the new shares has already been sent to the Pool\n  function canMint(uint256 newAmount) internal view returns (bool) {\n    IPool pool = config.getPool();\n    uint256 liabilities = totalSupply().add(newAmount).mul(pool.sharePrice()).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = pool.assets();\n    if (_assets >= liabilitiesInDollars) {\n      return _assets.sub(liabilitiesInDollars) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  // canBurn assumes that the USDC that backed these shares has already been moved out the Pool\n  function canBurn(uint256 amountToBurn) internal view returns (bool) {\n    IPool pool = config.getPool();\n    uint256 liabilities = totalSupply().sub(amountToBurn).mul(pool.sharePrice()).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = pool.assets();\n    if (_assets >= liabilitiesInDollars) {\n      return _assets.sub(liabilitiesInDollars) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function fiduMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(18);\n  }\n\n  function usdcMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(6);\n  }\n\n  function updateGoldfinchConfig() external {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: Must have minter role to change config\");\n    config = GoldfinchConfig(config.configAddress());\n  }\n}\n"
    },
    "contracts/test/IOneSplit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable\n\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\";\n\n// contract IOneSplitConsts {\n//     // flags = FLAG_DISABLE_UNISWAP + FLAG_DISABLE_BANCOR + ...\n//     uint256 internal constant FLAG_DISABLE_UNISWAP = 0x01;\n//     uint256 internal constant DEPRECATED_FLAG_DISABLE_KYBER = 0x02; // Deprecated\n//     uint256 internal constant FLAG_DISABLE_BANCOR = 0x04;\n//     uint256 internal constant FLAG_DISABLE_OASIS = 0x08;\n//     uint256 internal constant FLAG_DISABLE_COMPOUND = 0x10;\n//     uint256 internal constant FLAG_DISABLE_FULCRUM = 0x20;\n//     uint256 internal constant FLAG_DISABLE_CHAI = 0x40;\n//     uint256 internal constant FLAG_DISABLE_AAVE = 0x80;\n//     uint256 internal constant FLAG_DISABLE_SMART_TOKEN = 0x100;\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_ETH = 0x200; // Deprecated, Turned off by default\n//     uint256 internal constant FLAG_DISABLE_BDAI = 0x400;\n//     uint256 internal constant FLAG_DISABLE_IEARN = 0x800;\n//     uint256 internal constant FLAG_DISABLE_CURVE_COMPOUND = 0x1000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_USDT = 0x2000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_Y = 0x4000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_BINANCE = 0x8000;\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_DAI = 0x10000; // Deprecated, Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_USDC = 0x20000; // Deprecated, Turned off by default\n//     uint256 internal constant FLAG_DISABLE_CURVE_SYNTHETIX = 0x40000;\n//     uint256 internal constant FLAG_DISABLE_WETH = 0x80000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_COMPOUND = 0x100000; // Works only when one of assets is ETH or FLAG_ENABLE_MULTI_PATH_ETH\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_CHAI = 0x200000; // Works only when ETH<>DAI or FLAG_ENABLE_MULTI_PATH_ETH\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_AAVE = 0x400000; // Works only when one of assets is ETH or FLAG_ENABLE_MULTI_PATH_ETH\n//     uint256 internal constant FLAG_DISABLE_IDLE = 0x800000;\n//     uint256 internal constant FLAG_DISABLE_MOONISWAP = 0x1000000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_V2 = 0x2000000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_V2_ETH = 0x4000000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_V2_DAI = 0x8000000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_V2_USDC = 0x10000000;\n//     uint256 internal constant FLAG_DISABLE_ALL_SPLIT_SOURCES = 0x20000000;\n//     uint256 internal constant FLAG_DISABLE_ALL_WRAP_SOURCES = 0x40000000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_PAX = 0x80000000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_RENBTC = 0x100000000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_TBTC = 0x200000000;\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_USDT = 0x400000000; // Deprecated, Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_WBTC = 0x800000000; // Deprecated, Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_TBTC = 0x1000000000; // Deprecated, Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_RENBTC = 0x2000000000; // Deprecated, Turned off by default\n//     uint256 internal constant FLAG_DISABLE_DFORCE_SWAP = 0x4000000000;\n//     uint256 internal constant FLAG_DISABLE_SHELL = 0x8000000000;\n//     uint256 internal constant FLAG_ENABLE_CHI_BURN = 0x10000000000;\n//     uint256 internal constant FLAG_DISABLE_MSTABLE_MUSD = 0x20000000000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_SBTC = 0x40000000000;\n//     uint256 internal constant FLAG_DISABLE_DMM = 0x80000000000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_ALL = 0x100000000000;\n//     uint256 internal constant FLAG_DISABLE_CURVE_ALL = 0x200000000000;\n//     uint256 internal constant FLAG_DISABLE_UNISWAP_V2_ALL = 0x400000000000;\n//     uint256 internal constant FLAG_DISABLE_SPLIT_RECALCULATION = 0x800000000000;\n//     uint256 internal constant FLAG_DISABLE_BALANCER_ALL = 0x1000000000000;\n//     uint256 internal constant FLAG_DISABLE_BALANCER_1 = 0x2000000000000;\n//     uint256 internal constant FLAG_DISABLE_BALANCER_2 = 0x4000000000000;\n//     uint256 internal constant FLAG_DISABLE_BALANCER_3 = 0x8000000000000;\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_KYBER_UNISWAP_RESERVE = 0x10000000000000; // Deprecated, Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_KYBER_OASIS_RESERVE = 0x20000000000000; // Deprecated, Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_KYBER_BANCOR_RESERVE = 0x40000000000000; // Deprecated, Turned off by default\n//     uint256 internal constant FLAG_ENABLE_REFERRAL_GAS_SPONSORSHIP = 0x80000000000000; // Turned off by default\n//     uint256 internal constant DEPRECATED_FLAG_ENABLE_MULTI_PATH_COMP = 0x100000000000000; // Deprecated, Turned off by default\n//     uint256 internal constant FLAG_DISABLE_KYBER_ALL = 0x200000000000000;\n//     uint256 internal constant FLAG_DISABLE_KYBER_1 = 0x400000000000000;\n//     uint256 internal constant FLAG_DISABLE_KYBER_2 = 0x800000000000000;\n//     uint256 internal constant FLAG_DISABLE_KYBER_3 = 0x1000000000000000;\n//     uint256 internal constant FLAG_DISABLE_KYBER_4 = 0x2000000000000000;\n//     uint256 internal constant FLAG_ENABLE_CHI_BURN_BY_ORIGIN = 0x4000000000000000;\n//     uint256 internal constant FLAG_DISABLE_MOONISWAP_ALL = 0x8000000000000000;\n//     uint256 internal constant FLAG_DISABLE_MOONISWAP_ETH = 0x10000000000000000;\n//     uint256 internal constant FLAG_DISABLE_MOONISWAP_DAI = 0x20000000000000000;\n//     uint256 internal constant FLAG_DISABLE_MOONISWAP_USDC = 0x40000000000000000;\n//     uint256 internal constant FLAG_DISABLE_MOONISWAP_POOL_TOKEN = 0x80000000000000000;\n// }\n\ninterface IOneSplit {\n  function getExpectedReturn(\n    IERC20 fromToken,\n    IERC20 destToken,\n    uint256 amount,\n    uint256 parts,\n    uint256 flags // See constants in IOneSplit.sol\n  ) external view returns (uint256 returnAmount, uint256[] memory distribution);\n\n  function getExpectedReturnWithGas(\n    IERC20 fromToken,\n    IERC20 destToken,\n    uint256 amount,\n    uint256 parts,\n    uint256 flags, // See constants in IOneSplit.sol\n    uint256 destTokenEthPriceTimesGasPrice\n  )\n    external\n    view\n    returns (\n      uint256 returnAmount,\n      uint256 estimateGasAmount,\n      uint256[] memory distribution\n    );\n\n  function swap(\n    IERC20 fromToken,\n    IERC20 destToken,\n    uint256 amount,\n    uint256 minReturn,\n    uint256[] memory distribution,\n    uint256 flags\n  ) external payable returns (uint256 returnAmount);\n}\n"
    },
    "contracts/protocol/core/CreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./Accountant.sol\";\nimport \"./CreditLine.sol\";\nimport \"./CreditLineFactory.sol\";\n\n/**\n * @title Goldfinch's CreditDesk contract\n * @notice Main entry point for borrowers and underwriters.\n *  Handles key logic for creating CreditLine's, borrowing money, repayment, etc.\n * @author Goldfinch\n */\n\ncontract CreditDesk is BaseUpgradeablePausable, ICreditDesk {\n  // Approximate number of blocks per day\n  uint256 public constant BLOCKS_PER_DAY = 5760;\n  GoldfinchConfig public config;\n  using ConfigHelper for GoldfinchConfig;\n\n  struct Underwriter {\n    uint256 governanceLimit;\n    address[] creditLines;\n  }\n\n  struct Borrower {\n    address[] creditLines;\n  }\n\n  event PaymentApplied(\n    address indexed payer,\n    address indexed creditLine,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount\n  );\n  event PaymentCollected(address indexed payer, address indexed creditLine, uint256 paymentAmount);\n  event DrawdownMade(address indexed borrower, address indexed creditLine, uint256 drawdownAmount);\n  event CreditLineCreated(address indexed borrower, address indexed creditLine);\n  event GovernanceUpdatedUnderwriterLimit(address indexed underwriter, uint256 newLimit);\n\n  mapping(address => Underwriter) public underwriters;\n  mapping(address => Borrower) private borrowers;\n  mapping(address => address) private creditLines;\n\n  /**\n   * @notice Run only once, on initialization\n   * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n   * @param _config The address of the GoldfinchConfig contract\n   */\n  function initialize(address owner, GoldfinchConfig _config) public initializer {\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  /**\n   * @notice Sets a particular underwriter's limit of how much credit the DAO will allow them to \"create\"\n   * @param underwriterAddress The address of the underwriter for whom the limit shall change\n   * @param limit What the new limit will be set to\n   * Requirements:\n   *\n   * - the caller must have the `OWNER_ROLE`.\n   */\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit)\n    external\n    override\n    onlyAdmin\n    whenNotPaused\n  {\n    require(withinMaxUnderwriterLimit(limit), \"This limit is greater than the max allowed by the protocol\");\n    underwriters[underwriterAddress].governanceLimit = limit;\n    emit GovernanceUpdatedUnderwriterLimit(underwriterAddress, limit);\n  }\n\n  /**\n   * @notice Allows an underwriter to create a new CreditLine for a single borrower\n   * @param _borrower The borrower for whom the CreditLine will be created\n   * @param _limit The maximum amount a borrower can drawdown from this CreditLine\n   * @param _interestApr The interest amount, on an annualized basis (APR, so non-compounding), expressed as an integer.\n   *  We assume 8 digits of precision. For example, to submit 15.34%, you would pass up 15340000,\n   *  and 5.34% would be 5340000\n   * @param _paymentPeriodInDays How many days in each payment period.\n   *  ie. the frequency with which they need to make payments.\n   * @param _termInDays Number of days in the credit term. It is used to set the `termEndBlock` upon first drawdown.\n   *  ie. The credit line should be fully paid off {_termIndays} days after the first drawdown.\n   * @param _lateFeeApr The additional interest you will pay if you are late. For example, if this is 3%, and your\n   *  normal rate is 15%, then you will pay 18% while you are late.\n   *\n   * Requirements:\n   *\n   * - the caller must be an underwriter with enough limit (see `setUnderwriterGovernanceLimit`)\n   */\n  function createCreditLine(\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr\n  ) public override whenNotPaused returns (address) {\n    Underwriter storage underwriter = underwriters[msg.sender];\n    Borrower storage borrower = borrowers[_borrower];\n    require(underwriterCanCreateThisCreditLine(_limit, underwriter), \"The underwriter cannot create this credit line\");\n\n    address clAddress = getCreditLineFactory().createCreditLine();\n    CreditLine cl = CreditLine(clAddress);\n    cl.initialize(\n      address(this),\n      _borrower,\n      msg.sender,\n      _limit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr\n    );\n\n    underwriter.creditLines.push(clAddress);\n    borrower.creditLines.push(clAddress);\n    creditLines[clAddress] = clAddress;\n    emit CreditLineCreated(_borrower, clAddress);\n\n    cl.grantRole(keccak256(\"OWNER_ROLE\"), config.protocolAdminAddress());\n    cl.authorizePool(address(config));\n    return clAddress;\n  }\n\n  /**\n   * @notice Allows a borrower to drawdown on their creditline.\n   *  `amount` USDC is sent to the borrower, and the credit line accounting is updated.\n   * @param creditLineAddress The creditline from which they would like to drawdown\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to drawdown\n   *\n   * Requirements:\n   *\n   * - the caller must be the borrower on the creditLine\n   */\n  function drawdown(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    Borrower storage borrower = borrowers[msg.sender];\n    require(borrower.creditLines.length > 0, \"No credit lines exist for this borrower\");\n    require(amount > 0, \"Must drawdown more than zero\");\n    require(cl.borrower() == msg.sender, \"You are not the borrower of this credit line\");\n    require(withinTransactionLimit(amount), \"Amount is over the per-transaction limit\");\n    uint256 unappliedBalance = getUSDCBalance(creditLineAddress);\n    require(\n      withinCreditLimit(amount, unappliedBalance, cl),\n      \"The borrower does not have enough credit limit for this drawdown\"\n    );\n\n    uint256 balance = cl.balance();\n\n    if (balance == 0) {\n      cl.setInterestAccruedAsOfBlock(blockNumber());\n      cl.setLastFullPaymentBlock(blockNumber());\n    }\n\n    IPool pool = config.getPool();\n\n    // If there is any balance on the creditline that has not been applied yet, then use that first before\n    // drawing down from the pool. This is to support cases where the borrower partially pays back the\n    // principal before the due date, but then decides to drawdown again\n    uint256 amountToTransferFromCL;\n    if (unappliedBalance > 0) {\n      if (amount > unappliedBalance) {\n        amountToTransferFromCL = unappliedBalance;\n        amount = amount.sub(unappliedBalance);\n      } else {\n        amountToTransferFromCL = amount;\n        amount = 0;\n      }\n      bool success = pool.transferFrom(creditLineAddress, msg.sender, amountToTransferFromCL);\n      require(success, \"Failed to drawdown\");\n    }\n\n    (uint256 interestOwed, uint256 principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(cl, blockNumber());\n    balance = balance.add(amount);\n\n    updateCreditLineAccounting(cl, balance, interestOwed, principalOwed);\n\n    // Must put this after we update the credit line accounting, so we're using the latest\n    // interestOwed\n    require(!isLate(cl), \"Cannot drawdown when payments are past due\");\n    emit DrawdownMade(msg.sender, address(cl), amount.add(amountToTransferFromCL));\n\n    if (amount > 0) {\n      bool success = pool.drawdown(msg.sender, amount);\n      require(success, \"Failed to drawdown\");\n    }\n  }\n\n  /**\n   * @notice Allows a borrower to repay their loan. Payment is *collected* immediately (by sending it to\n   *  the individual CreditLine), but it is not *applied* unless it is after the nextDueBlock, or until we assess\n   *  the credit line (ie. payment period end).\n   *  Any amounts over the minimum payment will be applied to outstanding principal (reducing the effective\n   *  interest rate). If there is still any left over, it will remain in the USDC Balance\n   *  of the CreditLine, which is held distinct from the Pool amounts, and can not be withdrawn by LP's.\n   * @param creditLineAddress The credit line to be paid back\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to pay\n   */\n  function pay(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    require(amount > 0, \"Must pay more than zero\");\n    CreditLine cl = CreditLine(creditLineAddress);\n\n    collectPayment(cl, amount);\n    assessCreditLine(creditLineAddress);\n  }\n\n  /**\n   * @notice Assesses a particular creditLine. This will apply payments, which will update accounting and\n   *  distribute gains or losses back to the pool accordingly. This function is idempotent, and anyone\n   *  is allowed to call it.\n   * @param creditLineAddress The creditline that should be assessed.\n   */\n  function assessCreditLine(address creditLineAddress)\n    public\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    // Do not assess until a full period has elapsed or past due\n    require(cl.balance() > 0, \"Must have balance to assess credit line\");\n\n    // Don't assess credit lines early!\n    if (blockNumber() < cl.nextDueBlock() && !isLate(cl)) {\n      return;\n    }\n\n    uint256 blockToAssess = calculateNextDueBlock(cl);\n    cl.setNextDueBlock(blockToAssess);\n\n    // We always want to assess for the most recently *past* nextDueBlock.\n    // So if the recalculation above sets the nextDueBlock into the future,\n    // then ensure we pass in the one just before this.\n    if (blockToAssess > blockNumber()) {\n      uint256 blocksPerPeriod = cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n      blockToAssess = blockToAssess.sub(blocksPerPeriod);\n    }\n    _applyPayment(cl, getUSDCBalance(address(cl)), blockToAssess);\n  }\n\n  function applyPayment(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    require(cl.borrower() == msg.sender, \"You do not belong to this credit line\");\n    _applyPayment(cl, amount, blockNumber());\n  }\n\n  function migrateCreditLine(\n    CreditLine clToMigrate,\n    address borrower,\n    uint256 limit,\n    uint256 interestApr,\n    uint256 paymentPeriodInDays,\n    uint256 termInDays,\n    uint256 lateFeeApr\n  ) public {\n    require(clToMigrate.underwriter() == msg.sender, \"Caller must be the underwriter\");\n    require(clToMigrate.limit() > 0, \"Can't migrate empty credit line\");\n    address newClAddress = createCreditLine(borrower, limit, interestApr, paymentPeriodInDays, termInDays, lateFeeApr);\n\n    CreditLine newCl = CreditLine(newClAddress);\n\n    // Set accounting state vars.\n    newCl.setBalance(clToMigrate.balance());\n    newCl.setInterestOwed(clToMigrate.interestOwed());\n    newCl.setPrincipalOwed(clToMigrate.principalOwed());\n    newCl.setTermEndBlock(clToMigrate.termEndBlock());\n    newCl.setNextDueBlock(clToMigrate.nextDueBlock());\n    newCl.setInterestAccruedAsOfBlock(clToMigrate.interestAccruedAsOfBlock());\n    newCl.setWritedownAmount(clToMigrate.writedownAmount());\n    newCl.setLastFullPaymentBlock(clToMigrate.lastFullPaymentBlock());\n\n    // Close out the original credit line\n    clToMigrate.setLimit(0);\n    clToMigrate.setBalance(0);\n    bool success = config.getPool().transferFrom(\n      address(clToMigrate),\n      address(newCl),\n      config.getUSDC().balanceOf(address(clToMigrate))\n    );\n    require(success, \"Failed to transfer funds\");\n  }\n\n  // Public View Functions (Getters)\n\n  /**\n   * @notice Simple getter for the creditlines of a given underwriter\n   * @param underwriterAddress The underwriter address you would like to see the credit lines of.\n   */\n  function getUnderwriterCreditLines(address underwriterAddress) public view returns (address[] memory) {\n    return underwriters[underwriterAddress].creditLines;\n  }\n\n  /**\n   * @notice Simple getter for the creditlines of a given borrower\n   * @param borrowerAddress The borrower address you would like to see the credit lines of.\n   */\n  function getBorrowerCreditLines(address borrowerAddress) public view returns (address[] memory) {\n    return borrowers[borrowerAddress].creditLines;\n  }\n\n  /**\n   * @notice This function is only meant to be used by frontends. It returns the total\n   * payment due for a given creditLine as of the provided blocknumber. Returns 0 if no\n   * payment is due (e.g. asOfBLock is before the nextDueBlock)\n   * @param creditLineAddress The creditLine to calculate the payment for\n   * @param asOfBLock The block to use for the payment calculation, if it is set to 0, uses the current block number\n   */\n  function getNextPaymentAmount(address creditLineAddress, uint256 asOfBLock)\n    external\n    view\n    override\n    onlyValidCreditLine(creditLineAddress)\n    returns (uint256)\n  {\n    if (asOfBLock == 0) {\n      asOfBLock = blockNumber();\n    }\n    CreditLine cl = CreditLine(creditLineAddress);\n\n    if (asOfBLock < cl.nextDueBlock() && !isLate(cl)) {\n      return 0;\n    }\n\n    (uint256 interestAccrued, uint256 principalAccrued) = Accountant.calculateInterestAndPrincipalAccrued(\n      cl,\n      asOfBLock,\n      config.getLatenessGracePeriodInDays()\n    );\n    return cl.interestOwed().add(interestAccrued).add(cl.principalOwed().add(principalAccrued));\n  }\n\n  function updateGoldfinchConfig() external onlyAdmin {\n    config = GoldfinchConfig(config.configAddress());\n  }\n\n  /*\n   * Internal Functions\n   */\n\n  /**\n   * @notice Collects `amount` of payment for a given credit line. This sends money from the payer to the credit line.\n   *  Note that payment is not *applied* when calling this function. Only collected (ie. held) for later application.\n   * @param cl The CreditLine the payment will be collected for.\n   * @param amount The amount, in USDC atomic units, to be collected\n   */\n  function collectPayment(CreditLine cl, uint256 amount) internal {\n    require(withinTransactionLimit(amount), \"Amount is over the per-transaction limit\");\n\n    emit PaymentCollected(msg.sender, address(cl), amount);\n\n    bool success = config.getPool().transferFrom(msg.sender, address(cl), amount);\n    require(success, \"Failed to collect payment\");\n  }\n\n  /**\n   * @notice Applies `amount` of payment for a given credit line. This moves already collected money into the Pool.\n   *  It also updates all the accounting variables. Note that interest is always paid back first, then principal.\n   *  Any extra after paying the minimum will go towards existing principal (reducing the\n   *  effective interest rate). Any extra after the full loan has been paid off will remain in the\n   *  USDC Balance of the creditLine, where it will be automatically used for the next drawdown.\n   * @param cl The CreditLine the payment will be collected for.\n   * @param amount The amount, in USDC atomic units, to be applied\n   * @param blockNumber The blockNumber on which accrual calculations should be based. This allows us\n   *  to be precise when we assess a Credit Line\n   */\n  function _applyPayment(\n    CreditLine cl,\n    uint256 amount,\n    uint256 blockNumber\n  ) internal {\n    (uint256 paymentRemaining, uint256 interestPayment, uint256 principalPayment) = handlePayment(\n      cl,\n      amount,\n      blockNumber\n    );\n\n    IPool pool = config.getPool();\n    updateWritedownAmounts(cl, pool);\n\n    if (interestPayment > 0 || principalPayment > 0) {\n      emit PaymentApplied(cl.borrower(), address(cl), interestPayment, principalPayment, paymentRemaining);\n      pool.collectInterestAndPrincipal(address(cl), interestPayment, principalPayment);\n    }\n  }\n\n  function handlePayment(\n    CreditLine cl,\n    uint256 paymentAmount,\n    uint256 asOfBlock\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 interestOwed, uint256 principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(cl, asOfBlock);\n    Accountant.PaymentAllocation memory pa = Accountant.allocatePayment(\n      paymentAmount,\n      cl.balance(),\n      interestOwed,\n      principalOwed\n    );\n\n    uint256 newBalance = cl.balance().sub(pa.principalPayment);\n    // Apply any additional payment towards the balance\n    newBalance = newBalance.sub(pa.additionalBalancePayment);\n\n    uint256 totalPrincipalPayment = cl.balance().sub(newBalance);\n    uint256 paymentRemaining = paymentAmount.sub(pa.interestPayment).sub(totalPrincipalPayment);\n\n    updateCreditLineAccounting(\n      cl,\n      newBalance,\n      interestOwed.sub(pa.interestPayment),\n      principalOwed.sub(pa.principalPayment)\n    );\n\n    assert(paymentRemaining.add(pa.interestPayment).add(totalPrincipalPayment) == paymentAmount);\n\n    return (paymentRemaining, pa.interestPayment, totalPrincipalPayment);\n  }\n\n  function updateWritedownAmounts(CreditLine cl, IPool pool) internal {\n    (uint256 writedownPercent, uint256 writedownAmount) = Accountant.calculateWritedownFor(\n      cl,\n      blockNumber(),\n      config.getLatenessGracePeriodInDays(),\n      config.getLatenessMaxDays()\n    );\n\n    if (writedownPercent == 0 && cl.writedownAmount() == 0) {\n      return;\n    }\n    int256 writedownDelta = int256(cl.writedownAmount()) - int256(writedownAmount);\n    cl.setWritedownAmount(writedownAmount);\n    if (writedownDelta > 0) {\n      // If writedownDelta is positive, that means we got money back. So subtract from totalWritedowns.\n      totalWritedowns = totalWritedowns.sub(uint256(writedownDelta));\n    } else {\n      totalWritedowns = totalWritedowns.add(uint256(writedownDelta * -1));\n    }\n    pool.distributeLosses(address(cl), writedownDelta);\n  }\n\n  function isLate(CreditLine cl) internal view returns (bool) {\n    uint256 blocksElapsedSinceFullPayment = blockNumber().sub(cl.lastFullPaymentBlock());\n    return blocksElapsedSinceFullPayment > cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n  }\n\n  function getCreditLineFactory() internal view returns (CreditLineFactory) {\n    return CreditLineFactory(config.getAddress(uint256(ConfigOptions.Addresses.CreditLineFactory)));\n  }\n\n  function updateAndGetInterestAndPrincipalOwedAsOf(CreditLine cl, uint256 blockNumber)\n    internal\n    returns (uint256, uint256)\n  {\n    (uint256 interestAccrued, uint256 principalAccrued) = Accountant.calculateInterestAndPrincipalAccrued(\n      cl,\n      blockNumber,\n      config.getLatenessGracePeriodInDays()\n    );\n    if (interestAccrued > 0) {\n      // If we've accrued any interest, update interestAccruedAsOfBLock to the block that we've\n      // calculated interest for. If we've not accrued any interest, then we keep the old value so the next\n      // time the entire period is taken into account.\n      cl.setInterestAccruedAsOfBlock(blockNumber);\n    }\n    return (cl.interestOwed().add(interestAccrued), cl.principalOwed().add(principalAccrued));\n  }\n\n  function withinCreditLimit(\n    uint256 amount,\n    uint256 unappliedBalance,\n    CreditLine cl\n  ) internal view returns (bool) {\n    return cl.balance().add(amount).sub(unappliedBalance) <= cl.limit();\n  }\n\n  function withinTransactionLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n  }\n\n  function calculateNewTermEndBlock(CreditLine cl, uint256 balance) internal view returns (uint256) {\n    // If there's no balance, there's no loan, so there's no term end block\n    if (balance == 0) {\n      return 0;\n    }\n    // Don't allow any weird bugs where we add to your current end block. This\n    // function should only be used on new credit lines, when we are setting them up\n    if (cl.termEndBlock() != 0) {\n      return cl.termEndBlock();\n    }\n    return blockNumber().add(BLOCKS_PER_DAY.mul(cl.termInDays()));\n  }\n\n  function calculateNextDueBlock(CreditLine cl) internal view returns (uint256) {\n    uint256 blocksPerPeriod = cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n    uint256 balance = cl.balance();\n    uint256 nextDueBlock = cl.nextDueBlock();\n    uint256 curBlockNumber = blockNumber();\n    // You must have just done your first drawdown\n    if (nextDueBlock == 0 && balance > 0) {\n      return curBlockNumber.add(blocksPerPeriod);\n    }\n\n    // Active loan that has entered a new period, so return the *next* nextDueBlock.\n    // But never return something after the termEndBlock\n    if (balance > 0 && curBlockNumber >= nextDueBlock) {\n      uint256 blocksToAdvance = (curBlockNumber.sub(nextDueBlock).div(blocksPerPeriod)).add(1).mul(blocksPerPeriod);\n      nextDueBlock = nextDueBlock.add(blocksToAdvance);\n      return Math.min(nextDueBlock, cl.termEndBlock());\n    }\n\n    // Your paid off, or have not taken out a loan yet, so no next due block.\n    if (balance == 0 && nextDueBlock != 0) {\n      return 0;\n    }\n    // Active loan in current period, where we've already set the nextDueBlock correctly, so should not change.\n    if (balance > 0 && curBlockNumber < nextDueBlock) {\n      return nextDueBlock;\n    }\n    revert(\"Error: could not calculate next due block.\");\n  }\n\n  function blockNumber() internal view virtual returns (uint256) {\n    return block.number;\n  }\n\n  function underwriterCanCreateThisCreditLine(uint256 newAmount, Underwriter storage underwriter)\n    internal\n    view\n    returns (bool)\n  {\n    uint256 underwriterLimit = underwriter.governanceLimit;\n    require(underwriterLimit != 0, \"underwriter does not have governance limit\");\n    uint256 creditCurrentlyExtended = getCreditCurrentlyExtended(underwriter);\n    uint256 totalToBeExtended = creditCurrentlyExtended.add(newAmount);\n    return totalToBeExtended <= underwriterLimit;\n  }\n\n  function withinMaxUnderwriterLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.MaxUnderwriterLimit));\n  }\n\n  function getCreditCurrentlyExtended(Underwriter storage underwriter) internal view returns (uint256) {\n    uint256 creditExtended;\n    uint256 length = underwriter.creditLines.length;\n    for (uint256 i = 0; i < length; i++) {\n      CreditLine cl = CreditLine(underwriter.creditLines[i]);\n      creditExtended = creditExtended.add(cl.limit());\n    }\n    return creditExtended;\n  }\n\n  function updateCreditLineAccounting(\n    CreditLine cl,\n    uint256 balance,\n    uint256 interestOwed,\n    uint256 principalOwed\n  ) internal nonReentrant {\n    // subtract cl from total loans outstanding\n    totalLoansOutstanding = totalLoansOutstanding.sub(cl.balance());\n\n    cl.setBalance(balance);\n    cl.setInterestOwed(interestOwed);\n    cl.setPrincipalOwed(principalOwed);\n\n    // This resets lastFullPaymentBlock. These conditions assure that they have\n    // indeed paid off all their interest and they have a real nextDueBlock. (ie. creditline isn't pre-drawdown)\n    uint256 nextDueBlock = cl.nextDueBlock();\n    if (interestOwed == 0 && nextDueBlock != 0) {\n      // If interest was fully paid off, then set the last full payment as the previous due block\n      uint256 mostRecentLastDueBlock;\n      if (blockNumber() < nextDueBlock) {\n        uint256 blocksPerPeriod = cl.paymentPeriodInDays().mul(BLOCKS_PER_DAY);\n        mostRecentLastDueBlock = nextDueBlock.sub(blocksPerPeriod);\n      } else {\n        mostRecentLastDueBlock = nextDueBlock;\n      }\n      cl.setLastFullPaymentBlock(mostRecentLastDueBlock);\n    }\n\n    // Add new amount back to total loans outstanding\n    totalLoansOutstanding = totalLoansOutstanding.add(balance);\n\n    cl.setTermEndBlock(calculateNewTermEndBlock(cl, balance)); // pass in balance as a gas optimization\n    cl.setNextDueBlock(calculateNextDueBlock(cl));\n  }\n\n  function getUSDCBalance(address _address) internal view returns (uint256) {\n    return config.getUSDC().balanceOf(_address);\n  }\n\n  modifier onlyValidCreditLine(address clAddress) {\n    require(creditLines[clAddress] != address(0), \"Unknown credit line\");\n    _;\n  }\n}\n"
    },
    "contracts/test/TestCreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../protocol/core/CreditDesk.sol\";\n\ncontract TestCreditDesk is CreditDesk {\n  uint256 _blockNumberForTest;\n\n  function _setTotalLoansOutstanding(uint256 amount) public {\n    totalLoansOutstanding = amount;\n  }\n\n  function _setBlockNumberForTest(uint256 blockNumber) public {\n    _blockNumberForTest = blockNumber;\n  }\n\n  function blockNumber() internal view override returns (uint256) {\n    if (_blockNumberForTest == 0) {\n      return super.blockNumber();\n    } else {\n      return _blockNumberForTest;\n    }\n  }\n\n  function blockNumberForTest() public view returns (uint256) {\n    return blockNumber();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}